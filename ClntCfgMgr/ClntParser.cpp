#define YY_ClntParser_h_included
#define YY_USE_CLASS

/*  A Bison++ parser, made from ClntParser.y  */

/* with Bison++ version bison++ Version 1.21.9-1, adapted from GNU bison by
coetmeur@icdc.fr Maintained by Magnus Ekdahl <magnus@debian.org>
 */

#define YY_USE_CLASS

#line 1 "../bison++/bison.cc"
/* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
/* Skeleton output parser for bison,
   Copyright (C) 1984, 1989, 1990 Bob Corbett and Richard Stallman

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 1, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

   As a special exception, when this file is copied by Bison++ into a
   Bison++ output file, you may use that output file without restriction.
   This special exception was added by the Free Software Foundation
   in version 1.24 of Bison, and has been in Bison++ since 1.21.9.

*/

/* HEADER SECTION */
#if defined(_MSDOS) || defined(MSDOS) || defined(__MSDOS__)
#define __MSDOS_AND_ALIKE
#endif

#if defined(_WINDOWS) && defined(_MSC_VER)
#define __HAVE_NO_ALLOCA
#define __MSDOS_AND_ALIKE
#endif

#ifndef alloca
#if defined(__GNUC__)
#define alloca __builtin_alloca

#elif (!defined(__STDC__) && defined(sparc)) || defined(__sparc__) || defined(__sparc) || \
    defined(__sgi)
#include <alloca.h>

#elif defined(__MSDOS_AND_ALIKE)
#include <malloc.h>
#ifndef __TURBOC__
/* MS C runtime lib */
#define alloca _alloca
#endif

#elif defined(_AIX)
/* pragma must be put before any C/C++ instruction !! */
#pragma alloca
#include <malloc.h>

#elif defined(__hpux)
#ifdef __cplusplus
extern "C" {
void *alloca(unsigned int);
};
#else  /* not __cplusplus */
void *alloca();
#endif /* not __cplusplus */

#endif /* not _AIX  not MSDOS, or __TURBOC__ or _AIX, not sparc.  */
#endif /* alloca not defined.  */

#ifdef c_plusplus
#ifndef __cplusplus
#define __cplusplus
#endif
#endif

#ifdef __cplusplus
#ifndef YY_USE_CLASS
/*#warning "For C++ its recomended to use bison++, otherwise classes won't be
 * generated"*/
#endif
#else
#ifndef __STDC__
#define const
#endif
#ifdef YY_USE_CLASS
#error "This is a C++ header generated by bison++, please use a C++ compiler!"
#endif
#endif

#include <stdio.h>
#define YYBISON 1

#line 88 "../bison++/bison.cc"
#line 3 "ClntParser.y"

#include "ClntCfgAddr.h"
#include "ClntCfgIA.h"
#include "ClntCfgIface.h"
#include "ClntCfgMgr.h"
#include "ClntCfgPD.h"
#include "ClntCfgTA.h"
#include "ClntParsGlobalOpt.h"
#include "ClntParser.h"
#include "Container.h"
#include "DHCPConst.h"
#include "Logger.h"
#include "OptAddr.h"
#include "OptAddrLst.h"
#include "OptGeneric.h"
#include "OptString.h"
#include "SmartPtr.h"
#include <iostream>
#include <malloc.h>
#include <string>
#include <vector>

using namespace std;

#define YY_USE_CLASS
#line 30 "ClntParser.y"

#include "FlexLexer.h"
#define YY_ClntParser_MEMBERS                                             \
  yyFlexLexer *Lex_;                                                      \
  /*List of options in scope stack,the most fresh is last in the list*/   \
  List(TClntParsGlobalOpt) ParserOptStack;                                \
  /*List of parsed interfaces/IAs/Addresses, last */                      \
  /*interface/IA/address is just being parsing or have been just parsed*/ \
  List(TClntCfgIface) ClntCfgIfaceLst;                                    \
  List(TClntCfgIA) ClntCfgIALst;                                          \
  List(TClntCfgTA) ClntCfgTALst;                                          \
  List(TClntCfgPD) ClntCfgPDLst;                                          \
  List(TClntCfgAddr) ClntCfgAddrLst;                                      \
  DigestTypesLst DigestLst;                                               \
  /*Pointer to list which should contain either rejected servers or */    \
  /*preffered servers*/                                                   \
  List(THostID) PresentStationLst;                                        \
  List(TIPv6Addr) PresentAddrLst;                                         \
  List(TClntCfgPrefix) PrefixLst;                                         \
  List(std::string) PresentStringLst;                                     \
  List(TOptVendorSpecInfo) VendorSpec;                                    \
  bool IfaceDefined(int ifaceNr);                                         \
  bool IfaceDefined(const std::string &ifaceName);                        \
  bool StartIfaceDeclaration(const std::string &ifaceName);               \
  bool StartIfaceDeclaration(int ifindex);                                \
  bool EndIfaceDeclaration();                                             \
  void EmptyIface();                                                      \
  bool StartIADeclaration(bool aggregation);                              \
  void EndIADeclaration();                                                \
  bool StartPDDeclaration();                                              \
  bool EndPDDeclaration();                                                \
  void EmptyIA();                                                         \
  void EmptyAddr();                                                       \
  TClntCfgMgr *CfgMgr;                                                    \
  bool iaidSet;                                                           \
  unsigned int iaid;                                                      \
  unsigned int AddrCount_;                                                \
  virtual ~ClntParser();                                                  \
  EDUIDType DUIDType;                                                     \
  int DUIDEnterpriseNumber;                                               \
  SPtr<TDUID> DUIDEnterpriseID;
#define YY_ClntParser_CONSTRUCTOR_PARAM yyFlexLexer *lex
#define YY_ClntParser_CONSTRUCTOR_CODE             \
  Lex_ = lex;                                      \
  ParserOptStack.append(new TClntParsGlobalOpt()); \
  ParserOptStack.getFirst()->setIAIDCnt(1);        \
  ParserOptStack.getLast();                        \
  DUIDType = DUID_TYPE_NOT_DEFINED;                \
  DUIDEnterpriseID.reset();                        \
  AddrCount_ = 0;                                  \
  CfgMgr = 0;                                      \
  iaidSet = false;                                 \
  iaid = 0xffffffff;                               \
  DUIDEnterpriseNumber = -1;                       \
  yynerrs = 0;                                     \
  yychar = 0;

#line 91 "ClntParser.y"
typedef union {
  int ival;
  char *strval;
  struct SDuid {
    int length;
    char *duid;
  } duidval;
  char addrval[16];
} yy_ClntParser_stype;
#define YY_ClntParser_STYPE yy_ClntParser_stype
#line 102 "ClntParser.y"

namespace std {
extern yy_ClntParser_stype yylval;
}

#line 88 "../bison++/bison.cc"
/* %{ and %header{ and %union, during decl */
#define YY_ClntParser_BISON 1

#ifndef YY_ClntParser_COMPATIBILITY
#ifndef YY_USE_CLASS
#define YY_ClntParser_COMPATIBILITY 1
#else
#define YY_ClntParser_COMPATIBILITY 0
#endif
#endif

#if YY_ClntParser_COMPATIBILITY != 0
/* backward compatibility */
#ifdef YYLTYPE
#ifndef YY_ClntParser_LTYPE
#define YY_ClntParser_LTYPE YYLTYPE
#endif
#endif
/* Testing alternative bison solution
   /#ifdef YYSTYPE*/
#ifndef YY_ClntParser_STYPE
#define YY_ClntParser_STYPE YYSTYPE
#endif
/*#endif*/
#ifdef YYDEBUG
#ifndef YY_ClntParser_DEBUG
#define YY_ClntParser_DEBUG YYDEBUG
#endif
#endif

/* use goto to be compatible */
#ifndef YY_ClntParser_USE_GOTO
#define YY_ClntParser_USE_GOTO 1
#endif
#endif

/* use no goto to be clean in C++ */
#ifndef YY_ClntParser_USE_GOTO
#define YY_ClntParser_USE_GOTO 0
#endif

#ifndef YY_ClntParser_PURE

#line 130 "../bison++/bison.cc"

#line 130 "../bison++/bison.cc"
/*  YY_ClntParser_PURE */
#endif

/* section apres lecture def, avant lecture grammaire S2 */

#line 134 "../bison++/bison.cc"

#line 134 "../bison++/bison.cc"
/* prefix */
#ifndef YY_ClntParser_DEBUG

#line 136 "../bison++/bison.cc"
#define YY_ClntParser_DEBUG 1

#line 136 "../bison++/bison.cc"
/* YY_ClntParser_DEBUG */
#endif

#ifndef YY_ClntParser_LSP_NEEDED

#line 141 "../bison++/bison.cc"

#line 141 "../bison++/bison.cc"
/* YY_ClntParser_LSP_NEEDED*/
#endif

/* DEFAULT LTYPE*/
#ifdef YY_ClntParser_LSP_NEEDED
#ifndef YY_ClntParser_LTYPE
#ifndef BISON_YYLTYPE_ISDECLARED
#define BISON_YYLTYPE_ISDECLARED
typedef struct yyltype {
  int timestamp;
  int first_line;
  int first_column;
  int last_line;
  int last_column;
  char *text;
} yyltype;

#endif
#define YY_ClntParser_LTYPE yyltype
#endif
#endif
/* DEFAULT STYPE*/
/* We used to use `unsigned long' as YY_ClntParser_STYPE on MSDOS,
   but it seems better to be consistent.
   Most programs should declare their own type anyway.  */

#ifndef YY_ClntParser_STYPE
#define YY_ClntParser_STYPE int
#endif
/* DEFAULT MISCELANEOUS */
#ifndef YY_ClntParser_PARSE
#define YY_ClntParser_PARSE yyparse
#endif
#ifndef YY_ClntParser_LEX
#define YY_ClntParser_LEX yylex
#endif
#ifndef YY_ClntParser_LVAL
#define YY_ClntParser_LVAL yylval
#endif
#ifndef YY_ClntParser_LLOC
#define YY_ClntParser_LLOC yylloc
#endif
#ifndef YY_ClntParser_CHAR
#define YY_ClntParser_CHAR yychar
#endif
#ifndef YY_ClntParser_NERRS
#define YY_ClntParser_NERRS yynerrs
#endif
#ifndef YY_ClntParser_DEBUG_FLAG
#define YY_ClntParser_DEBUG_FLAG yydebug
#endif
#ifndef YY_ClntParser_ERROR
#define YY_ClntParser_ERROR yyerror
#endif

#ifndef YY_ClntParser_PARSE_PARAM
#ifndef YY_USE_CLASS
#ifdef YYPARSE_PARAM
#define YY_ClntParser_PARSE_PARAM void *YYPARSE_PARAM
#else
#ifndef __STDC__
#ifndef __cplusplus
#define YY_ClntParser_PARSE_PARAM
#endif
#endif
#endif
#endif
#ifndef YY_ClntParser_PARSE_PARAM
#define YY_ClntParser_PARSE_PARAM void
#endif
#endif

#if YY_ClntParser_COMPATIBILITY != 0
/* backward compatibility */
#ifdef YY_ClntParser_LTYPE
#ifndef YYLTYPE
#define YYLTYPE YY_ClntParser_LTYPE
#else
/* WARNING obsolete !!! user defined YYLTYPE not reported into generated header
 */
#endif
#endif

/* Removed due to bison compabilityproblems
/#ifndef YYSTYPE
/#define YYSTYPE YY_ClntParser_STYPE
/#else*/
/* WARNING obsolete !!! user defined YYSTYPE not reported into generated header
 */
/*#endif*/

#ifdef YY_ClntParser_PURE
#ifndef YYPURE
#define YYPURE YY_ClntParser_PURE
#endif
#endif

#ifdef YY_ClntParser_DEBUG
#ifndef YYDEBUG
#define YYDEBUG YY_ClntParser_DEBUG
#endif
#endif

#ifndef YY_ClntParser_ERROR_VERBOSE
#ifdef YYERROR_VERBOSE
#define YY_ClntParser_ERROR_VERBOSE YYERROR_VERBOSE
#endif
#endif

#ifndef YY_ClntParser_LSP_NEEDED
#ifdef YYLSP_NEEDED
#define YY_ClntParser_LSP_NEEDED YYLSP_NEEDED
#endif
#endif

#endif

#ifndef YY_USE_CLASS
/* TOKEN C */

#line 263 "../bison++/bison.cc"
#define T1_ 258
#define T2_ 259
#define PREF_TIME_ 260
#define DNS_SERVER_ 261
#define VALID_TIME_ 262
#define UNICAST_ 263
#define NTP_SERVER_ 264
#define DOMAIN_ 265
#define TIME_ZONE_ 266
#define SIP_SERVER_ 267
#define SIP_DOMAIN_ 268
#define NIS_SERVER_ 269
#define NISP_SERVER_ 270
#define NIS_DOMAIN_ 271
#define NISP_DOMAIN_ 272
#define FQDN_ 273
#define FQDN_S_ 274
#define DDNS_PROTOCOL_ 275
#define DDNS_TIMEOUT_ 276
#define LIFETIME_ 277
#define VENDOR_SPEC_ 278
#define IFACE_ 279
#define NO_CONFIG_ 280
#define REJECT_SERVERS_ 281
#define PREFERRED_SERVERS_ 282
#define IA_ 283
#define TA_ 284
#define IAID_ 285
#define ADDRESS_KEYWORD_ 286
#define NAME_ 287
#define IPV6ADDR_ 288
#define WORKDIR_ 289
#define RAPID_COMMIT_ 290
#define OPTION_ 291
#define SCRIPT_ 292
#define LOGNAME_ 293
#define LOGLEVEL_ 294
#define LOGMODE_ 295
#define LOGCOLORS_ 296
#define STRING_ 297
#define HEXNUMBER_ 298
#define INTNUMBER_ 299
#define DUID_ 300
#define STRICT_RFC_NO_ROUTING_ 301
#define SKIP_CONFIRM_ 302
#define OBEY_RA_BITS_ 303
#define PD_ 304
#define PREFIX_ 305
#define DOWNLINK_PREFIX_IFACES_ 306
#define DUID_TYPE_ 307
#define DUID_TYPE_LLT_ 308
#define DUID_TYPE_LL_ 309
#define DUID_TYPE_EN_ 310
#define AUTH_METHODS_ 311
#define AUTH_PROTOCOL_ 312
#define AUTH_ALGORITHM_ 313
#define AUTH_REPLAY_ 314
#define AUTH_REALM_ 315
#define DIGEST_NONE_ 316
#define DIGEST_PLAIN_ 317
#define DIGEST_HMAC_MD5_ 318
#define DIGEST_HMAC_SHA1_ 319
#define DIGEST_HMAC_SHA224_ 320
#define DIGEST_HMAC_SHA256_ 321
#define DIGEST_HMAC_SHA384_ 322
#define DIGEST_HMAC_SHA512_ 323
#define STATELESS_ 324
#define ANON_INF_REQUEST_ 325
#define INSIST_MODE_ 326
#define INACTIVE_MODE_ 327
#define EXPERIMENTAL_ 328
#define ADDR_PARAMS_ 329
#define REMOTE_AUTOCONF_ 330
#define AFTR_ 331
#define ROUTING_ 332
#define BIND_TO_ADDR_ 333
#define ADDRESS_LIST_KEYWORD_ 334
#define STRING_KEYWORD_ 335
#define DUID_KEYWORD_ 336
#define HEX_KEYWORD_ 337
#define RECONFIGURE_ 338

#line 263 "../bison++/bison.cc"
/* #defines tokens */
#else
/* CLASS */
#ifndef YY_ClntParser_CLASS
#define YY_ClntParser_CLASS ClntParser
#endif
#ifndef YY_ClntParser_INHERIT
#define YY_ClntParser_INHERIT
#endif
#ifndef YY_ClntParser_MEMBERS
#define YY_ClntParser_MEMBERS
#endif
#ifndef YY_ClntParser_LEX_BODY
#define YY_ClntParser_LEX_BODY
#endif
#ifndef YY_ClntParser_ERROR_BODY
#define YY_ClntParser_ERROR_BODY
#endif
#ifndef YY_ClntParser_CONSTRUCTOR_PARAM
#define YY_ClntParser_CONSTRUCTOR_PARAM
#endif
#ifndef YY_ClntParser_CONSTRUCTOR_CODE
#define YY_ClntParser_CONSTRUCTOR_CODE
#endif
#ifndef YY_ClntParser_CONSTRUCTOR_INIT
#define YY_ClntParser_CONSTRUCTOR_INIT
#endif
/* choose between enum and const */
#ifndef YY_ClntParser_USE_CONST_TOKEN
#define YY_ClntParser_USE_CONST_TOKEN 0
/* yes enum is more compatible with flex,  */
/* so by default we use it */
#endif
#if YY_ClntParser_USE_CONST_TOKEN != 0
#ifndef YY_ClntParser_ENUM_TOKEN
#define YY_ClntParser_ENUM_TOKEN yy_ClntParser_enum_token
#endif
#endif

class YY_ClntParser_CLASS YY_ClntParser_INHERIT {
 public:
#if YY_ClntParser_USE_CONST_TOKEN != 0
  /* static const int token ... */

#line 307 "../bison++/bison.cc"
  static const int T1_;
  static const int T2_;
  static const int PREF_TIME_;
  static const int DNS_SERVER_;
  static const int VALID_TIME_;
  static const int UNICAST_;
  static const int NTP_SERVER_;
  static const int DOMAIN_;
  static const int TIME_ZONE_;
  static const int SIP_SERVER_;
  static const int SIP_DOMAIN_;
  static const int NIS_SERVER_;
  static const int NISP_SERVER_;
  static const int NIS_DOMAIN_;
  static const int NISP_DOMAIN_;
  static const int FQDN_;
  static const int FQDN_S_;
  static const int DDNS_PROTOCOL_;
  static const int DDNS_TIMEOUT_;
  static const int LIFETIME_;
  static const int VENDOR_SPEC_;
  static const int IFACE_;
  static const int NO_CONFIG_;
  static const int REJECT_SERVERS_;
  static const int PREFERRED_SERVERS_;
  static const int IA_;
  static const int TA_;
  static const int IAID_;
  static const int ADDRESS_KEYWORD_;
  static const int NAME_;
  static const int IPV6ADDR_;
  static const int WORKDIR_;
  static const int RAPID_COMMIT_;
  static const int OPTION_;
  static const int SCRIPT_;
  static const int LOGNAME_;
  static const int LOGLEVEL_;
  static const int LOGMODE_;
  static const int LOGCOLORS_;
  static const int STRING_;
  static const int HEXNUMBER_;
  static const int INTNUMBER_;
  static const int DUID_;
  static const int STRICT_RFC_NO_ROUTING_;
  static const int SKIP_CONFIRM_;
  static const int OBEY_RA_BITS_;
  static const int PD_;
  static const int PREFIX_;
  static const int DOWNLINK_PREFIX_IFACES_;
  static const int DUID_TYPE_;
  static const int DUID_TYPE_LLT_;
  static const int DUID_TYPE_LL_;
  static const int DUID_TYPE_EN_;
  static const int AUTH_METHODS_;
  static const int AUTH_PROTOCOL_;
  static const int AUTH_ALGORITHM_;
  static const int AUTH_REPLAY_;
  static const int AUTH_REALM_;
  static const int DIGEST_NONE_;
  static const int DIGEST_PLAIN_;
  static const int DIGEST_HMAC_MD5_;
  static const int DIGEST_HMAC_SHA1_;
  static const int DIGEST_HMAC_SHA224_;
  static const int DIGEST_HMAC_SHA256_;
  static const int DIGEST_HMAC_SHA384_;
  static const int DIGEST_HMAC_SHA512_;
  static const int STATELESS_;
  static const int ANON_INF_REQUEST_;
  static const int INSIST_MODE_;
  static const int INACTIVE_MODE_;
  static const int EXPERIMENTAL_;
  static const int ADDR_PARAMS_;
  static const int REMOTE_AUTOCONF_;
  static const int AFTR_;
  static const int ROUTING_;
  static const int BIND_TO_ADDR_;
  static const int ADDRESS_LIST_KEYWORD_;
  static const int STRING_KEYWORD_;
  static const int DUID_KEYWORD_;
  static const int HEX_KEYWORD_;
  static const int RECONFIGURE_;

#line 307 "../bison++/bison.cc"
  /* decl const */
#else
  enum YY_ClntParser_ENUM_TOKEN {
    YY_ClntParser_NULL_TOKEN = 0

#line 310 "../bison++/bison.cc"
    ,
    T1_ = 258,
    T2_ = 259,
    PREF_TIME_ = 260,
    DNS_SERVER_ = 261,
    VALID_TIME_ = 262,
    UNICAST_ = 263,
    NTP_SERVER_ = 264,
    DOMAIN_ = 265,
    TIME_ZONE_ = 266,
    SIP_SERVER_ = 267,
    SIP_DOMAIN_ = 268,
    NIS_SERVER_ = 269,
    NISP_SERVER_ = 270,
    NIS_DOMAIN_ = 271,
    NISP_DOMAIN_ = 272,
    FQDN_ = 273,
    FQDN_S_ = 274,
    DDNS_PROTOCOL_ = 275,
    DDNS_TIMEOUT_ = 276,
    LIFETIME_ = 277,
    VENDOR_SPEC_ = 278,
    IFACE_ = 279,
    NO_CONFIG_ = 280,
    REJECT_SERVERS_ = 281,
    PREFERRED_SERVERS_ = 282,
    IA_ = 283,
    TA_ = 284,
    IAID_ = 285,
    ADDRESS_KEYWORD_ = 286,
    NAME_ = 287,
    IPV6ADDR_ = 288,
    WORKDIR_ = 289,
    RAPID_COMMIT_ = 290,
    OPTION_ = 291,
    SCRIPT_ = 292,
    LOGNAME_ = 293,
    LOGLEVEL_ = 294,
    LOGMODE_ = 295,
    LOGCOLORS_ = 296,
    STRING_ = 297,
    HEXNUMBER_ = 298,
    INTNUMBER_ = 299,
    DUID_ = 300,
    STRICT_RFC_NO_ROUTING_ = 301,
    SKIP_CONFIRM_ = 302,
    OBEY_RA_BITS_ = 303,
    PD_ = 304,
    PREFIX_ = 305,
    DOWNLINK_PREFIX_IFACES_ = 306,
    DUID_TYPE_ = 307,
    DUID_TYPE_LLT_ = 308,
    DUID_TYPE_LL_ = 309,
    DUID_TYPE_EN_ = 310,
    AUTH_METHODS_ = 311,
    AUTH_PROTOCOL_ = 312,
    AUTH_ALGORITHM_ = 313,
    AUTH_REPLAY_ = 314,
    AUTH_REALM_ = 315,
    DIGEST_NONE_ = 316,
    DIGEST_PLAIN_ = 317,
    DIGEST_HMAC_MD5_ = 318,
    DIGEST_HMAC_SHA1_ = 319,
    DIGEST_HMAC_SHA224_ = 320,
    DIGEST_HMAC_SHA256_ = 321,
    DIGEST_HMAC_SHA384_ = 322,
    DIGEST_HMAC_SHA512_ = 323,
    STATELESS_ = 324,
    ANON_INF_REQUEST_ = 325,
    INSIST_MODE_ = 326,
    INACTIVE_MODE_ = 327,
    EXPERIMENTAL_ = 328,
    ADDR_PARAMS_ = 329,
    REMOTE_AUTOCONF_ = 330,
    AFTR_ = 331,
    ROUTING_ = 332,
    BIND_TO_ADDR_ = 333,
    ADDRESS_LIST_KEYWORD_ = 334,
    STRING_KEYWORD_ = 335,
    DUID_KEYWORD_ = 336,
    HEX_KEYWORD_ = 337,
    RECONFIGURE_ = 338

#line 310 "../bison++/bison.cc"
    /* enum token */
  }; /* end of enum declaration */
#endif
 public:
  int YY_ClntParser_PARSE(YY_ClntParser_PARSE_PARAM);
  virtual void YY_ClntParser_ERROR(char *msg) YY_ClntParser_ERROR_BODY;
#ifdef YY_ClntParser_PURE
#ifdef YY_ClntParser_LSP_NEEDED
  virtual int YY_ClntParser_LEX(YY_ClntParser_STYPE *YY_ClntParser_LVAL,
                                YY_ClntParser_LTYPE *YY_ClntParser_LLOC) YY_ClntParser_LEX_BODY;
#else
  virtual int YY_ClntParser_LEX(YY_ClntParser_STYPE *YY_ClntParser_LVAL) YY_ClntParser_LEX_BODY;
#endif
#else
  virtual int YY_ClntParser_LEX() YY_ClntParser_LEX_BODY;
  YY_ClntParser_STYPE YY_ClntParser_LVAL;
#ifdef YY_ClntParser_LSP_NEEDED
  YY_ClntParser_LTYPE YY_ClntParser_LLOC;
#endif
  int YY_ClntParser_NERRS;
  int YY_ClntParser_CHAR;
#endif
#if YY_ClntParser_DEBUG != 0
  int YY_ClntParser_DEBUG_FLAG; /*  nonzero means print parse trace     */
#endif
 public:
  YY_ClntParser_CLASS(YY_ClntParser_CONSTRUCTOR_PARAM);

 public:
  YY_ClntParser_MEMBERS
};
/* other declare folow */
#if YY_ClntParser_USE_CONST_TOKEN != 0

#line 341 "../bison++/bison.cc"
const int YY_ClntParser_CLASS::T1_ = 258;
const int YY_ClntParser_CLASS::T2_ = 259;
const int YY_ClntParser_CLASS::PREF_TIME_ = 260;
const int YY_ClntParser_CLASS::DNS_SERVER_ = 261;
const int YY_ClntParser_CLASS::VALID_TIME_ = 262;
const int YY_ClntParser_CLASS::UNICAST_ = 263;
const int YY_ClntParser_CLASS::NTP_SERVER_ = 264;
const int YY_ClntParser_CLASS::DOMAIN_ = 265;
const int YY_ClntParser_CLASS::TIME_ZONE_ = 266;
const int YY_ClntParser_CLASS::SIP_SERVER_ = 267;
const int YY_ClntParser_CLASS::SIP_DOMAIN_ = 268;
const int YY_ClntParser_CLASS::NIS_SERVER_ = 269;
const int YY_ClntParser_CLASS::NISP_SERVER_ = 270;
const int YY_ClntParser_CLASS::NIS_DOMAIN_ = 271;
const int YY_ClntParser_CLASS::NISP_DOMAIN_ = 272;
const int YY_ClntParser_CLASS::FQDN_ = 273;
const int YY_ClntParser_CLASS::FQDN_S_ = 274;
const int YY_ClntParser_CLASS::DDNS_PROTOCOL_ = 275;
const int YY_ClntParser_CLASS::DDNS_TIMEOUT_ = 276;
const int YY_ClntParser_CLASS::LIFETIME_ = 277;
const int YY_ClntParser_CLASS::VENDOR_SPEC_ = 278;
const int YY_ClntParser_CLASS::IFACE_ = 279;
const int YY_ClntParser_CLASS::NO_CONFIG_ = 280;
const int YY_ClntParser_CLASS::REJECT_SERVERS_ = 281;
const int YY_ClntParser_CLASS::PREFERRED_SERVERS_ = 282;
const int YY_ClntParser_CLASS::IA_ = 283;
const int YY_ClntParser_CLASS::TA_ = 284;
const int YY_ClntParser_CLASS::IAID_ = 285;
const int YY_ClntParser_CLASS::ADDRESS_KEYWORD_ = 286;
const int YY_ClntParser_CLASS::NAME_ = 287;
const int YY_ClntParser_CLASS::IPV6ADDR_ = 288;
const int YY_ClntParser_CLASS::WORKDIR_ = 289;
const int YY_ClntParser_CLASS::RAPID_COMMIT_ = 290;
const int YY_ClntParser_CLASS::OPTION_ = 291;
const int YY_ClntParser_CLASS::SCRIPT_ = 292;
const int YY_ClntParser_CLASS::LOGNAME_ = 293;
const int YY_ClntParser_CLASS::LOGLEVEL_ = 294;
const int YY_ClntParser_CLASS::LOGMODE_ = 295;
const int YY_ClntParser_CLASS::LOGCOLORS_ = 296;
const int YY_ClntParser_CLASS::STRING_ = 297;
const int YY_ClntParser_CLASS::HEXNUMBER_ = 298;
const int YY_ClntParser_CLASS::INTNUMBER_ = 299;
const int YY_ClntParser_CLASS::DUID_ = 300;
const int YY_ClntParser_CLASS::STRICT_RFC_NO_ROUTING_ = 301;
const int YY_ClntParser_CLASS::SKIP_CONFIRM_ = 302;
const int YY_ClntParser_CLASS::OBEY_RA_BITS_ = 303;
const int YY_ClntParser_CLASS::PD_ = 304;
const int YY_ClntParser_CLASS::PREFIX_ = 305;
const int YY_ClntParser_CLASS::DOWNLINK_PREFIX_IFACES_ = 306;
const int YY_ClntParser_CLASS::DUID_TYPE_ = 307;
const int YY_ClntParser_CLASS::DUID_TYPE_LLT_ = 308;
const int YY_ClntParser_CLASS::DUID_TYPE_LL_ = 309;
const int YY_ClntParser_CLASS::DUID_TYPE_EN_ = 310;
const int YY_ClntParser_CLASS::AUTH_METHODS_ = 311;
const int YY_ClntParser_CLASS::AUTH_PROTOCOL_ = 312;
const int YY_ClntParser_CLASS::AUTH_ALGORITHM_ = 313;
const int YY_ClntParser_CLASS::AUTH_REPLAY_ = 314;
const int YY_ClntParser_CLASS::AUTH_REALM_ = 315;
const int YY_ClntParser_CLASS::DIGEST_NONE_ = 316;
const int YY_ClntParser_CLASS::DIGEST_PLAIN_ = 317;
const int YY_ClntParser_CLASS::DIGEST_HMAC_MD5_ = 318;
const int YY_ClntParser_CLASS::DIGEST_HMAC_SHA1_ = 319;
const int YY_ClntParser_CLASS::DIGEST_HMAC_SHA224_ = 320;
const int YY_ClntParser_CLASS::DIGEST_HMAC_SHA256_ = 321;
const int YY_ClntParser_CLASS::DIGEST_HMAC_SHA384_ = 322;
const int YY_ClntParser_CLASS::DIGEST_HMAC_SHA512_ = 323;
const int YY_ClntParser_CLASS::STATELESS_ = 324;
const int YY_ClntParser_CLASS::ANON_INF_REQUEST_ = 325;
const int YY_ClntParser_CLASS::INSIST_MODE_ = 326;
const int YY_ClntParser_CLASS::INACTIVE_MODE_ = 327;
const int YY_ClntParser_CLASS::EXPERIMENTAL_ = 328;
const int YY_ClntParser_CLASS::ADDR_PARAMS_ = 329;
const int YY_ClntParser_CLASS::REMOTE_AUTOCONF_ = 330;
const int YY_ClntParser_CLASS::AFTR_ = 331;
const int YY_ClntParser_CLASS::ROUTING_ = 332;
const int YY_ClntParser_CLASS::BIND_TO_ADDR_ = 333;
const int YY_ClntParser_CLASS::ADDRESS_LIST_KEYWORD_ = 334;
const int YY_ClntParser_CLASS::STRING_KEYWORD_ = 335;
const int YY_ClntParser_CLASS::DUID_KEYWORD_ = 336;
const int YY_ClntParser_CLASS::HEX_KEYWORD_ = 337;
const int YY_ClntParser_CLASS::RECONFIGURE_ = 338;

#line 341 "../bison++/bison.cc"
/* const YY_ClntParser_CLASS::token */
#endif
/*apres const  */
YY_ClntParser_CLASS::YY_ClntParser_CLASS(YY_ClntParser_CONSTRUCTOR_PARAM)
    YY_ClntParser_CONSTRUCTOR_INIT {
#if YY_ClntParser_DEBUG != 0
  YY_ClntParser_DEBUG_FLAG = 0;
#endif
  YY_ClntParser_CONSTRUCTOR_CODE;
}
#endif

#line 352 "../bison++/bison.cc"

#define YYFINAL 311
#define YYFLAG -32768
#define YYNTBASE 89

#define YYTRANSLATE(x) ((unsigned)(x) <= 338 ? yytranslate[x] : 194)

static const char yytranslate[] = {
    0,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,
    2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  86, 88,
    2,  87, 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,
    2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,
    2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,
    2,  2,  2,  2,  2,  2,  2,  2,  84, 2,  85, 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,
    2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,
    2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,
    2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,
    2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,
    2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,
    2,  2,  2,  1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
    21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
    44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66,
    67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83};

#if YY_ClntParser_DEBUG != 0
static const short yyprhs[] = {
    0,   0,   2,   3,   5,   7,   10,  13,  15,  17,  19,  21,  23,  25,  27,  29,  31,  33,  35,
    37,  39,  41,  43,  45,  47,  49,  51,  53,  55,  57,  59,  61,  63,  65,  67,  69,  71,  73,
    75,  77,  79,  81,  83,  85,  87,  89,  91,  93,  95,  97,  99,  101, 103, 105, 107, 109, 111,
    113, 115, 117, 119, 120, 124, 125, 132, 133, 140, 145, 150, 154, 158, 160, 163, 165, 168, 170,
    173, 175, 178, 180, 181, 182, 189, 193, 196, 198, 201, 202, 208, 209, 216, 220, 222, 225, 227,
    230, 232, 235, 237, 240, 243, 244, 250, 251, 258, 259, 266, 268, 271, 273, 275, 278, 281, 284,
    287, 290, 293, 298, 300, 303, 305, 308, 311, 312, 316, 319, 322, 324, 327, 330, 332, 336, 338,
    340, 342, 344, 346, 348, 350, 352, 354, 356, 358, 360, 361, 365, 366, 370, 373, 376, 379, 381,
    383, 385, 387, 390, 393, 396, 399, 402, 405, 407, 411, 412, 418, 421, 422, 429, 431, 434, 436,
    438, 440, 445, 447, 451, 452, 458, 459, 468, 470, 473, 475, 477, 480, 483, 485, 487, 491, 495,
    497, 501, 503, 507, 509, 511, 514, 515, 520, 523, 524, 529, 532, 533, 538, 541, 545, 548, 549,
    554, 557, 558, 563, 566, 570, 574, 577, 578, 583, 586, 587, 592, 595, 599, 602, 606, 609, 612,
    616, 618, 622, 626, 632, 635, 640, 645, 646, 652, 657, 661, 665, 669};

static const short yyrhs[] = {
    90,  0,   0,   91,  0,   96,  0,   90,  91,  0,   90,  96,  0,   92,  0,   116, 0,   117, 0,
    115, 0,   118, 0,   121, 0,   119, 0,   122, 0,   123, 0,   148, 0,   149, 0,   124, 0,   126,
    0,   127, 0,   128, 0,   129, 0,   132, 0,   133, 0,   134, 0,   181, 0,   135, 0,   146, 0,
    147, 0,   94,  0,   145, 0,   93,  0,   164, 0,   120, 0,   163, 0,   169, 0,   171, 0,   173,
    0,   175, 0,   176, 0,   178, 0,   180, 0,   182, 0,   184, 0,   186, 0,   187, 0,   188, 0,
    189, 0,   191, 0,   136, 0,   138, 0,   192, 0,   144, 0,   140, 0,   151, 0,   152, 0,   142,
    0,   114, 0,   143, 0,   0,   51,  95,  167, 0,   0,   24,  42,  84,  97,  99,  85,  0,   0,
    24,  168, 84,  98,  99,  85,  0,   24,  42,  84,  85,  0,   24,  168, 84,  85,  0,   24,  42,
    25,  0,   24,  168, 25,  0,   92,  0,   99,  92,  0,   105, 0,   99,  105, 0,   100, 0,   99,
    100, 0,   153, 0,   99,  153, 0,   29,  0,   0,   0,   29,  84,  101, 103, 102, 85,  0,   29,
    84,  85,  0,   103, 104, 0,   104, 0,   30,  168, 0,   0,   28,  84,  106, 108, 85,  0,   0,
    28,  168, 84,  107, 108, 85,  0,   28,  84,  85,  0,   28,  0,   28,  168, 0,   93,  0,   108,
    93,  0,   109, 0,   108, 109, 0,   31,  0,   31,  33,  0,   31,  168, 0,   0,   31,  84,  110,
    113, 85,  0,   0,   31,  33,  84,  111, 113, 85,  0,   0,   31,  168, 84,  112, 113, 85,  0,
    114, 0,   113, 114, 0,   141, 0,   150, 0,   39,  168, 0,   40,  42,  0,   38,  42,  0,   41,
    168, 0,   52,  53,  0,   52,  54,  0,   52,  55,  168, 45,  0,   69,  0,   34,  42,  0,   46,
    0,   46,  168, 0,   37,  42,  0,   0,   56,  125, 130, 0,   57,  42,  0,   58,  42,  0,   128,
    0,   59,  42,  0,   60,  42,  0,   131, 0,   130, 86,  131, 0,   61,  0,   62,  0,   63,  0,
    64,  0,   65,  0,   66,  0,   67,  0,   68,  0,   70,  0,   72,  0,   71,  0,   73,  0,   0,
    26,  137, 165, 0,   0,   27,  139, 165, 0,   78,  33,  0,   5,   168, 0,   35,  168, 0,   74,
    0,   75,  0,   48,  0,   47,  0,   83,  168, 0,   20,  42,  0,   21,  168, 0,   7,   168, 0,
    3,   168, 0,   4,   168, 0,   49,  0,   49,  84,  85,  0,   0,   49,  84,  154, 156, 85,  0,
    49,  168, 0,   0,   49,  168, 84,  155, 156, 85,  0,   157, 0,   156, 157, 0,   158, 0,   151,
    0,   152, 0,   50,  33,  87,  168, 0,   50,  0,   50,  84,  85,  0,   0,   50,  84,  159, 161,
    85,  0,   0,   50,  33,  87,  168, 84,  160, 161, 85,  0,   162, 0,   161, 162, 0,   150, 0,
    141, 0,   8,   168, 0,   77,  168, 0,   33,  0,   45,  0,   165, 86,  33,  0,   165, 86,  45,
    0,   33,  0,   166, 86,  33,  0,   42,  0,   167, 86,  42,  0,   43,  0,   44,  0,   36,  6,
    0,   0,   36,  6,   170, 166, 0,   36,  10,  0,   0,   36,  10,  172, 167, 0,   36,  9,   0,
    0,   36,  9,   174, 166, 0,   36,  11,  0,   36,  11,  42,  0,   36,  12,  0,   0,   36,  12,
    177, 166, 0,   36,  13,  0,   0,   36,  13,  179, 167, 0,   36,  18,  0,   36,  18,  42,  0,
    36,  19,  168, 0,   36,  14,  0,   0,   36,  14,  183, 166, 0,   36,  15,  0,   0,   36,  15,
    185, 166, 0,   36,  16,  0,   36,  16,  42,  0,   36,  17,  0,   36,  17,  42,  0,   36,  22,
    0,   36,  23,  0,   36,  23,  190, 0,   168, 0,   168, 88,  168, 0,   190, 86,  168, 0,   190,
    86,  168, 88,  168, 0,   36,  76,  0,   36,  168, 82,  45,  0,   36,  168, 31,  33,  0,   0,
    36,  168, 79,  193, 166, 0,   36,  168, 80,  42,  0,   36,  168, 82,  0,   36,  168, 31,  0,
    36,  168, 80,  0,   36,  168, 79,  0};

#endif

#if (YY_ClntParser_DEBUG != 0) || defined(YY_ClntParser_ERROR_VERBOSE)
static const short yyrline[] = {
    0,    145,  146,  150,  151,  152,  153,  157,  158,  159,  160,  161,  162,  163,  164,  165,
    166,  167,  168,  169,  170,  171,  172,  173,  174,  175,  176,  177,  178,  179,  180,  181,
    185,  186,  187,  188,  189,  190,  191,  192,  193,  194,  195,  196,  197,  198,  199,  200,
    201,  202,  203,  204,  205,  206,  207,  211,  212,  213,  214,  215,  219,  221,  229,  234,
    244,  251,  260,  272,  283,  296,  310,  311,  312,  313,  314,  315,  316,  317,  324,  333,
    344,  349,  349,  361,  362,  366,  378,  384,  389,  396,  406,  417,  425,  438,  439,  440,
    441,  454,  460,  466,  474,  485,  492,  503,  513,  521,  533,  534,  538,  539,  543,  553,
    558,  563,  569,  570,  571,  579,  601,  608,  616,  639,  645,  648,  658,  680,  688,  691,
    707,  716,  717,  721,  722,  723,  724,  725,  726,  727,  728,  732,  738,  744,  750,  757,
    762,  768,  771,  777,  783,  790,  797,  808,  824,  831,  838,  845,  862,  870,  877,  884,
    891,  899,  907,  914,  918,  927,  934,  942,  943,  947,  948,  949,  955,  962,  969,  976,
    979,  987,  994,  1001, 1002, 1006, 1007, 1011, 1029, 1046, 1050, 1054, 1058, 1065, 1066, 1070,
    1071, 1074, 1075, 1082, 1088, 1092, 1101, 1106, 1109, 1118, 1124, 1127, 1136, 1140, 1150, 1156,
    1159, 1168, 1173, 1176, 1185, 1194, 1201, 1216, 1222, 1225, 1234, 1240, 1243, 1252, 1256, 1267,
    1271, 1281, 1292, 1297, 1305, 1306, 1307, 1308, 1312, 1319, 1326, 1335, 1340, 1346, 1353, 1359,
    1366, 1372};

static const char *const yytname[] = {"$",
                                      "error",
                                      "$illegal.",
                                      "T1_",
                                      "T2_",
                                      "PREF_TIME_",
                                      "DNS_SERVER_",
                                      "VALID_TIME_",
                                      "UNICAST_",
                                      "NTP_SERVER_",
                                      "DOMAIN_",
                                      "TIME_ZONE_",
                                      "SIP_SERVER_",
                                      "SIP_DOMAIN_",
                                      "NIS_SERVER_",
                                      "NISP_SERVER_",
                                      "NIS_DOMAIN_",
                                      "NISP_DOMAIN_",
                                      "FQDN_",
                                      "FQDN_S_",
                                      "DDNS_PROTOCOL_",
                                      "DDNS_TIMEOUT_",
                                      "LIFETIME_",
                                      "VENDOR_SPEC_",
                                      "IFACE_",
                                      "NO_CONFIG_",
                                      "REJECT_SERVERS_",
                                      "PREFERRED_SERVERS_",
                                      "IA_",
                                      "TA_",
                                      "IAID_",
                                      "ADDRESS_KEYWORD_",
                                      "NAME_",
                                      "IPV6ADDR_",
                                      "WORKDIR_",
                                      "RAPID_COMMIT_",
                                      "OPTION_",
                                      "SCRIPT_",
                                      "LOGNAME_",
                                      "LOGLEVEL_",
                                      "LOGMODE_",
                                      "LOGCOLORS_",
                                      "STRING_",
                                      "HEXNUMBER_",
                                      "INTNUMBER_",
                                      "DUID_",
                                      "STRICT_RFC_NO_ROUTING_",
                                      "SKIP_CONFIRM_",
                                      "OBEY_RA_BITS_",
                                      "PD_",
                                      "PREFIX_",
                                      "DOWNLINK_PREFIX_IFACES_",
                                      "DUID_TYPE_",
                                      "DUID_TYPE_LLT_",
                                      "DUID_TYPE_LL_",
                                      "DUID_TYPE_EN_",
                                      "AUTH_METHODS_",
                                      "AUTH_PROTOCOL_",
                                      "AUTH_ALGORITHM_",
                                      "AUTH_REPLAY_",
                                      "AUTH_REALM_",
                                      "DIGEST_NONE_",
                                      "DIGEST_PLAIN_",
                                      "DIGEST_HMAC_MD5_",
                                      "DIGEST_HMAC_SHA1_",
                                      "DIGEST_HMAC_SHA224_",
                                      "DIGEST_HMAC_SHA256_",
                                      "DIGEST_HMAC_SHA384_",
                                      "DIGEST_HMAC_SHA512_",
                                      "STATELESS_",
                                      "ANON_INF_REQUEST_",
                                      "INSIST_MODE_",
                                      "INACTIVE_MODE_",
                                      "EXPERIMENTAL_",
                                      "ADDR_PARAMS_",
                                      "REMOTE_AUTOCONF_",
                                      "AFTR_",
                                      "ROUTING_",
                                      "BIND_TO_ADDR_",
                                      "ADDRESS_LIST_KEYWORD_",
                                      "STRING_KEYWORD_",
                                      "DUID_KEYWORD_",
                                      "HEX_KEYWORD_",
                                      "RECONFIGURE_",
                                      "'{'",
                                      "'}'",
                                      "','",
                                      "'/'",
                                      "'-'",
                                      "Grammar",
                                      "GlobalDeclarationList",
                                      "GlobalOptionDeclaration",
                                      "InterfaceOptionDeclaration",
                                      "IAOptionDeclaration",
                                      "DownlinkPrefixInterfaces",
                                      "@1",
                                      "InterfaceDeclaration",
                                      "@2",
                                      "@3",
                                      "InterfaceDeclarationsList",
                                      "TADeclaration",
                                      "@4",
                                      "@5",
                                      "TADeclarationList",
                                      "IAID",
                                      "IADeclaration",
                                      "@6",
                                      "@7",
                                      "IADeclarationList",
                                      "ADDRESDeclaration",
                                      "@8",
                                      "@9",
                                      "@10",
                                      "AddressParametersList",
                                      "AddressParameter",
                                      "LogLevelOption",
                                      "LogModeOption",
                                      "LogNameOption",
                                      "LogColors",
                                      "DuidTypeOption",
                                      "StatelessMode",
                                      "WorkDirOption",
                                      "StrictRfcNoRoutingOption",
                                      "ScriptName",
                                      "AuthAcceptMethods",
                                      "@11",
                                      "AuthProtocol",
                                      "AuthAlgorithm",
                                      "AuthReplay",
                                      "AuthRealm",
                                      "DigestList",
                                      "Digest",
                                      "AnonInfRequest",
                                      "InactiveMode",
                                      "InsistMode",
                                      "Experimental",
                                      "RejectServersOption",
                                      "@12",
                                      "PreferServersOption",
                                      "@13",
                                      "BindToAddress",
                                      "PreferredTimeOption",
                                      "RapidCommitOption",
                                      "ExperimentalAddrParams",
                                      "ExperimentalRemoteAutoconf",
                                      "ObeyRaBits",
                                      "SkipConfirm",
                                      "ReconfigureAccept",
                                      "DdnsProtocol",
                                      "DdnsTimeout",
                                      "ValidTimeOption",
                                      "T1Option",
                                      "T2Option",
                                      "PDDeclaration",
                                      "@14",
                                      "@15",
                                      "PDOptionsList",
                                      "PDOption",
                                      "Prefix",
                                      "@16",
                                      "@17",
                                      "PrefixOptionsList",
                                      "PrefixOption",
                                      "UnicastOption",
                                      "Routing",
                                      "ADDRESDUIDList",
                                      "ADDRESSList",
                                      "StringList",
                                      "Number",
                                      "DNSServerOption",
                                      "@18",
                                      "DomainOption",
                                      "@19",
                                      "NTPServerOption",
                                      "@20",
                                      "TimeZoneOption",
                                      "SIPServerOption",
                                      "@21",
                                      "SIPDomainOption",
                                      "@22",
                                      "FQDNOption",
                                      "FQDNBits",
                                      "NISServerOption",
                                      "@23",
                                      "NISPServerOption",
                                      "@24",
                                      "NISDomainOption",
                                      "NISPDomainOption",
                                      "LifetimeOption",
                                      "VendorSpecOption",
                                      "VendorSpecList",
                                      "DsLiteTunnelOption",
                                      "ExtraOption",
                                      "@25",
                                      ""};
#endif

static const short yyr1[] = {
    0,   89,  89,  90,  90,  90,  90,  91,  91,  91,  91,  91,  91,  91,  91,  91,  91,  91,  91,
    91,  91,  91,  91,  91,  91,  91,  91,  91,  91,  91,  91,  91,  92,  92,  92,  92,  92,  92,
    92,  92,  92,  92,  92,  92,  92,  92,  92,  92,  92,  92,  92,  92,  92,  92,  92,  93,  93,
    93,  93,  93,  95,  94,  97,  96,  98,  96,  96,  96,  96,  96,  99,  99,  99,  99,  99,  99,
    99,  99,  100, 101, 102, 100, 100, 103, 103, 104, 106, 105, 107, 105, 105, 105, 105, 108, 108,
    108, 108, 109, 109, 109, 110, 109, 111, 109, 112, 109, 113, 113, 114, 114, 115, 116, 117, 118,
    119, 119, 119, 120, 121, 122, 122, 123, 125, 124, 126, 127, 127, 128, 129, 130, 130, 131, 131,
    131, 131, 131, 131, 131, 131, 132, 133, 134, 135, 137, 136, 139, 138, 140, 141, 142, 143, 144,
    145, 146, 147, 148, 149, 150, 151, 152, 153, 153, 154, 153, 153, 155, 153, 156, 156, 157, 157,
    157, 158, 158, 158, 159, 158, 160, 158, 161, 161, 162, 162, 163, 164, 165, 165, 165, 165, 166,
    166, 167, 167, 168, 168, 169, 170, 169, 171, 172, 171, 173, 174, 173, 175, 175, 176, 177, 176,
    178, 179, 178, 180, 180, 181, 182, 183, 182, 184, 185, 184, 186, 186, 187, 187, 188, 189, 189,
    190, 190, 190, 190, 191, 192, 192, 193, 192, 192, 192, 192, 192, 192};

static const short yyr2[] = {
    0, 1, 0, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 3,
    0, 6, 0, 6, 4, 4, 3, 3, 1, 2, 1, 2, 1, 2, 1, 2, 1, 0, 0, 6, 3, 2, 1, 2, 0, 5, 0, 6, 3, 1, 2,
    1, 2, 1, 2, 1, 2, 2, 0, 5, 0, 6, 0, 6, 1, 2, 1, 1, 2, 2, 2, 2, 2, 2, 4, 1, 2, 1, 2, 2, 0, 3,
    2, 2, 1, 2, 2, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 3, 0, 3, 2, 2, 2, 1, 1, 1, 1, 2,
    2, 2, 2, 2, 2, 1, 3, 0, 5, 2, 0, 6, 1, 2, 1, 1, 1, 4, 1, 3, 0, 5, 0, 8, 1, 2, 1, 1, 2, 2, 1,
    1, 3, 3, 1, 3, 1, 3, 1, 1, 2, 0, 4, 2, 0, 4, 2, 0, 4, 2, 3, 2, 0, 4, 2, 0, 4, 2, 3, 3, 2, 0,
    4, 2, 0, 4, 2, 3, 2, 3, 2, 2, 3, 1, 3, 3, 5, 2, 4, 4, 0, 5, 4, 3, 3, 3, 3};

static const short yydefact[] = {
    2,   0,   0,   0,   0,   0,   0,   0,   0,   143, 145, 0,   0,   0,   0,   0,   0,   0,   0,
    119, 153, 152, 60,  0,   122, 0,   0,   0,   0,   117, 139, 141, 140, 142, 150, 151, 0,   0,
    0,   1,   3,   7,   32,  30,  4,   58,  10,  8,   9,   11,  13,  34,  12,  14,  15,  18,  19,
    20,  21,  22,  23,  24,  25,  27,  50,  51,  54,  108, 57,  59,  53,  31,  28,  29,  16,  17,
    109, 55,  56,  35,  33,  36,  37,  38,  39,  40,  41,  42,  26,  43,  44,  45,  46,  47,  48,
    49,  52,  193, 194, 158, 159, 148, 157, 183, 155, 156, 0,   0,   0,   0,   118, 149, 195, 201,
    198, 204, 206, 209, 215, 218, 221, 223, 212, 0,   225, 226, 232, 0,   121, 112, 110, 111, 113,
    120, 0,   114, 115, 0,   0,   124, 125, 127, 128, 184, 147, 154, 5,   6,   68,  62,  69,  64,
    185, 186, 144, 146, 0,   0,   0,   205, 0,   0,   0,   0,   222, 224, 213, 214, 228, 227, 239,
    241, 240, 238, 191, 61,  0,   131, 132, 133, 134, 135, 136, 137, 138, 123, 129, 66,  0,   67,
    0,   0,   189, 197, 203, 200, 208, 211, 217, 220, 0,   0,   234, 0,   237, 233, 0,   116, 0,
    91,  78,  0,   160, 70,  0,   74,  72,  76,  0,   187, 188, 0,   229, 230, 236, 192, 130, 86,
    92,  79,  162, 164, 63,  71,  75,  73,  77,  65,  190, 0,   90,  0,   88,  82,  0,   161, 0,
    165, 231, 97,  93,  0,   95,  0,   0,   80,  84,  173, 170, 171, 0,   167, 169, 0,   98,  100,
    99,  87,  94,  96,  0,   85,  0,   83,  0,   175, 163, 168, 0,   102, 0,   104, 89,  81,  0,
    174, 0,   166, 0,   0,   106, 0,   172, 182, 181, 0,   179, 0,   101, 107, 0,   177, 176, 180,
    103, 105, 0,   0,   178, 0,   0,   0};

static const short yydefgoto[] = {
    309, 39,  40,  41,  42,  43,  134, 44,  188, 190, 214, 215, 244, 272, 255, 256, 216, 241,
    253, 251, 252, 280, 288, 291, 289, 45,  46,  47,  48,  49,  50,  51,  52,  53,  54,  55,
    138, 56,  57,  58,  59,  185, 186, 60,  61,  62,  63,  64,  108, 65,  109, 66,  67,  68,
    69,  70,  71,  72,  73,  74,  75,  76,  77,  78,  217, 246, 263, 260, 261, 262, 286, 306,
    295, 296, 79,  80,  154, 193, 175, 127, 81,  156, 82,  158, 83,  157, 84,  85,  160, 86,
    161, 87,  88,  89,  162, 90,  163, 91,  92,  93,  94,  169, 95,  96,  203};

static const short yypact[] = {
    113,    166,    166,    166,    166,    166,    -6,     166,    201,    -32768, -32768, 13,
    166,    218,    27,     72,     166,    77,     166,    166,    -32768, -32768, -32768, 202,
    -32768, 102,    104,    126,    137,    -32768, -32768, -32768, -32768, -32768, -32768, -32768,
    166,    54,     166,    113,    -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
    -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
    -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
    -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
    -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
    -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -20,    22,
    78,     78,     -32768, -32768, 122,    156,    162,    165,    181,    173,    214,    216,
    209,    221,    224,    166,    -32768, 166,    -32768, -12,    -32768, -32768, -32768, -32768,
    -32768, -32768, 247,    -32768, -32768, 166,    270,    -32768, -32768, -32768, -32768, -32768,
    -32768, -32768, -32768, -32768, -32768, 138,    -32768, 175,    -32768, -32768, 172,    172,
    257,    257,    247,    -32768, 257,    247,    257,    257,    -32768, -32768, -32768, -32768,
    203,    206,    260,    262,    256,    255,    -32768, 215,    258,    -32768, -32768, -32768,
    -32768, -32768, -32768, -32768, -32768, 219,    -32768, -32768, 190,    -32768, 190,    97,
    -32768, 225,    225,    215,    225,    215,    225,    225,    166,    166,    -32768, 257,
    -32768, -32768, 271,    -32768, 270,    28,     220,    263,    57,     -32768, 5,      -32768,
    -32768, -32768, 17,     -32768, -32768, 279,    -32768, 227,    225,    -32768, -32768, 231,
    233,    235,    237,    239,    -32768, -32768, -32768, -32768, -32768, -32768, -32768, 166,
    -32768, 100,    -32768, -32768, 294,    -32768, 35,     -32768, -32768, 82,     -32768, 53,
    -32768, 100,    166,    294,    -32768, -3,     -32768, -32768, 23,     -32768, -32768, 35,
    241,    -32768, 242,    -32768, -32768, -32768, 58,     -32768, 243,    -32768, 253,    244,
    -32768, -32768, 25,     -32768, 9,      -32768, -32768, -32768, 166,    -32768, 9,      -32768,
    9,      43,     -32768, 9,      259,    -32768, -32768, 44,     -32768, 71,     -32768, -32768,
    91,     -32768, -32768, -32768, -32768, -32768, 9,      92,     -32768, 341,    342,    -32768};

static const short yypgoto[] = {
    -32768, -32768, 305,    32,     1,      -32768, -32768, 306,    -32768, -32768, 157,    -105,
    -32768, -32768, -32768, 93,     -56,    -32768, -32768, 96,     -228,   -32768, -32768, -32768,
    -86,    30,     -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
    -32768, -32768, -32768, -32768, -32768, -32768, 142,    -32768, -32768, -32768, -32768, -32768,
    -32768, -32768, -32768, -32768, -94,    -32768, -32768, -32768, -32768, -32768, -32768, -32768,
    -32768, 2,      24,     36,     -51,    -32768, -32768, 83,     -201,   -32768, -32768, -32768,
    46,     -150,   -32768, -32768, 245,    18,     45,     -1,     -32768, -32768, -32768, -32768,
    -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
    -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768};

#define YYLAST 354

static const short yytable[] = {
    99,   100, 101,  102, 103, 148, 105,  107, 1,   2,    3,    111,  4,   5,   3,   130, 4,
    132,  133, 170,  1,   2,   3,   269,  4,   5,   1,    2,    1,    2,   274, 9,   10,  209,
    210,  143, 104,  145, 1,   2,   12,   211, 269, 9,    10,   209,  210, 150, 3,   3,   4,
    4,    12,  211,  212, 110, 1,   2,    3,   277, 4,    1,    2,    3,   149, 4,   212, 171,
    172,  128, 173,  97,  98,  257, 29,   257, 3,   277,  4,    34,   35,  275, 36,  37,  249,
    257,  29,  144,  12,  249, 232, 34,   35,  12,  36,   37,   3,    3,   4,   4,   97,  98,
    237,  1,   2,    3,   151, 4,   276,  234, 287, 152,  227,  234,  129, 264, 1,   2,   3,
    131,  4,   5,    167, 153, 168, 97,   98,  34,  298,  302,  219,  249, 34,  6,   7,   12,
    176,  8,   267,  9,   10,  230, 220,  282, 139, 303,  140,  11,   12,  13,  14,  15,  16,
    17,   18,  -196, 304, 303, 235, 19,   20,  21,  235,  236,  22,   23,  265, 236, 141, 24,
    25,   26,  27,   28,  34,  194, 305,  308, 196, 142,  198,  199,  29,  30,  31,  32,  33,
    34,   35,  -202, 36,  37,  293, 1,    2,   3,   38,   4,    5,    222, 223, 293, 297, 195,
    -199, 300, 197,  159, 228, 97,  98,   231, 293, 293,  -207, -210, 9,   10,  209, 210, 213,
    224,  213, 187,  112, 12,  211, 113,  114, 115, 116,  117,  118,  119, 120, 121, 122, 123,
    248,  212, 124,  125, 250, 106, 97,   98,  233, -216, 266,  -219, 233, 164, 268, 271, 250,
    135,  136, 137,  191, 29,  189, 97,   98,  165, 34,   35,   166,  36,  37,  112, 258, 268,
    113,  114, 115,  116, 117, 118, 119,  120, 121, 122,  259,  292,  258, 124, 125, 258, 294,
    174,  192, 200,  201, 202, 126, -235, 259, 294, 204,  259,  205,  206, 258, 207, 229, 208,
    97,   98,  294,  294, 290, 221, 238,  225, 259, 239,  240,  242,  290, 299, 243, 290, 245,
    247,  254, 279,  281, 299, 283, 285,  299, 177, 178,  179,  180,  181, 182, 183, 184, 126,
    284,  310, 311,  301, 146, 147, 278,  218, 273, 270,  226,  0,    307, 0,   155};

static const short yycheck[] = {
    1,  2,   3,   4,   5,   25,  7,   8,   3,   4,   5,   12,  7,   8,   5,   16,  7,   18,  19,
    31, 3,   4,   5,   251, 7,   8,   3,   4,   3,   4,   33,  26,  27,  28,  29,  36,  42,  38,
    3,  4,   35,  36,  270, 26,  27,  28,  29,  25,  5,   5,   7,   7,   35,  36,  49,  42,  3,
    4,  5,   260, 7,   3,   4,   5,   84,  7,   49,  79,  80,  42,  82,  43,  44,  50,  69,  50,
    5,  278, 7,   74,  75,  84,  77,  78,  31,  50,  69,  33,  35,  31,  85,  74,  75,  35,  77,
    78, 5,   5,   7,   7,   43,  44,  85,  3,   4,   5,   84,  7,   85,  214, 85,  33,  84,  218,
    42, 33,  3,   4,   5,   42,  7,   8,   123, 45,  125, 43,  44,  74,  85,  85,  33,  31,  74,
    20, 21,  35,  137, 24,  85,  26,  27,  84,  45,  85,  42,  295, 42,  34,  35,  36,  37,  38,
    39, 40,  41,  33,  85,  307, 214, 46,  47,  48,  218, 214, 51,  52,  84,  218, 42,  56,  57,
    58, 59,  60,  74,  157, 85,  85,  160, 42,  162, 163, 69,  70,  71,  72,  73,  74,  75,  33,
    77, 78,  286, 3,   4,   5,   83,  7,   8,   200, 201, 295, 288, 158, 42,  291, 161, 42,  209,
    43, 44,  212, 306, 307, 33,  42,  26,  27,  28,  29,  188, 203, 190, 85,  6,   35,  36,  9,
    10, 11,  12,  13,  14,  15,  16,  17,  18,  19,  239, 49,  22,  23,  241, 42,  43,  44,  214,
    33, 249, 33,  218, 42,  251, 254, 253, 53,  54,  55,  86,  69,  85,  43,  44,  42,  74,  75,
    42, 77,  78,  6,   246, 270, 9,   10,  11,  12,  13,  14,  15,  16,  17,  18,  246, 284, 260,
    22, 23,  263, 286, 42,  33,  88,  86,  33,  76,  33,  260, 295, 42,  263, 45,  86,  278, 45,
    84, 86,  43,  44,  306, 307, 280, 86,  33,  42,  278, 88,  85,  84,  288, 289, 85,  291, 85,
    84, 30,  84,  84,  297, 85,  85,  300, 61,  62,  63,  64,  65,  66,  67,  68,  76,  87,  0,
    0,  84,  39,  39,  263, 190, 255, 253, 208, -1,  306, -1,  109};

#line 352 "../bison++/bison.cc"
/* fattrs + tables */

/* parser code folow  */

/* This is the parser code that is written into each bison parser
  when the %semantic_parser declaration is not specified in the grammar.
  It was written by Richard Stallman by simplifying the hairy parser
  used when %semantic_parser is specified.  */

/* Note: dollar marks section change
   the next  is replaced by the list of actions, each action
   as one case of the switch.  */

#if YY_ClntParser_USE_GOTO != 0
/*
 SUPRESSION OF GOTO : on some C++ compiler (sun c++)
  the goto is strictly forbidden if any constructor/destructor
  is used in the whole function (very stupid isn't it ?)
 so goto are to be replaced with a 'while/switch/case construct'
 here are the macro to keep some apparent compatibility
*/
#define YYGOTO(lb)     \
  {                    \
    yy_gotostate = lb; \
    continue;          \
  }
#define YYBEGINGOTO                          \
  enum yy_labels yy_gotostate = yygotostart; \
  for (;;) switch (yy_gotostate) {           \
      case yygotostart: {
#define YYLABEL(lb) \
  }                 \
  case lb: {
#define YYENDGOTO \
  }               \
  }
#define YYBEGINDECLARELABEL enum yy_labels { yygotostart
#define YYDECLARELABEL(lb) , lb
#define YYENDDECLARELABEL }
#else
/* macro to keep goto */
#define YYGOTO(lb) goto lb
#define YYBEGINGOTO
#define YYLABEL(lb) \
  lb:
#define YYENDGOTO
#define YYBEGINDECLARELABEL
#define YYDECLARELABEL(lb)
#define YYENDDECLARELABEL
#endif
/* LABEL DECLARATION */
YYBEGINDECLARELABEL
YYDECLARELABEL(yynewstate)
YYDECLARELABEL(yybackup)
/* YYDECLARELABEL(yyresume) */
YYDECLARELABEL(yydefault)
YYDECLARELABEL(yyreduce)
YYDECLARELABEL(yyerrlab)     /* here on detecting error */
YYDECLARELABEL(yyerrlab1)    /* here on error raised explicitly by an action */
YYDECLARELABEL(yyerrdefault) /* current state does not do anything special for
                                the error token. */
YYDECLARELABEL(yyerrpop)     /* pop the current state because it cannot handle the
                                error token */
YYDECLARELABEL(yyerrhandle)
YYENDDECLARELABEL
/* ALLOCA SIMULATION */
/* __HAVE_NO_ALLOCA */
#ifdef __HAVE_NO_ALLOCA
int __alloca_free_ptr(char *ptr, char *ref) {
  if (ptr != ref) free(ptr);
  return 0;
}

#define __ALLOCA_alloca(size) malloc(size)
#define __ALLOCA_free(ptr, ref) __alloca_free_ptr((char *)ptr, (char *)ref)

#ifdef YY_ClntParser_LSP_NEEDED
#define __ALLOCA_return(num)                                                                       \
  do {                                                                                             \
    return (__ALLOCA_free(yyss, yyssa) + __ALLOCA_free(yyvs, yyvsa) + __ALLOCA_free(yyls, yylsa) + \
            (num));                                                                                \
  } while (0)
#else
#define __ALLOCA_return(num)                                                  \
  do {                                                                        \
    return (__ALLOCA_free(yyss, yyssa) + __ALLOCA_free(yyvs, yyvsa) + (num)); \
  } while (0)
#endif
#else
#define __ALLOCA_return(num) \
  do {                       \
    return (num);            \
  } while (0)
#define __ALLOCA_alloca(size) alloca(size)
#define __ALLOCA_free(ptr, ref)
#endif

/* ENDALLOCA SIMULATION */

#define yyerrok (yyerrstatus = 0)
#define yyclearin (YY_ClntParser_CHAR = YYEMPTY)
#define YYEMPTY -2
#define YYEOF 0
#define YYACCEPT __ALLOCA_return(0)
#define YYABORT __ALLOCA_return(1)
#define YYERROR YYGOTO(yyerrlab1)
/* Like YYERROR except do call yyerror.
   This remains here temporarily to ease the
   transition to the new meaning of YYERROR, for GCC.
   Once GCC version 2 has supplanted version 1, this can go.  */
#define YYFAIL YYGOTO(yyerrlab)
#define YYRECOVERING() (!!yyerrstatus)
#define YYBACKUP(token, value)                                    \
  do                                                              \
    if (YY_ClntParser_CHAR == YYEMPTY && yylen == 1) {            \
      YY_ClntParser_CHAR = (token), YY_ClntParser_LVAL = (value); \
      yychar1 = YYTRANSLATE(YY_ClntParser_CHAR);                  \
      YYPOPSTACK;                                                 \
      YYGOTO(yybackup);                                           \
    } else {                                                      \
      YY_ClntParser_ERROR("syntax error: cannot back up");        \
      YYERROR;                                                    \
    }                                                             \
  while (0)

#define YYTERROR 1
#define YYERRCODE 256

#ifndef YY_ClntParser_PURE
/* UNPURE */
#define YYLEX YY_ClntParser_LEX()
#ifndef YY_USE_CLASS
/* If nonreentrant, and not class , generate the variables here */
int YY_ClntParser_CHAR;                 /*  the lookahead symbol        */
YY_ClntParser_STYPE YY_ClntParser_LVAL; /*  the semantic value of the */
                                        /*  lookahead symbol    */
int YY_ClntParser_NERRS;                /*  number of parse errors so far */
#ifdef YY_ClntParser_LSP_NEEDED
YY_ClntParser_LTYPE YY_ClntParser_LLOC; /*  location data for the lookahead */
/*  symbol                              */
#endif
#endif

#else
/* PURE */
#ifdef YY_ClntParser_LSP_NEEDED
#define YYLEX YY_ClntParser_LEX(&YY_ClntParser_LVAL, &YY_ClntParser_LLOC)
#else
#define YYLEX YY_ClntParser_LEX(&YY_ClntParser_LVAL)
#endif
#endif
#ifndef YY_USE_CLASS
#if YY_ClntParser_DEBUG != 0
int YY_ClntParser_DEBUG_FLAG; /*  nonzero means print parse trace     */
/* Since this is uninitialized, it does not stop multiple parsers
   from coexisting.  */
#endif
#endif

/*  YYINITDEPTH indicates the initial size of the parser's stacks       */

#ifndef YYINITDEPTH
#define YYINITDEPTH 200
#endif

/*  YYMAXDEPTH is the maximum size the stacks can grow to
    (effective only if the built-in stack extension method is used).  */

#if YYMAXDEPTH == 0
#undef YYMAXDEPTH
#endif

#ifndef YYMAXDEPTH
#define YYMAXDEPTH 10000
#endif

#if __GNUC__ > 1 /* GNU C and GNU C++ define this.  */
#define __yy_bcopy(FROM, TO, COUNT) __builtin_memcpy(TO, FROM, COUNT)
#else /* not GNU C or C++ */

/* This is the most reliable way to avoid incompatibilities
   in available built-in functions on various systems.  */

#ifdef __cplusplus
static void __yy_bcopy(char *from, char *to, int count)
#else
#ifdef __STDC__
static void __yy_bcopy(char *from, char *to, int count)
#else
static void __yy_bcopy(from, to, count) char *from;
char *to;
int count;
#endif
#endif
{
  register char *f = from;
  register char *t = to;
  register int i = count;

  while (i-- > 0) *t++ = *f++;
}
#endif

int
#ifdef YY_USE_CLASS
 YY_ClntParser_CLASS::
#endif
     YY_ClntParser_PARSE(YY_ClntParser_PARSE_PARAM)
#ifndef __STDC__
#ifndef __cplusplus
#ifndef YY_USE_CLASS
/* parameter definition without protypes */
YY_ClntParser_PARSE_PARAM_DEF
#endif
#endif
#endif
{
  register int yystate;
  register int yyn;
  register short *yyssp;
  register YY_ClntParser_STYPE *yyvsp;
  int yyerrstatus; /*  number of tokens to shift before error messages enabled
                    */
  int yychar1 = 0; /*  lookahead token as an internal (translated) token number */

  short yyssa[YYINITDEPTH];               /*  the state stack                     */
  YY_ClntParser_STYPE yyvsa[YYINITDEPTH]; /*  the semantic value stack */

  short *yyss = yyssa;               /*  refer to the stacks thru separate pointers */
  YY_ClntParser_STYPE *yyvs = yyvsa; /*  to allow yyoverflow to reallocate them elsewhere */

#ifdef YY_ClntParser_LSP_NEEDED
  YY_ClntParser_LTYPE yylsa[YYINITDEPTH]; /*  the location stack */
  YY_ClntParser_LTYPE *yyls = yylsa;
  YY_ClntParser_LTYPE *yylsp;

#define YYPOPSTACK (yyvsp--, yyssp--, yylsp--)
#else
#define YYPOPSTACK (yyvsp--, yyssp--)
#endif

  int yystacksize = YYINITDEPTH;

#ifdef YY_ClntParser_PURE
  int YY_ClntParser_CHAR;
  YY_ClntParser_STYPE YY_ClntParser_LVAL;
  int YY_ClntParser_NERRS;
#ifdef YY_ClntParser_LSP_NEEDED
  YY_ClntParser_LTYPE YY_ClntParser_LLOC;
#endif
#endif

  YY_ClntParser_STYPE yyval; /*  the variable used to return         */
  /*  semantic values from the action     */
  /*  routines                            */

  int yylen;
  /* start loop, in which YYGOTO may be used. */
  YYBEGINGOTO

#if YY_ClntParser_DEBUG != 0
  if (YY_ClntParser_DEBUG_FLAG) fprintf(stderr, "Starting parse\n");
#endif
  yystate = 0;
  yyerrstatus = 0;
  YY_ClntParser_NERRS = 0;
  YY_ClntParser_CHAR = YYEMPTY; /* Cause a token to be read.  */

  /* Initialize stack pointers.
     Waste one element of value and location stack
     so that they stay on the same level as the state stack.
     The wasted elements are never initialized.  */

  yyssp = yyss - 1;
  yyvsp = yyvs;
#ifdef YY_ClntParser_LSP_NEEDED
  yylsp = yyls;
#endif

  /* Push a new state, which is found in  yystate  .  */
  /* In all cases, when you get here, the value and location stacks
     have just been pushed. so pushing a state here evens the stacks.  */
  YYLABEL(yynewstate)

  *++yyssp = yystate;

  if (yyssp >= yyss + yystacksize - 1) {
    /* Give user a chance to reallocate the stack */
    /* Use copies of these so that the &'s don't force the real ones into
     * memory. */
    YY_ClntParser_STYPE *yyvs1 = yyvs;
    short *yyss1 = yyss;
#ifdef YY_ClntParser_LSP_NEEDED
    YY_ClntParser_LTYPE *yyls1 = yyls;
#endif

    /* Get the current used size of the three stacks, in elements.  */
    int size = yyssp - yyss + 1;

#ifdef yyoverflow
    /* Each stack pointer address is followed by the size of
       the data in use in that stack, in bytes.  */
#ifdef YY_ClntParser_LSP_NEEDED
    /* This used to be a conditional around just the two extra args,
       but that might be undefined if yyoverflow is a macro.  */
    yyoverflow("parser stack overflow", &yyss1, size * sizeof(*yyssp), &yyvs1,
               size * sizeof(*yyvsp), &yyls1, size * sizeof(*yylsp), &yystacksize);
#else
    // cppcheck-suppress constStatement
    yyoverflow("parser stack overflow", &yyss1, size * sizeof(*yyssp), &yyvs1,
               size * sizeof(*yyvsp), &yystacksize);
#endif

    yyss = yyss1;
    yyvs = yyvs1;
#ifdef YY_ClntParser_LSP_NEEDED
    yyls = yyls1;
#endif
#else /* no yyoverflow */
    /* Extend the stack our own way.  */
    if (yystacksize >= YYMAXDEPTH) {
      YY_ClntParser_ERROR(((char *)"parser stack overflow"));
      __ALLOCA_return(2);
    }
    yystacksize *= 2;
    if (yystacksize > YYMAXDEPTH) yystacksize = YYMAXDEPTH;
    yyss = (short *)__ALLOCA_alloca(yystacksize * sizeof(*yyssp));
    __yy_bcopy((char *)yyss1, (char *)yyss, size * sizeof(*yyssp));
    __ALLOCA_free(yyss1, yyssa);
    yyvs = (YY_ClntParser_STYPE *)__ALLOCA_alloca(yystacksize * sizeof(*yyvsp));
    __yy_bcopy((char *)yyvs1, (char *)yyvs, size * sizeof(*yyvsp));
    __ALLOCA_free(yyvs1, yyvsa);
#ifdef YY_ClntParser_LSP_NEEDED
    yyls = (YY_ClntParser_LTYPE *)__ALLOCA_alloca(yystacksize * sizeof(*yylsp));
    __yy_bcopy((char *)yyls1, (char *)yyls, size * sizeof(*yylsp));
    __ALLOCA_free(yyls1, yylsa);
#endif
#endif /* no yyoverflow */

    yyssp = yyss + size - 1;
    yyvsp = yyvs + size - 1;
#ifdef YY_ClntParser_LSP_NEEDED
    yylsp = yyls + size - 1;
#endif

#if YY_ClntParser_DEBUG != 0
    if (YY_ClntParser_DEBUG_FLAG) fprintf(stderr, "Stack size increased to %d\n", yystacksize);
#endif

    if (yyssp >= yyss + yystacksize - 1) YYABORT;
  }

#if YY_ClntParser_DEBUG != 0
  if (YY_ClntParser_DEBUG_FLAG) fprintf(stderr, "Entering state %d\n", yystate);
#endif

  YYGOTO(yybackup);
  YYLABEL(yybackup)

  /* Do appropriate processing given the current state.  */
  /* Read a lookahead token if we need one and don't already have one.  */
  /* YYLABEL(yyresume) */

  /* First try to decide what to do without reference to lookahead token.  */

  yyn = yypact[yystate];
  if (yyn == YYFLAG) YYGOTO(yydefault);

  /* Not known => get a lookahead token if don't already have one.  */

  /* yychar is either YYEMPTY or YYEOF
     or a valid token in external form.  */

  if (YY_ClntParser_CHAR == YYEMPTY) {
#if YY_ClntParser_DEBUG != 0
    if (YY_ClntParser_DEBUG_FLAG) fprintf(stderr, "Reading a token: ");
#endif
    YY_ClntParser_CHAR = YYLEX;
  }

  /* Convert token to internal form (in yychar1) for indexing tables with */

  if (YY_ClntParser_CHAR <= 0) /* This means end of input. */
  {
    yychar1 = 0;
    YY_ClntParser_CHAR = YYEOF; /* Don't call YYLEX any more */

#if YY_ClntParser_DEBUG != 0
    if (YY_ClntParser_DEBUG_FLAG) fprintf(stderr, "Now at end of input.\n");
#endif
  } else {
    yychar1 = YYTRANSLATE(YY_ClntParser_CHAR);

#if YY_ClntParser_DEBUG != 0
    if (YY_ClntParser_DEBUG_FLAG) {
      fprintf(stderr, "Next token is %d (%s", YY_ClntParser_CHAR, yytname[yychar1]);
      /* Give the individual parser a way to print the precise meaning
         of a token, for further debugging info.  */
#ifdef YYPRINT
      YYPRINT(stderr, YY_ClntParser_CHAR, YY_ClntParser_LVAL);
#endif
      fprintf(stderr, ")\n");
    }
#endif
  }

  yyn += yychar1;
  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != yychar1) YYGOTO(yydefault);

  yyn = yytable[yyn];

  /* yyn is what to do for this token type in this state.
     Negative => reduce, -yyn is rule number.
     Positive => shift, yyn is new state.
       New state is final state => don't bother to shift,
       just return success.
     0, or most negative number => error.  */

  if (yyn < 0) {
    if (yyn == YYFLAG) YYGOTO(yyerrlab);
    yyn = -yyn;
    YYGOTO(yyreduce);
  } else if (yyn == 0)
    YYGOTO(yyerrlab);

  if (yyn == YYFINAL) YYACCEPT;

    /* Shift the lookahead token.  */

#if YY_ClntParser_DEBUG != 0
  if (YY_ClntParser_DEBUG_FLAG)
    fprintf(stderr, "Shifting token %d (%s), ", YY_ClntParser_CHAR, yytname[yychar1]);
#endif

  /* Discard the token being shifted unless it is eof.  */
  if (YY_ClntParser_CHAR != YYEOF) YY_ClntParser_CHAR = YYEMPTY;

  *++yyvsp = YY_ClntParser_LVAL;
#ifdef YY_ClntParser_LSP_NEEDED
  *++yylsp = YY_ClntParser_LLOC;
#endif

  /* count tokens shifted since error; after three, turn off error status.  */
  if (yyerrstatus) yyerrstatus--;

  yystate = yyn;
  YYGOTO(yynewstate);

  /* Do the default action for the current state.  */
  YYLABEL(yydefault)

  yyn = yydefact[yystate];
  if (yyn == 0) YYGOTO(yyerrlab);

  /* Do a reduction.  yyn is the number of a rule to reduce with.  */
  YYLABEL(yyreduce)
  yylen = yyr2[yyn];
  if (yylen > 0) yyval = yyvsp[1 - yylen]; /* implement default value of the action */

#if YY_ClntParser_DEBUG != 0
  if (YY_ClntParser_DEBUG_FLAG) {
    int i;

    fprintf(stderr, "Reducing via rule %d (line %d), ", yyn, yyrline[yyn]);

    /* Print the symbols being reduced, and their result.  */
    for (i = yyprhs[yyn]; yyrhs[i] > 0; i++) fprintf(stderr, "%s ", yytname[yyrhs[i]]);
    fprintf(stderr, " -> %s\n", yytname[yyr1[yyn]]);
  }
#endif

#line 840 "../bison++/bison.cc"

  switch (yyn) {

    case 60:
#line 219 "ClntParser.y"
    {
      PresentStringLst.clear();
      ;
      break;
    }
    case 61:
#line 221 "ClntParser.y"
    {
      CfgMgr->setDownlinkPrefixIfaces(PresentStringLst);
      ;
      break;
    }
    case 62:
#line 230 "ClntParser.y"
    {
      if (!StartIfaceDeclaration(yyvsp[-1].strval)) YYABORT;
      ;
      break;
    }
    case 63:
#line 235 "ClntParser.y"
    {
      delete[] yyvsp[-4].strval;
      if (!EndIfaceDeclaration()) YYABORT;
      ;
      break;
    }
    case 64:
#line 245 "ClntParser.y"
    {
      if (!IfaceDefined(yyvsp[-1].ival)) YYABORT;
      if (!StartIfaceDeclaration(yyvsp[-1].ival)) YYABORT;
      ;
      break;
    }
    case 65:
#line 252 "ClntParser.y"
    {
      if (!EndIfaceDeclaration()) YYABORT;
      ;
      break;
    }
    case 66:
#line 261 "ClntParser.y"
    {
      if (!IfaceDefined(string(yyvsp[-2].strval))) YYABORT;
      ClntCfgIfaceLst.append(new TClntCfgIface(yyvsp[-2].strval));
      delete[] yyvsp[-2].strval;
      EmptyIface();
      ;
      break;
    }
    case 67:
#line 273 "ClntParser.y"
    {
      if (!IfaceDefined(yyvsp[-2].ival)) YYABORT;
      ClntCfgIfaceLst.append(new TClntCfgIface(yyvsp[-2].ival));
      EmptyIface();
      ;
      break;
    }
    case 68:
#line 284 "ClntParser.y"
    {
      if (!IfaceDefined(string(yyvsp[-1].strval))) YYABORT;
      ClntCfgIfaceLst.append(new TClntCfgIface(yyvsp[-1].strval));
      ClntCfgIfaceLst.getLast()->setOptions(ParserOptStack.getLast());
      ClntCfgIfaceLst.getLast()->setNoConfig();
      delete yyvsp[-1].strval;
      ;
      break;
    }
    case 69:
#line 297 "ClntParser.y"
    {
      if (!IfaceDefined(yyvsp[-1].ival)) YYABORT;
      ClntCfgIfaceLst.append(SPtr<TClntCfgIface>(new TClntCfgIface(yyvsp[-1].ival)));
      ClntCfgIfaceLst.getLast()->setOptions(ParserOptStack.getLast());
      ClntCfgIfaceLst.getLast()->setNoConfig();
      ;
      break;
    }
    case 78:
#line 325 "ClntParser.y"
    {
      if (!ParserOptStack.getLast()->getStateful()) {
        Log(Crit) << "Attempted to use TA (stateful option) in stateless mode." << LogEnd;
        YYABORT;
      }

      this->ClntCfgTALst.append(new TClntCfgTA());  // append new TA
      ;
      break;
    }
    case 79:
#line 334 "ClntParser.y"
    {
      if (!ParserOptStack.getLast()->getStateful()) {
        Log(Crit) << "Attempted to use TA (stateful option) in stateless mode." << LogEnd;
        YYABORT;
      }

      this->ClntCfgTALst.append(new TClntCfgTA());  // append new TA
      this->iaidSet = false;
      ;
      break;
    }
    case 80:
#line 344 "ClntParser.y"
    {
      if (this->iaidSet) this->ClntCfgTALst.getLast()->setIAID(this->iaid);
      ;
      break;
    }
    case 82:
#line 350 "ClntParser.y"
    {
      if (!ParserOptStack.getLast()->getStateful()) {
        Log(Crit) << "Attempted to use TA (stateful option) in stateless mode." << LogEnd;
        YYABORT;
      }

      this->ClntCfgTALst.append(new TClntCfgTA());  // append new TA
      ;
      break;
    }
    case 85:
#line 367 "ClntParser.y"
    {
      this->iaidSet = true;
      this->iaid = yyvsp[0].ival;
      Log(Crit) << "IAID=" << this->iaid << " parsed." << LogEnd;
      ;
      break;
    }
    case 86:
#line 379 "ClntParser.y"
    {
      if (!StartIADeclaration(false)) {
        YYABORT;
      };
      break;
    }
    case 87:
#line 385 "ClntParser.y"
    {
      EndIADeclaration();
      ;
      break;
    }
    case 88:
#line 390 "ClntParser.y"
    {
      if (!StartIADeclaration(false)) {
        YYABORT;
      }
      this->iaid = yyvsp[-1].ival;
      ;
      break;
    }
    case 89:
#line 397 "ClntParser.y"
    {
      EndIADeclaration();
      Log(Info) << "Setting IAID to " << this->iaid << LogEnd;
      ClntCfgIALst.getLast()->setIAID(this->iaid);
      ;
      break;
    }
    case 90:
#line 407 "ClntParser.y"
    {
      if (!StartIADeclaration(true)) {
        YYABORT;
      }
      EndIADeclaration();
      ;
      break;
    }
    case 91:
#line 418 "ClntParser.y"
    {
      if (!StartIADeclaration(true)) {
        YYABORT;
      }
      EndIADeclaration();
      ;
      break;
    }
    case 92:
#line 426 "ClntParser.y"
    {
      if (!StartIADeclaration(true)) {
        YYABORT;
      }
      EndIADeclaration();
      Log(Info) << "Setting IAID to " << yyvsp[0].ival << LogEnd;
      ClntCfgIALst.getLast()->setIAID(yyvsp[0].ival);
      ;
      break;
    }
    case 97:
#line 455 "ClntParser.y"
    {
      EmptyAddr();
      ;
      break;
    }
    case 98:
#line 460 "ClntParser.y"
    {
      ClntCfgAddrLst.append(new TClntCfgAddr(new TIPv6Addr(yyvsp[0].addrval)));
      ClntCfgAddrLst.getLast()->setOptions(ParserOptStack.getLast());
      ;
      break;
    }
    case 99:
#line 467 "ClntParser.y"
    {
      for (int i = 0; i < yyvsp[0].ival; i++) {
        EmptyAddr();
      };
      break;
    }
    case 100:
#line 475 "ClntParser.y"
    {
      // Get last context
      SPtr<TClntParsGlobalOpt> globalOpt = ParserOptStack.getLast();

      // Create new context based on the current one
      SPtr<TClntParsGlobalOpt> newOpt = new TClntParsGlobalOpt(*globalOpt);

      // Add this new context to the contexts stack
      ParserOptStack.append(newOpt);
      ;
      break;
    }
    case 101:
#line 486 "ClntParser.y"
    {
      EmptyAddr();               // Create an empty address
      ParserOptStack.delLast();  // Delete new context
      ;
      break;
    }
    case 102:
#line 493 "ClntParser.y"
    {
      // We need to store just one address, but let's use PresentAddrLst
      // We'll need that address to create an actual object when the context is
      // closed
      PresentAddrLst.clear();
      PresentAddrLst.append(SPtr<TIPv6Addr>(new TIPv6Addr(yyvsp[-1].addrval)));

      SPtr<TClntParsGlobalOpt> globalOpt = ParserOptStack.getLast();
      SPtr<TClntParsGlobalOpt> newOpt = new TClntParsGlobalOpt(*globalOpt);
      ParserOptStack.append(newOpt);
      ;
      break;
    }
    case 103:
#line 504 "ClntParser.y"
    {
      ClntCfgAddrLst.append(new TClntCfgAddr(PresentAddrLst.getLast()));
      ClntCfgAddrLst.getLast()->setOptions(ParserOptStack.getLast());
      if (ParserOptStack.count()) ParserOptStack.delLast();
      PresentAddrLst.clear();
      ;
      break;
    }
    case 104:
#line 514 "ClntParser.y"
    {
      // In this agregated declaration no address hints are allowed
      ParserOptStack.append(new TClntParsGlobalOpt(*ParserOptStack.getLast()));
      ParserOptStack.getLast()->setAddrHint(false);

      AddrCount_ = yyvsp[-1].ival;
      ;
      break;
    }
    case 105:
#line 522 "ClntParser.y"
    {
      for (unsigned int i = 0; i < AddrCount_; i++) {
        EmptyAddr();
        ClntCfgAddrLst.getLast()->setOptions(ParserOptStack.getLast());
      }
      ParserOptStack.delLast();
      AddrCount_ = 0;
      ;
      break;
    }
    case 110:
#line 544 "ClntParser.y"
    {
      if ((yyvsp[0].ival < 1) || (yyvsp[0].ival > 8)) {
        Log(Crit) << "Invalid loglevel specified: " << yyvsp[0].ival << ". Allowed range: 1-8."
                  << LogEnd;
      }
      logger::setLogLevel(yyvsp[0].ival);
      ;
      break;
    }
    case 111:
#line 553 "ClntParser.y"
    {
      logger::setLogMode(yyvsp[0].strval);
      delete[] yyvsp[0].strval;
      ;
      break;
    }
    case 112:
#line 558 "ClntParser.y"
    {
      logger::setLogName(yyvsp[0].strval);
      ;
      break;
    }
    case 113:
#line 564 "ClntParser.y"
    {
      logger::setColors(yyvsp[0].ival == 1);
      ;
      break;
    }
    case 114:
#line 569 "ClntParser.y"
    {
      this->DUIDType = DUID_TYPE_LLT;
      ;
      break;
    }
    case 115:
#line 570 "ClntParser.y"
    {
      this->DUIDType = DUID_TYPE_LL;
      ;
      break;
    }
    case 116:
#line 571 "ClntParser.y"
    {
      this->DUIDType = DUID_TYPE_EN;
      this->DUIDEnterpriseNumber = yyvsp[-1].ival;
      this->DUIDEnterpriseID = new TDUID(yyvsp[0].duidval.duid, yyvsp[0].duidval.length);
      ;
      break;
    }
    case 117:
#line 580 "ClntParser.y"
    {
      if (!ClntCfgIALst.empty()) {
        Log(Crit) << "Attempting to enable statelss, but IA (stateful option) is "
                     "already defined."
                  << LogEnd;
        YYABORT;
      }

      if (!ClntCfgTALst.empty()) {
        Log(Crit) << "Attempting to enable statelss, but TA (stateful option) is "
                     "already defined."
                  << LogEnd;
        YYABORT;
      }

      if (!ClntCfgPDLst.empty()) {
        Log(Crit) << "Attempting to enable statelss, but PD (stateful option) is "
                     "already defined."
                  << LogEnd;
        YYABORT;
      }

      ParserOptStack.getLast()->setStateful(false);
      ;
      break;
    }
    case 118:
#line 602 "ClntParser.y"
    {
      ParserOptStack.getLast()->setWorkDir(yyvsp[0].strval);
      ;
      break;
    }
    case 119:
#line 609 "ClntParser.y"
    {
      Log(Warning) << "strict-rfc-no-routing has changed in 1.0.0RC2: it now "
                      "takes one argument: "
                   << " 0 (address configured with guessed /64 prefix length "
                      "that may be wrong in "
                   << "some cases; dibbler clients prior to 1.0.0RC2 used this) "
                      "or 1 (address "
                   << "configured with /128, as RFC specifies); the default has "
                      "changed in 1.0.0RC2: "
                   << "Dibbler is now RFC conformant." << LogEnd;
      ;
      break;
    }
    case 120:
#line 617 "ClntParser.y"
    {
      switch (yyvsp[0].ival) {
        case 0:
          // This is pre 1.0.0RC2 behaviour
          Log(Warning) << "Strict-rfc-no-routing disabled: addresses will be "
                       << "configured with /64 prefix." << LogEnd;
          ParserOptStack.getLast()->setOnLinkPrefixLength(64);
          break;
        case 1:
          // The default is now /128 anyway, so this is a no-op
          Log(Warning) << "Strict-rfc-no-routing enabled (it is the default): "
                       << "addresses will be configured with /128 prefix." << LogEnd;
          break;
        default:
          Log(Crit) << "Invalid parameter passed to strict-rfc-no-routing: " << yyvsp[0].ival
                    << ", only 0 or 1" << LogEnd;
          YYABORT;
      };
      break;
    }
    case 121:
#line 640 "ClntParser.y"
    {
      CfgMgr->setScript(yyvsp[0].strval);
      delete[] yyvsp[0].strval;
      ;
      break;
    }
    case 122:
#line 646 "ClntParser.y"
    {
      DigestLst.clear();
      ;
      break;
    }
    case 123:
#line 648 "ClntParser.y"
    {
#ifndef MOD_DISABLE_AUTH
      CfgMgr->setAuthAcceptMethods(DigestLst);
      DigestLst.clear();
#else
      Log(Crit) << "Auth support disabled at compilation time." << LogEnd;
#endif
      ;
      break;
    }
    case 124:
#line 658 "ClntParser.y"
    {
#ifndef MOD_DISABLE_AUTH
      if (!strcasecmp(yyvsp[0].strval, "none")) {
        CfgMgr->setAuthProtocol(AUTH_PROTO_NONE);
        CfgMgr->setAuthAlgorithm(AUTH_ALGORITHM_NONE);
      } else if (!strcasecmp(yyvsp[0].strval, "delayed")) {
        CfgMgr->setAuthProtocol(AUTH_PROTO_DELAYED);
      } else if (!strcasecmp(yyvsp[0].strval, "reconfigure-key")) {
        CfgMgr->setAuthProtocol(AUTH_PROTO_RECONFIGURE_KEY);
        CfgMgr->setAuthAlgorithm(AUTH_ALGORITHM_RECONFIGURE_KEY);
      } else if (!strcasecmp(yyvsp[0].strval, "dibbler")) {
        CfgMgr->setAuthProtocol(AUTH_PROTO_DIBBLER);
      } else {
        Log(Crit) << "Invalid auth-protocol parameter: " << string(yyvsp[0].strval) << LogEnd;
        YYABORT;
      }
#else
      Log(Crit) << "Auth support disabled at compilation time." << LogEnd;
#endif
      ;
      break;
    }
    case 125:
#line 680 "ClntParser.y"
    {
#ifndef MOD_DISABLE_AUTH
      Log(Crit) << "auth-algorithm selection is not supported yet." << LogEnd;
      YYABORT;
#else
      Log(Crit) << "Auth support disabled at compilation time." << LogEnd;
#endif
      ;
      break;
    }
    case 127:
#line 691 "ClntParser.y"
    {
#ifndef MOD_DISABLE_AUTH
      if (strcasecmp(yyvsp[0].strval, "none")) {
        CfgMgr->setAuthReplay(AUTH_REPLAY_NONE);
      } else if (strcasecmp(yyvsp[0].strval, "monotonic")) {
        CfgMgr->setAuthReplay(AUTH_REPLAY_MONOTONIC);
      } else {
        Log(Crit) << "Invalid auth-replay parameter: " << string(yyvsp[0].strval) << LogEnd;
        YYABORT;
      }
#else
      Log(Crit) << "Auth support disabled at compilation time." << LogEnd;
#endif
      ;
      break;
    }
    case 128:
#line 707 "ClntParser.y"
    {
#ifndef MOD_DISABLE_AUTH
      CfgMgr->setAuthRealm(std::string(yyvsp[0].strval));
#else
      Log(Crit) << "Auth support disabled at compilation time." << LogEnd;
#endif
      ;
      break;
    }
    case 131:
#line 721 "ClntParser.y"
    {
      DigestLst.push_back(DIGEST_NONE);
      ;
      break;
    }
    case 132:
#line 722 "ClntParser.y"
    {
      DigestLst.push_back(DIGEST_PLAIN);
      ;
      break;
    }
    case 133:
#line 723 "ClntParser.y"
    {
      DigestLst.push_back(DIGEST_HMAC_MD5);
      ;
      break;
    }
    case 134:
#line 724 "ClntParser.y"
    {
      DigestLst.push_back(DIGEST_HMAC_SHA1);
      ;
      break;
    }
    case 135:
#line 725 "ClntParser.y"
    {
      DigestLst.push_back(DIGEST_HMAC_SHA224);
      ;
      break;
    }
    case 136:
#line 726 "ClntParser.y"
    {
      DigestLst.push_back(DIGEST_HMAC_SHA256);
      ;
      break;
    }
    case 137:
#line 727 "ClntParser.y"
    {
      DigestLst.push_back(DIGEST_HMAC_SHA384);
      ;
      break;
    }
    case 138:
#line 728 "ClntParser.y"
    {
      DigestLst.push_back(DIGEST_HMAC_SHA512);
      ;
      break;
    }
    case 139:
#line 733 "ClntParser.y"
    {
      ParserOptStack.getLast()->setAnonInfRequest(true);
      ;
      break;
    }
    case 140:
#line 739 "ClntParser.y"
    {
      ParserOptStack.getLast()->setInactiveMode(true);
      ;
      break;
    }
    case 141:
#line 745 "ClntParser.y"
    {
      ParserOptStack.getLast()->setInsistMode(true);
      ;
      break;
    }
    case 142:
#line 751 "ClntParser.y"
    {
      Log(Crit) << "Experimental features are allowed." << LogEnd;
      ParserOptStack.getLast()->setExperimental();
      ;
      break;
    }
    case 143:
#line 758 "ClntParser.y"
    {
      // ParserOptStack.getLast()->clearRejedSrv();
      PresentStationLst.clear();
      ;
      break;
    }
    case 144:
#line 762 "ClntParser.y"
    {
      ParserOptStack.getLast()->setRejedSrvLst(&PresentStationLst);
      ;
      break;
    }
    case 145:
#line 769 "ClntParser.y"
    {
      PresentStationLst.clear();
      ;
      break;
    }
    case 146:
#line 771 "ClntParser.y"
    {
      ParserOptStack.getLast()->setPrefSrvLst(&PresentStationLst);
      ;
      break;
    }
    case 147:
#line 778 "ClntParser.y"
    {
      ClntCfgIfaceLst.getLast()->setBindToAddr(SPtr<TIPv6Addr>(new TIPv6Addr(yyvsp[0].addrval)));
      ;
      break;
    }
    case 148:
#line 784 "ClntParser.y"
    {
      ParserOptStack.getLast()->setPref(yyvsp[0].ival);
      ;
      break;
    }
    case 149:
#line 791 "ClntParser.y"
    {
      ParserOptStack.getLast()->setRapidCommit(yyvsp[0].ival);
      ;
      break;
    }
    case 150:
#line 798 "ClntParser.y"
    {
      if (!ParserOptStack.getLast()->getExperimental()) {
        Log(Crit) << "Experimental 'addr-params' defined, but experimental features "
                     "are disabled."
                  << "Add 'experimental' in global section of client.conf to enable it." << LogEnd;
        YYABORT;
      }
      ParserOptStack.getLast()->setAddrParams(true);
      ;
      break;
    }
    case 151:
#line 809 "ClntParser.y"
    {
      if (!ParserOptStack.getLast()->getExperimental()) {
        Log(Crit) << "Experimental remote autoconfiguration feature defined, but "
                     "experimental"
                     " features are disabled. Add 'experimental' in global "
                     "section of client.conf "
                     "to enable it."
                  << LogEnd;
        YYABORT;
      }
#ifdef MOD_REMOTE_AUTOCONF
      CfgMgr->setRemoteAutoconf(true);
#else
      Log(Error) << "Remote autoconf support not compiled in." << LogEnd;
#endif
      ;
      break;
    }
    case 152:
#line 825 "ClntParser.y"
    {
      Log(Debug) << "Obeying Router Advertisement (M, O) bits." << LogEnd;
      CfgMgr->obeyRaBits(true);
      ;
      break;
    }
    case 153:
#line 832 "ClntParser.y"
    {
      Log(Debug) << "CONFIRM support disabled (skip-confirm in client.conf)." << LogEnd;
      ParserOptStack.getLast()->setConfirm(false);
      ;
      break;
    }
    case 154:
#line 839 "ClntParser.y"
    {
      Log(Debug) << "Reconfigure accept " << ((yyvsp[0].ival > 0) ? "enabled" : "disabled") << "."
                 << LogEnd;
      CfgMgr->setReconfigure(yyvsp[0].ival);
      ;
      break;
    }
    case 155:
#line 846 "ClntParser.y"
    {
      if (!strcasecmp(yyvsp[0].strval, "tcp"))
        CfgMgr->setDDNSProtocol(TCfgMgr::DNSUPDATE_TCP);
      else if (!strcasecmp(yyvsp[0].strval, "udp"))
        CfgMgr->setDDNSProtocol(TCfgMgr::DNSUPDATE_UDP);
      else if (!strcasecmp(yyvsp[0].strval, "any"))
        CfgMgr->setDDNSProtocol(TCfgMgr::DNSUPDATE_ANY);
      else {
        Log(Crit) << "Invalid ddns-protocol specifed:" << (yyvsp[0].strval)
                  << ", supported values are tcp, udp, any." << LogEnd;
        YYABORT;
      }
      Log(Debug) << "DDNS: Setting protocol to " << (yyvsp[0].strval) << LogEnd;
      ;
      break;
    }
    case 156:
#line 863 "ClntParser.y"
    {
      Log(Debug) << "DDNS: Setting timeout to " << yyvsp[0].ival << "ms." << LogEnd;
      CfgMgr->setDDNSTimeout(yyvsp[0].ival);
      ;
      break;
    }
    case 157:
#line 871 "ClntParser.y"
    {
      ParserOptStack.getLast()->setValid(yyvsp[0].ival);
      ;
      break;
    }
    case 158:
#line 878 "ClntParser.y"
    {
      ParserOptStack.getLast()->setT1(yyvsp[0].ival);
      ;
      break;
    }
    case 159:
#line 885 "ClntParser.y"
    {
      ParserOptStack.getLast()->setT2(yyvsp[0].ival);
      ;
      break;
    }
    case 160:
#line 892 "ClntParser.y"
    {
      Log(Debug) << "Prefix delegation option (no parameters) found." << LogEnd;
      if (!StartPDDeclaration()) {
        YYABORT;
      }
      EndPDDeclaration();
      ;
      break;
    }
    case 161:
#line 900 "ClntParser.y"
    {
      Log(Debug) << "Prefix delegation option (empty scope) found." << LogEnd;
      if (!StartPDDeclaration()) {
        YYABORT;
      }
      EndPDDeclaration();
      ;
      break;
    }
    case 162:
#line 908 "ClntParser.y"
    {
      Log(Debug) << "Prefix delegation option (with scope) found." << LogEnd;
      if (!StartPDDeclaration()) {
        YYABORT;
      };
      break;
    }
    case 163:
#line 915 "ClntParser.y"
    {
      EndPDDeclaration();
      ;
      break;
    }
    case 164:
#line 919 "ClntParser.y"
    {
      Log(Debug) << "Prefix delegation option (with IAID set to " << yyvsp[0].ival << " found."
                 << LogEnd;
      if (!StartPDDeclaration()) {
        YYABORT;
      }
      EndPDDeclaration();
      ClntCfgPDLst.getLast()->setIAID(yyvsp[0].ival);
      ;
      break;
    }
    case 165:
#line 928 "ClntParser.y"
    {
      if (!StartPDDeclaration()) {
        YYABORT;
      }
      this->iaid = yyvsp[-1].ival;
      ;
      break;
    }
    case 166:
#line 935 "ClntParser.y"
    {
      EndPDDeclaration();
      ClntCfgPDLst.getLast()->setIAID(yyvsp[-4].ival);
      ;
      break;
    }
    case 172:
#line 956 "ClntParser.y"
    {
      SPtr<TIPv6Addr> addr = new TIPv6Addr(yyvsp[-2].addrval);
      SPtr<TClntCfgPrefix> prefix = new TClntCfgPrefix(addr, (yyvsp[0].ival));
      PrefixLst.append(prefix);
      Log(Debug) << "PD: Adding single prefix " << addr->getPlain() << "/" << (yyvsp[0].ival) << "."
                 << LogEnd;
      ;
      break;
    }
    case 173:
#line 963 "ClntParser.y"
    {
      Log(Debug) << "PD: Adding single prefix." << LogEnd;
      SPtr<TClntCfgPrefix> prefix = new TClntCfgPrefix(new TIPv6Addr("::", true), 0);
      PrefixLst.append(prefix);
      ;
      break;
    }
    case 174:
#line 970 "ClntParser.y"
    {
      Log(Debug) << "PD: Adding single prefix." << LogEnd;
      SPtr<TClntCfgPrefix> prefix = new TClntCfgPrefix(new TIPv6Addr("::", true), 0);
      PrefixLst.append(prefix);
      ;
      break;
    }
    case 175:
#line 977 "ClntParser.y"
    {
      ;
      break;
    }
    case 176:
#line 980 "ClntParser.y"
    {
      Log(Debug) << "PD: Adding single (any) prefix." << LogEnd;
      SPtr<TClntCfgPrefix> prefix = new TClntCfgPrefix(new TIPv6Addr("::", true), 0);
      prefix->setOptions(ParserOptStack.getLast());
      PrefixLst.append(prefix);
      ;
      break;
    }
    case 177:
#line 988 "ClntParser.y"
    {
      SPtr<TIPv6Addr> addr = new TIPv6Addr(yyvsp[-3].addrval);
      SPtr<TClntCfgPrefix> prefix = new TClntCfgPrefix(addr, (yyvsp[-1].ival));
      PrefixLst.append(prefix);
      Log(Debug) << "PD: Adding single prefix " << addr->getPlain() << "/" << (yyvsp[-1].ival)
                 << "." << LogEnd;
      ;
      break;
    }
    case 178:
#line 995 "ClntParser.y"
    {
      PrefixLst.getLast()->setOptions(ParserOptStack.getLast());
      ;
      break;
    }
    case 183:
#line 1012 "ClntParser.y"
    {
      switch (yyvsp[0].ival) {
        case 0:
          ParserOptStack.getLast()->setUnicast(false);
          break;
        case 1:
          ParserOptStack.getLast()->setUnicast(true);
          break;
        default:
          Log(Error) << "Invalid parameter (" << yyvsp[0].ival << ") passed to unicast in line "
                     << Lex_->YYText() << "." << LogEnd;
          return 1;
      };
      break;
    }
    case 184:
#line 1030 "ClntParser.y"
    {
      switch (yyvsp[0].ival) {
        case 0:
          ClntCfgIfaceLst.getLast()->setRouting(false);
          break;
        case 1:
          ClntCfgIfaceLst.getLast()->setRouting(true);
          break;
        default:
          Log(Error) << "Invalid parameter (" << yyvsp[0].ival << ") passed to routing in line "
                     << Lex_->YYText() << "." << LogEnd;
          return 1;
      };
      break;
    }
    case 185:
#line 1047 "ClntParser.y"
    {
      PresentStationLst.append(SPtr<THostID>(new THostID(new TIPv6Addr(yyvsp[0].addrval))));
      ;
      break;
    }
    case 186:
#line 1051 "ClntParser.y"
    {
      PresentStationLst.append(
          SPtr<THostID>(new THostID(new TDUID(yyvsp[0].duidval.duid, yyvsp[0].duidval.length))));
      ;
      break;
    }
    case 187:
#line 1055 "ClntParser.y"
    {
      PresentStationLst.append(SPtr<THostID>(new THostID(new TIPv6Addr(yyvsp[0].addrval))));
      ;
      break;
    }
    case 188:
#line 1059 "ClntParser.y"
    {
      PresentStationLst.append(
          SPtr<THostID>(new THostID(new TDUID(yyvsp[0].duidval.duid, yyvsp[0].duidval.length))));
      ;
      break;
    }
    case 189:
#line 1065 "ClntParser.y"
    {
      PresentAddrLst.append(SPtr<TIPv6Addr>(new TIPv6Addr(yyvsp[0].addrval)));
      ;
      break;
    }
    case 190:
#line 1066 "ClntParser.y"
    {
      PresentAddrLst.append(SPtr<TIPv6Addr>(new TIPv6Addr(yyvsp[0].addrval)));
      ;
      break;
    }
    case 191:
#line 1070 "ClntParser.y"
    {
      PresentStringLst.append(SPtr<string>(new string(yyvsp[0].strval)));
      delete[] yyvsp[0].strval;
      ;
      break;
    }
    case 192:
#line 1071 "ClntParser.y"
    {
      PresentStringLst.append(SPtr<string>(new string(yyvsp[0].strval)));
      delete[] yyvsp[0].strval;
      ;
      break;
    }
    case 193:
#line 1074 "ClntParser.y"
    {
      yyval.ival = yyvsp[0].ival;
      ;
      break;
    }
    case 194:
#line 1075 "ClntParser.y"
    {
      yyval.ival = yyvsp[0].ival;
      ;
      break;
    }
    case 195:
#line 1083 "ClntParser.y"
    {
      PresentAddrLst.clear();
      //    PresentAddrLst.append(SPtr<TIPv6Addr> (new TIPv6Addr()));
      ParserOptStack.getLast()->setDNSServerLst(&PresentAddrLst);
      ;
      break;
    }
    case 196:
#line 1089 "ClntParser.y"
    {
      PresentAddrLst.clear();
      ;
      break;
    }
    case 197:
#line 1092 "ClntParser.y"
    {
      ParserOptStack.getLast()->setDNSServerLst(&PresentAddrLst);
      ;
      break;
    }
    case 198:
#line 1102 "ClntParser.y"
    {
      PresentStringLst.clear();
      ParserOptStack.getLast()->setDomainLst(&PresentStringLst);
      ;
      break;
    }
    case 199:
#line 1106 "ClntParser.y"
    {
      PresentStringLst.clear();
      ;
      break;
    }
    case 200:
#line 1109 "ClntParser.y"
    {
      ParserOptStack.getLast()->setDomainLst(&PresentStringLst);
      ;
      break;
    }
    case 201:
#line 1119 "ClntParser.y"
    {
      PresentAddrLst.clear();
      //    PresentAddrLst.append(SPtr<TIPv6Addr> (new TIPv6Addr()));
      ParserOptStack.getLast()->setNTPServerLst(&PresentAddrLst);
      ;
      break;
    }
    case 202:
#line 1124 "ClntParser.y"
    {
      PresentAddrLst.clear();
      ;
      break;
    }
    case 203:
#line 1127 "ClntParser.y"
    {
      ParserOptStack.getLast()->setNTPServerLst(&PresentAddrLst);
      ;
      break;
    }
    case 204:
#line 1137 "ClntParser.y"
    {
      ParserOptStack.getLast()->setTimezone(string(""));
      ;
      break;
    }
    case 205:
#line 1141 "ClntParser.y"
    {
      ParserOptStack.getLast()->setTimezone(yyvsp[0].strval);
      ;
      break;
    }
    case 206:
#line 1151 "ClntParser.y"
    {
      PresentAddrLst.clear();
      //    PresentAddrLst.append(SPtr<TIPv6Addr> (new TIPv6Addr()));
      ParserOptStack.getLast()->setSIPServerLst(&PresentAddrLst);
      ;
      break;
    }
    case 207:
#line 1156 "ClntParser.y"
    {
      PresentAddrLst.clear();
      ;
      break;
    }
    case 208:
#line 1159 "ClntParser.y"
    {
      ParserOptStack.getLast()->setSIPServerLst(&PresentAddrLst);
      ;
      break;
    }
    case 209:
#line 1169 "ClntParser.y"
    {
      PresentStringLst.clear();
      ParserOptStack.getLast()->setSIPDomainLst(&PresentStringLst);
      ;
      break;
    }
    case 210:
#line 1173 "ClntParser.y"
    {
      PresentStringLst.clear();
      ;
      break;
    }
    case 211:
#line 1176 "ClntParser.y"
    {
      ParserOptStack.getLast()->setSIPDomainLst(&PresentStringLst);
      ;
      break;
    }
    case 212:
#line 1186 "ClntParser.y"
    {
      char hostname[255];
      if (get_hostname(hostname, 255) == LOWLEVEL_NO_ERROR) {
        ParserOptStack.getLast()->setFQDN(string(hostname));
      } else {
        ParserOptStack.getLast()->setFQDN(string(""));
      };
      break;
    }
    case 213:
#line 1195 "ClntParser.y"
    {
      ParserOptStack.getLast()->setFQDN(yyvsp[0].strval);
      ;
      break;
    }
    case 214:
#line 1202 "ClntParser.y"
    {
      if (yyvsp[0].ival != 0 && yyvsp[0].ival != 1) {
        Log(Crit) << "Invalid FQDN S bit value: " << yyvsp[0].ival << ", expected 0 or 1."
                  << LogEnd;
        YYABORT;
      }

      Log(Info) << "Setting FQDN S bit to " << yyvsp[0].ival << LogEnd;
      ParserOptStack.getLast()->setFQDNFlagS(yyvsp[0].ival);
      ;
      break;
    }
    case 215:
#line 1217 "ClntParser.y"
    {
      PresentAddrLst.clear();
      //    PresentAddrLst.append(SPtr<TIPv6Addr> (new TIPv6Addr()));
      ParserOptStack.getLast()->setNISServerLst(&PresentAddrLst);
      ;
      break;
    }
    case 216:
#line 1222 "ClntParser.y"
    {
      PresentAddrLst.clear();
      ;
      break;
    }
    case 217:
#line 1225 "ClntParser.y"
    {
      ParserOptStack.getLast()->setNISServerLst(&PresentAddrLst);
      ;
      break;
    }
    case 218:
#line 1235 "ClntParser.y"
    {
      PresentAddrLst.clear();
      //    PresentAddrLst.append(SPtr<TIPv6Addr> (new TIPv6Addr()));
      ParserOptStack.getLast()->setNISPServerLst(&PresentAddrLst);
      ;
      break;
    }
    case 219:
#line 1240 "ClntParser.y"
    {
      PresentAddrLst.clear();
      ;
      break;
    }
    case 220:
#line 1243 "ClntParser.y"
    {
      ParserOptStack.getLast()->setNISPServerLst(&PresentAddrLst);
      ;
      break;
    }
    case 221:
#line 1253 "ClntParser.y"
    {
      ParserOptStack.getLast()->setNISDomain("");
      ;
      break;
    }
    case 222:
#line 1257 "ClntParser.y"
    {
      ParserOptStack.getLast()->setNISDomain(yyvsp[0].strval);
      ;
      break;
    }
    case 223:
#line 1268 "ClntParser.y"
    {
      ParserOptStack.getLast()->setNISPDomain("");
      ;
      break;
    }
    case 224:
#line 1272 "ClntParser.y"
    {
      ParserOptStack.getLast()->setNISPDomain(yyvsp[0].strval);
      ;
      break;
    }
    case 225:
#line 1282 "ClntParser.y"
    {
      if (ParserOptStack.getLast()->getStateful()) {
        Log(Crit) << "Information refresh time (lifetime) option can only be "
                     "used in stateless mode."
                  << LogEnd;
        YYABORT;
      }
      ParserOptStack.getLast()->setLifetime();
      ;
      break;
    }
    case 226:
#line 1293 "ClntParser.y"
    {
      Log(Debug) << "VendorSpec defined (no details)." << LogEnd;
      ParserOptStack.getLast()->setVendorSpec();
      ;
      break;
    }
    case 227:
#line 1298 "ClntParser.y"
    {
      ParserOptStack.getLast()->setVendorSpec();
      Log(Debug) << "VendorSpec defined (multiple times)." << LogEnd;
      ;
      break;
    }
    case 228:
#line 1305 "ClntParser.y"
    {
      VendorSpec.append(new TOptVendorSpecInfo(OPTION_VENDOR_OPTS, yyvsp[0].ival, 0, 0, 0, 0));
      ;
      break;
    }
    case 229:
#line 1306 "ClntParser.y"
    {
      VendorSpec.append(
          new TOptVendorSpecInfo(OPTION_VENDOR_OPTS, yyvsp[-2].ival, yyvsp[0].ival, 0, 0, 0));
      ;
      break;
    }
    case 230:
#line 1307 "ClntParser.y"
    {
      VendorSpec.append(new TOptVendorSpecInfo(OPTION_VENDOR_OPTS, yyvsp[0].ival, 0, 0, 0, 0));
      ;
      break;
    }
    case 231:
#line 1308 "ClntParser.y"
    {
      VendorSpec.append(
          new TOptVendorSpecInfo(OPTION_VENDOR_OPTS, yyvsp[-2].ival, yyvsp[0].ival, 0, 0, 0));
      ;
      break;
    }
    case 232:
#line 1313 "ClntParser.y"
    {
      ClntCfgIfaceLst.getLast()->addExtraOption(OPTION_AFTR_NAME, TOpt::Layout_String, false);
      ;
      break;
    }
    case 233:
#line 1320 "ClntParser.y"
    {
      // option 123 hex 0x1234abcd
      SPtr<TOpt> opt =
          new TOptGeneric(yyvsp[-2].ival, yyvsp[0].duidval.duid, yyvsp[0].duidval.length, 0);
      ClntCfgIfaceLst.getLast()->addExtraOption(opt, TOpt::Layout_Duid, true);
      Log(Debug) << "Will send option " << yyvsp[-2].ival << " (hex data, len"
                 << yyvsp[0].duidval.length << ")" << LogEnd;
      ;
      break;
    }
    case 234:
#line 1327 "ClntParser.y"
    {
      // option 123 address 2001:db8::1
      SPtr<TIPv6Addr> addr(new TIPv6Addr(yyvsp[0].addrval));

      SPtr<TOpt> opt = new TOptAddr(yyvsp[-2].ival, addr, 0);
      ClntCfgIfaceLst.getLast()->addExtraOption(opt, TOpt::Layout_Addr, true);
      Log(Debug) << "Will send option " << yyvsp[-2].ival << " (address " << addr->getPlain() << ")"
                 << LogEnd;
      ;
      break;
    }
    case 235:
#line 1336 "ClntParser.y"
    {
      // option 123 address-list 2001:db8::1,2001:db8::cafe
      PresentAddrLst.clear();
      ;
      break;
    }
    case 236:
#line 1340 "ClntParser.y"
    {
      SPtr<TOpt> opt = new TOptAddrLst(yyvsp[-3].ival, PresentAddrLst, 0);
      ClntCfgIfaceLst.getLast()->addExtraOption(opt, TOpt::Layout_AddrLst, true);
      Log(Debug) << "Will send option " << yyvsp[-3].ival << " (address list, containing "
                 << PresentAddrLst.count() << " addresses)." << LogEnd;
      ;
      break;
    }
    case 237:
#line 1347 "ClntParser.y"
    {
      // option 123 string "foobar"
      SPtr<TOpt> opt = new TOptString(yyvsp[-2].ival, string(yyvsp[0].strval), 0);
      ClntCfgIfaceLst.getLast()->addExtraOption(opt, TOpt::Layout_String, true);
      Log(Debug) << "Will send option " << yyvsp[-2].ival << " (string " << yyvsp[0].strval << ")"
                 << LogEnd;
      ;
      break;
    }
    case 238:
#line 1354 "ClntParser.y"
    {
      // just request option 123 and interpret responses as hex
      Log(Debug) << "Will request option " << yyvsp[-1].ival << " and iterpret response as hex."
                 << LogEnd;
      ClntCfgIfaceLst.getLast()->addExtraOption(yyvsp[-1].ival, TOpt::Layout_Duid, false);
      ;
      break;
    }
    case 239:
#line 1360 "ClntParser.y"
    {
      // just request this option and expect OptAddr layout
      Log(Debug) << "Will request option " << yyvsp[-1].ival
                 << " and interpret response as IPv6 address." << LogEnd;
      ClntCfgIfaceLst.getLast()->addExtraOption(yyvsp[-1].ival, TOpt::Layout_Addr, false);
      ;
      break;
    }
    case 240:
#line 1367 "ClntParser.y"
    {
      // just request this option and expect OptString layout
      Log(Debug) << "Will request option " << yyvsp[-1].ival
                 << " and interpret response as a string." << LogEnd;
      ClntCfgIfaceLst.getLast()->addExtraOption(yyvsp[-1].ival, TOpt::Layout_String, false);
      ;
      break;
    }
    case 241:
#line 1373 "ClntParser.y"
    {
      // just request this option and expect OptAddrLst layout
      Log(Debug) << "Will request option " << yyvsp[-1].ival
                 << " and interpret response as an address list." << LogEnd;
      ClntCfgIfaceLst.getLast()->addExtraOption(yyvsp[-1].ival, TOpt::Layout_AddrLst, false);
      ;
      break;
    }
  }

#line 840 "../bison++/bison.cc"
  /* the action file gets copied in in place of this dollarsign  */
  yyvsp -= yylen;
  yyssp -= yylen;
#ifdef YY_ClntParser_LSP_NEEDED
  yylsp -= yylen;
#endif

#if YY_ClntParser_DEBUG != 0
  if (YY_ClntParser_DEBUG_FLAG) {
    short *ssp1 = yyss - 1;
    fprintf(stderr, "state stack now");
    while (ssp1 != yyssp) fprintf(stderr, " %d", *++ssp1);
    fprintf(stderr, "\n");
  }
#endif

  *++yyvsp = yyval;

#ifdef YY_ClntParser_LSP_NEEDED
  yylsp++;
  if (yylen == 0) {
    yylsp->first_line = YY_ClntParser_LLOC.first_line;
    yylsp->first_column = YY_ClntParser_LLOC.first_column;
    yylsp->last_line = (yylsp - 1)->last_line;
    yylsp->last_column = (yylsp - 1)->last_column;
    yylsp->text = 0;
  } else {
    yylsp->last_line = (yylsp + yylen - 1)->last_line;
    yylsp->last_column = (yylsp + yylen - 1)->last_column;
  }
#endif

  /* Now "shift" the result of the reduction.
     Determine what state that goes to,
     based on the state we popped back to
     and the rule number reduced by.  */

  yyn = yyr1[yyn];

  yystate = yypgoto[yyn - YYNTBASE] + *yyssp;
  if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *yyssp)
    yystate = yytable[yystate];
  else
    yystate = yydefgoto[yyn - YYNTBASE];

  YYGOTO(yynewstate);

  YYLABEL(yyerrlab) /* here on detecting error */

  if (!yyerrstatus)
  /* If not already recovering from an error, report this error.  */
  {
    ++YY_ClntParser_NERRS;

#ifdef YY_ClntParser_ERROR_VERBOSE
    yyn = yypact[yystate];

    if (yyn > YYFLAG && yyn < YYLAST) {
      int size = 0;
      char *msg;
      int x, count;

      count = 0;
      /* Start X at -yyn if nec to avoid negative indexes in yycheck.  */
      for (x = (yyn < 0 ? -yyn : 0); x < (sizeof(yytname) / sizeof(char *)); x++)
        if (yycheck[x + yyn] == x) size += strlen(yytname[x]) + 15, count++;
      msg = (char *)malloc(size + 15);
      if (msg != 0) {
        strcpy(msg, "parse error");

        if (count < 5) {
          count = 0;
          for (x = (yyn < 0 ? -yyn : 0); x < (sizeof(yytname) / sizeof(char *)); x++)
            if (yycheck[x + yyn] == x) {
              strcat(msg, count == 0 ? ", expecting `" : " or `");
              strcat(msg, yytname[x]);
              strcat(msg, "'");
              count++;
            }
        }
        YY_ClntParser_ERROR(msg);
        free(msg);
      } else
        YY_ClntParser_ERROR("parse error; also virtual memory exceeded");
    } else
#endif /* YY_ClntParser_ERROR_VERBOSE */
      YY_ClntParser_ERROR((char *)"parse error");
  }

  YYGOTO(yyerrlab1);
  YYLABEL(yyerrlab1) /* here on error raised explicitly by an action */

  if (yyerrstatus == 3) {
    /* if just tried and failed to reuse lookahead token after an error, discard
     * it.  */

    /* return failure if at end of input */
    if (YY_ClntParser_CHAR == YYEOF) YYABORT;

#if YY_ClntParser_DEBUG != 0
    if (YY_ClntParser_DEBUG_FLAG)
      fprintf(stderr, "Discarding token %d (%s).\n", YY_ClntParser_CHAR, yytname[yychar1]);
#endif

    YY_ClntParser_CHAR = YYEMPTY;
  }

  /* Else will try to reuse lookahead token
     after shifting the error token.  */

  yyerrstatus = 3; /* Each real token shifted decrements this */

  YYGOTO(yyerrhandle);

  YYLABEL(yyerrdefault) /* current state does not do anything special for the
                           error token. */

#if 0
  /* This is wrong; only states that explicitly want error tokens
     should shift them.  */
  yyn = yydefact[yystate];  /* If its default is to accept any token, ok.  Otherwise pop it.*/
  if (yyn) YYGOTO(yydefault);
#endif

  YYLABEL(yyerrpop) /* pop the current state because it cannot handle the error
                       token */

  if (yyssp == yyss) YYABORT;
  yyvsp--;
  yystate = *--yyssp;
#ifdef YY_ClntParser_LSP_NEEDED
  yylsp--;
#endif

#if YY_ClntParser_DEBUG != 0
  if (YY_ClntParser_DEBUG_FLAG) {
    short *ssp1 = yyss - 1;
    fprintf(stderr, "Error: state stack now");
    while (ssp1 != yyssp) fprintf(stderr, " %d", *++ssp1);
    fprintf(stderr, "\n");
  }
#endif

  YYLABEL(yyerrhandle)

  yyn = yypact[yystate];
  if (yyn == YYFLAG) YYGOTO(yyerrdefault);

  yyn += YYTERROR;
  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != YYTERROR) YYGOTO(yyerrdefault);

  yyn = yytable[yyn];
  if (yyn < 0) {
    if (yyn == YYFLAG) YYGOTO(yyerrpop);
    yyn = -yyn;
    YYGOTO(yyreduce);
  } else if (yyn == 0)
    YYGOTO(yyerrpop);

  if (yyn == YYFINAL) YYACCEPT;

#if YY_ClntParser_DEBUG != 0
  if (YY_ClntParser_DEBUG_FLAG) fprintf(stderr, "Shifting error token, ");
#endif

  *++yyvsp = YY_ClntParser_LVAL;
#ifdef YY_ClntParser_LSP_NEEDED
  *++yylsp = YY_ClntParser_LLOC;
#endif

  yystate = yyn;
  YYGOTO(yynewstate);
  /* end loop, in which YYGOTO may be used. */
  YYENDGOTO
}

/* END */

#line 1039 "../bison++/bison.cc"
#line 1380 "ClntParser.y"

/////////////////////////////////////////////////////////////////////////////
// programs section
/////////////////////////////////////////////////////////////////////////////

/**
 * method check whether interface with id=ifaceNr has been
 * already declared.
 *
 * @param ifindex interface index of the checked interface
 *
 * @return true if not declared.
 */
bool ClntParser::IfaceDefined(int ifindex) {
  SPtr<TClntCfgIface> ptr;
  ClntCfgIfaceLst.first();
  while (ptr = ClntCfgIfaceLst.get()) {
    if ((ptr->getID()) == ifindex) {
      Log(Crit) << "Interface with ifindex=" << ifindex << " is already defined." << LogEnd;
      return false;
    }
  }
  return true;
}

// method check whether interface with id=ifaceName has been
// already declared
/**
 * method check whether interface with specified name has been
 * already declared.
 *
 * @param ifaceName name of the checked interface
 *
 * @return true if not declared.
 */
bool ClntParser::IfaceDefined(const std::string &ifaceName) {
  SPtr<TClntCfgIface> ptr;
  ClntCfgIfaceLst.first();
  while (ptr = ClntCfgIfaceLst.get()) {
    if (ptr->getName() == ifaceName) {
      Log(Crit) << "Interface " << ifaceName << " is already defined." << LogEnd;
      return false;
    }
  };
  return true;
}

/**
 * creates new scope appropriately for interface options and declarations
 * clears all lists except the list of interfaces and adds new group
 */
bool ClntParser::StartIfaceDeclaration(const std::string &ifaceName) {
  if (!IfaceDefined(ifaceName)) return false;

  ClntCfgIfaceLst.append(new TClntCfgIface(ifaceName));

  // Interface scope, so parameters associated with global scope are pushed on
  // stack
  ParserOptStack.append(new TClntParsGlobalOpt(*ParserOptStack.getLast()));
  ClntCfgIALst.clear();
  ClntCfgAddrLst.clear();
  this->VendorSpec.clear();
  return true;
}

/**
 * creates new scope appropriately for interface options and declarations
 * clears all lists except the list of interfaces and adds new group
 */
bool ClntParser::StartIfaceDeclaration(int ifindex) {
  if (!IfaceDefined(ifindex)) return false;

  ClntCfgIfaceLst.append(new TClntCfgIface(ifindex));

  // Interface scope, so parameters associated with global scope are pushed on
  // stack
  ParserOptStack.append(new TClntParsGlobalOpt(*ParserOptStack.getLast()));
  ClntCfgIALst.clear();
  ClntCfgAddrLst.clear();
  this->VendorSpec.clear();
  return true;
}

bool ClntParser::EndIfaceDeclaration() {
  SPtr<TClntCfgIface> iface = ClntCfgIfaceLst.getLast();
  if (!iface) {
    Log(Crit) << "Internal error: Interface not found. Something is wrong. "
                 "Very wrong."
              << LogEnd;
    return false;
  }

  // set interface options on the basis of just read information
  // preferred-server and rejected-servers are also copied here
  if (VendorSpec.count()) ParserOptStack.getLast()->setVendorSpec(VendorSpec);
  iface->setOptions(ParserOptStack.getLast());
  iface->setOnLinkPrefixLength(ParserOptStack.getLast()->getOnLinkPrefixLength());

  if ((iface->stateless()) && (ClntCfgIALst.count())) {
    Log(Crit) << "Interface " << iface->getFullName()
              << " is configured stateless, "
                 " but has "
              << ClntCfgIALst.count() << " IA(s) defined." << LogEnd;
    return false;
  }

  if ((iface->stateless()) && (ClntCfgTALst.count())) {
    Log(Crit) << "Interface " << iface->getFullName()
              << " is configured stateless, "
                 " but has TA defined."
              << LogEnd;
    return false;
  }

  // add all IAs to the interface
  SPtr<TClntCfgIA> ia;
  ClntCfgIALst.first();
  while (ia = ClntCfgIALst.get()) {
    ClntCfgIfaceLst.getLast()->addIA(ia);
  }

  // add all TAs to the interface
  SPtr<TClntCfgTA> ptrTA;
  ClntCfgTALst.first();
  while (ptrTA = ClntCfgTALst.get()) {
    iface->addTA(ptrTA);
  }

  // add all PDs to the interface
  SPtr<TClntCfgPD> pd;
  ClntCfgPDLst.first();
  while (pd = ClntCfgPDLst.get()) {
    iface->addPD(pd);
  }

  // restore global options
  ParserOptStack.delLast();
  ClntCfgIALst.clear();
  return true;
}

void ClntParser::EmptyIface() {
  // set iface options on the basis of recent information
  ClntCfgIfaceLst.getLast()->setOptions(ParserOptStack.getLast());
  // add one IA with one address to this iface
  EmptyIA();
  ClntCfgIALst.getLast()->setOptions(ParserOptStack.getLast());
  ClntCfgIfaceLst.getLast()->addIA(ClntCfgIALst.getLast());
}

/// method creates new scope appropriately for interface options and
/// declarations clears list of addresses
///
/// @param aggregation - does this IA contains suboptions ( ia { ... } )
/// @return true if creation was successful
bool ClntParser::StartIADeclaration(bool aggregation) {
  if (!ParserOptStack.getLast()->getStateful()) {
    Log(Crit) << "Attempted to use IA (stateful option) in stateless mode." << LogEnd;
    return (false);
  }

  ParserOptStack.append(new TClntParsGlobalOpt(*ParserOptStack.getLast()));
  ParserOptStack.getLast()->setAddrHint(!aggregation);
  ClntCfgAddrLst.clear();

  return (true);
}

/**
 * Inbelivable piece of crap code. If you read this, rewrite this code
 * immediately.
 *
 */
void ClntParser::EndIADeclaration() {
  if (!ClntCfgAddrLst.count()) {
    EmptyIA();
  } else {
    SPtr<TClntCfgIA> ia = new TClntCfgIA();
    ClntCfgIALst.append(ia);
    SPtr<TClntCfgAddr> ptr;
    ClntCfgAddrLst.first();
    while (ptr = ClntCfgAddrLst.get()) ia->addAddr(ptr);
  }

  // set proper options specific for this IA
  ClntCfgIALst.getLast()->setOptions(ParserOptStack.getLast());

  ClntCfgAddrLst.clear();
  ParserOptStack.delLast();

  // this IA matches with previous ones and can be grouped with them
  // so it's should be left on the list and be appended with them to present
  // list
}

/// @brief creates PD context
///
/// @return true if initialization was successful
bool ClntParser::StartPDDeclaration() {
  if (!ParserOptStack.getLast()->getStateful()) {
    Log(Crit) << "Attempted to use PD (stateful option) in stateless mode." << LogEnd;
    return (false);
  }

  ParserOptStack.append(new TClntParsGlobalOpt(*ParserOptStack.getLast()));
  ClntCfgAddrLst.clear();
  PrefixLst.clear();
  return (true);
}

bool ClntParser::EndPDDeclaration() {
  SPtr<TClntCfgPD> pd = new TClntCfgPD();
  pd->setOptions(ParserOptStack.getLast());

  // copy all defined prefixes
  PrefixLst.first();
  SPtr<TClntCfgPrefix> prefix;
  while (prefix = PrefixLst.get()) {
    pd->addPrefix(prefix);
  }

  PrefixLst.clear();

  ClntCfgPDLst.append(pd);
  ParserOptStack.delLast();
  return true;
}

/**
 * method adds 1 IA object (containing 1 address) to the ClntCfgIA list.
 * Both objects' properties are set to last parsed values
 *
 */
void ClntParser::EmptyIA() {
  EmptyAddr();
  ClntCfgIALst.append(new TClntCfgIA());
  ClntCfgIALst.getLast()->setOptions(ParserOptStack.getLast());

  // Commented out: by default sent empty IA, without any addresses
  // ClntCfgIALst.getLast()->addAddr(ClntCfgAddrLst.getLast());
}

/**
 * method adds empty address to the ClntCfgAddrList list and sets
 * its properties to last parsed values
 *
 */
void ClntParser::EmptyAddr() {
  ClntCfgAddrLst.append(new TClntCfgAddr());
  ClntCfgAddrLst.getLast()->setOptions(ParserOptStack.getLast());
}

int ClntParser::yylex() {
  memset(&std::yylval, 0, sizeof(std::yylval));
  memset(&this->yylval, 0, sizeof(this->yylval));
  int x = Lex_->yylex();
  this->yylval = std::yylval;
  return x;
}

/**
 * This method is called when parsing error is detected.
 *
 * @param m - first invalid character
 */
void ClntParser::yyerror(char *m) {
  Log(Crit) << "Config parse error: line " << Lex_->lineno() << ", unexpected [" << Lex_->YYText()
            << "] token." << LogEnd;
}

/**
 * Desctructor. Just cleans things up
 *
 */

ClntParser::~ClntParser() {
  this->ClntCfgIfaceLst.clear();
  this->ClntCfgIALst.clear();
  this->ClntCfgTALst.clear();
  this->ClntCfgAddrLst.clear();
}
