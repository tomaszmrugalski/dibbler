#define YY_RelParser_h_included
#define YY_USE_CLASS

/*  A Bison++ parser, made from RelParser.y  */

/* with Bison++ version bison++ Version 1.21.9-1, adapted from GNU bison by
coetmeur@icdc.fr Maintained by Magnus Ekdahl <magnus@debian.org>
 */

#define YY_USE_CLASS

#line 1 "../bison++/bison.cc"
/* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
/* Skeleton output parser for bison,
   Copyright (C) 1984, 1989, 1990 Bob Corbett and Richard Stallman

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 1, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

   As a special exception, when this file is copied by Bison++ into a
   Bison++ output file, you may use that output file without restriction.
   This special exception was added by the Free Software Foundation
   in version 1.24 of Bison, and has been in Bison++ since 1.21.9.

*/

/* HEADER SECTION */
#if defined(_MSDOS) || defined(MSDOS) || defined(__MSDOS__)
#define __MSDOS_AND_ALIKE
#endif

#if defined(_WINDOWS) && defined(_MSC_VER)
#define __HAVE_NO_ALLOCA
#define __MSDOS_AND_ALIKE
#endif

#ifndef alloca
#if defined(__GNUC__)
#define alloca __builtin_alloca

#elif (!defined(__STDC__) && defined(sparc)) || defined(__sparc__) || defined(__sparc) || \
    defined(__sgi)
#include <alloca.h>

#elif defined(__MSDOS_AND_ALIKE)
#include <malloc.h>
#ifndef __TURBOC__
/* MS C runtime lib */
#define alloca _alloca
#endif

#elif defined(_AIX)
/* pragma must be put before any C/C++ instruction !! */
#pragma alloca
#include <malloc.h>

#elif defined(__hpux)
#ifdef __cplusplus
extern "C" {
void *alloca(unsigned int);
};
#else  /* not __cplusplus */
void *alloca();
#endif /* not __cplusplus */

#endif /* not _AIX  not MSDOS, or __TURBOC__ or _AIX, not sparc.  */
#endif /* alloca not defined.  */

#ifdef c_plusplus
#ifndef __cplusplus
#define __cplusplus
#endif
#endif

#ifdef __cplusplus
#ifndef YY_USE_CLASS
/*#warning "For C++ its recomended to use bison++, otherwise classes won't be
 * generated"*/
#endif
#else
#ifndef __STDC__
#define const
#endif
#ifdef YY_USE_CLASS
#error "This is a C++ header generated by bison++, please use a C++ compiler!"
#endif
#endif

#include <stdio.h>
#define YYBISON 1

#line 88 "../bison++/bison.cc"
#line 3 "RelParser.y"

#include "Container.h"
#include "DHCPConst.h"
#include "DUID.h"
#include "Logger.h"
#include "OptDUID.h"
#include "OptVendorData.h"
#include "Portable.h"
#include "RelCfgIface.h"
#include "RelCfgMgr.h"
#include "RelParsGlobalOpt.h"
#include "RelParsIfaceOpt.h"
#include "RelParser.h"
#include "SmartPtr.h"
#include <iostream>
#include <malloc.h>
#include <string.h>
#include <string>

using namespace std;

#define YY_USE_CLASS
#line 27 "RelParser.y"

#include "FlexLexer.h"
#define YY_RelParser_MEMBERS                                                        \
  FlexLexer *lex;                                                                   \
  List(TRelParsGlobalOpt) ParserOptStack; /* list of parsed interfaces/IAs/addrs */ \
  List(TRelCfgIface) RelCfgIfaceLst;      /* list of RelCfg interfaces */           \
  List(TIPv6Addr) PresentAddrLst;         /* address list (used for DNS,NTP,etc.)*/ \
  List(std::string) PresentStringLst;     /* string list */                         \
  SPtr<TRelOptEcho> EchoOpt;              /* echo request option */                 \
  /*method check whether interface with id=ifaceNr has been already declared        \
   */                                                                               \
  bool CheckIsIface(int ifaceNr);                                                   \
  /*method check whether interface with id=ifaceName has been already               \
   * declared*/                                                                     \
  bool CheckIsIface(string ifaceName);                                              \
  void StartIfaceDeclaration();                                                     \
  bool EndIfaceDeclaration();                                                       \
  TRelCfgMgr *CfgMgr;                                                               \
  virtual ~RelParser();
#define YY_RelParser_CONSTRUCTOR_PARAM yyFlexLexer *lex
#define YY_RelParser_CONSTRUCTOR_CODE             \
  ParserOptStack.append(new TRelParsGlobalOpt()); \
  this->lex = lex;                                \
  yynerrs = 0;                                    \
  yychar = 0;

#line 55 "RelParser.y"
typedef union {
  unsigned int ival;
  char *strval;
  char addrval[16];
  struct SDuid {
    int length;
    char *duid;
  } duidval;
} yy_RelParser_stype;
#define YY_RelParser_STYPE yy_RelParser_stype

#line 88 "../bison++/bison.cc"
/* %{ and %header{ and %union, during decl */
#define YY_RelParser_BISON 1

#ifndef YY_RelParser_COMPATIBILITY
#ifndef YY_USE_CLASS
#define YY_RelParser_COMPATIBILITY 1
#else
#define YY_RelParser_COMPATIBILITY 0
#endif
#endif

#if YY_RelParser_COMPATIBILITY != 0
/* backward compatibility */
#ifdef YYLTYPE
#ifndef YY_RelParser_LTYPE
#define YY_RelParser_LTYPE YYLTYPE
#endif
#endif
/* Testing alternative bison solution
   /#ifdef YYSTYPE*/
#ifndef YY_RelParser_STYPE
#define YY_RelParser_STYPE YYSTYPE
#endif
/*#endif*/
#ifdef YYDEBUG
#ifndef YY_RelParser_DEBUG
#define YY_RelParser_DEBUG YYDEBUG
#endif
#endif

/* use goto to be compatible */
#ifndef YY_RelParser_USE_GOTO
#define YY_RelParser_USE_GOTO 1
#endif
#endif

/* use no goto to be clean in C++ */
#ifndef YY_RelParser_USE_GOTO
#define YY_RelParser_USE_GOTO 0
#endif

#ifndef YY_RelParser_PURE

#line 130 "../bison++/bison.cc"

#line 130 "../bison++/bison.cc"
/*  YY_RelParser_PURE */
#endif

/* section apres lecture def, avant lecture grammaire S2 */

#line 134 "../bison++/bison.cc"

#line 134 "../bison++/bison.cc"
/* prefix */
#ifndef YY_RelParser_DEBUG

#line 136 "../bison++/bison.cc"
#define YY_RelParser_DEBUG 1

#line 136 "../bison++/bison.cc"
/* YY_RelParser_DEBUG */
#endif

#ifndef YY_RelParser_LSP_NEEDED

#line 141 "../bison++/bison.cc"

#line 141 "../bison++/bison.cc"
/* YY_RelParser_LSP_NEEDED*/
#endif

/* DEFAULT LTYPE*/
#ifdef YY_RelParser_LSP_NEEDED
#ifndef YY_RelParser_LTYPE
#ifndef BISON_YYLTYPE_ISDECLARED
#define BISON_YYLTYPE_ISDECLARED
typedef struct yyltype {
  int timestamp;
  int first_line;
  int first_column;
  int last_line;
  int last_column;
  char *text;
} yyltype;

#endif
#define YY_RelParser_LTYPE yyltype
#endif
#endif
/* DEFAULT STYPE*/
/* We used to use `unsigned long' as YY_RelParser_STYPE on MSDOS,
   but it seems better to be consistent.
   Most programs should declare their own type anyway.  */

#ifndef YY_RelParser_STYPE
#define YY_RelParser_STYPE int
#endif
/* DEFAULT MISCELANEOUS */
#ifndef YY_RelParser_PARSE
#define YY_RelParser_PARSE yyparse
#endif
#ifndef YY_RelParser_LEX
#define YY_RelParser_LEX yylex
#endif
#ifndef YY_RelParser_LVAL
#define YY_RelParser_LVAL yylval
#endif
#ifndef YY_RelParser_LLOC
#define YY_RelParser_LLOC yylloc
#endif
#ifndef YY_RelParser_CHAR
#define YY_RelParser_CHAR yychar
#endif
#ifndef YY_RelParser_NERRS
#define YY_RelParser_NERRS yynerrs
#endif
#ifndef YY_RelParser_DEBUG_FLAG
#define YY_RelParser_DEBUG_FLAG yydebug
#endif
#ifndef YY_RelParser_ERROR
#define YY_RelParser_ERROR yyerror
#endif

#ifndef YY_RelParser_PARSE_PARAM
#ifndef YY_USE_CLASS
#ifdef YYPARSE_PARAM
#define YY_RelParser_PARSE_PARAM void *YYPARSE_PARAM
#else
#ifndef __STDC__
#ifndef __cplusplus
#define YY_RelParser_PARSE_PARAM
#endif
#endif
#endif
#endif
#ifndef YY_RelParser_PARSE_PARAM
#define YY_RelParser_PARSE_PARAM void
#endif
#endif

#if YY_RelParser_COMPATIBILITY != 0
/* backward compatibility */
#ifdef YY_RelParser_LTYPE
#ifndef YYLTYPE
#define YYLTYPE YY_RelParser_LTYPE
#else
/* WARNING obsolete !!! user defined YYLTYPE not reported into generated header
 */
#endif
#endif

/* Removed due to bison compabilityproblems
/#ifndef YYSTYPE
/#define YYSTYPE YY_RelParser_STYPE
/#else*/
/* WARNING obsolete !!! user defined YYSTYPE not reported into generated header
 */
/*#endif*/

#ifdef YY_RelParser_PURE
#ifndef YYPURE
#define YYPURE YY_RelParser_PURE
#endif
#endif

#ifdef YY_RelParser_DEBUG
#ifndef YYDEBUG
#define YYDEBUG YY_RelParser_DEBUG
#endif
#endif

#ifndef YY_RelParser_ERROR_VERBOSE
#ifdef YYERROR_VERBOSE
#define YY_RelParser_ERROR_VERBOSE YYERROR_VERBOSE
#endif
#endif

#ifndef YY_RelParser_LSP_NEEDED
#ifdef YYLSP_NEEDED
#define YY_RelParser_LSP_NEEDED YYLSP_NEEDED
#endif
#endif

#endif

#ifndef YY_USE_CLASS
/* TOKEN C */

#line 263 "../bison++/bison.cc"
#define IFACE_ 258
#define CLIENT_ 259
#define SERVER_ 260
#define UNICAST_ 261
#define MULTICAST_ 262
#define IFACE_ID_ 263
#define IFACE_ID_ORDER_ 264
#define LOGNAME_ 265
#define LOGLEVEL_ 266
#define LOGMODE_ 267
#define WORKDIR_ 268
#define DUID_ 269
#define OPTION_ 270
#define REMOTE_ID_ 271
#define ECHO_REQUEST_ 272
#define RELAY_ID_ 273
#define LINK_LAYER_ 274
#define GUESS_MODE_ 275
#define STRING_ 276
#define HEXNUMBER_ 277
#define INTNUMBER_ 278
#define IPV6ADDR_ 279

#line 263 "../bison++/bison.cc"
/* #defines tokens */
#else
/* CLASS */
#ifndef YY_RelParser_CLASS
#define YY_RelParser_CLASS RelParser
#endif
#ifndef YY_RelParser_INHERIT
#define YY_RelParser_INHERIT
#endif
#ifndef YY_RelParser_MEMBERS
#define YY_RelParser_MEMBERS
#endif
#ifndef YY_RelParser_LEX_BODY
#define YY_RelParser_LEX_BODY
#endif
#ifndef YY_RelParser_ERROR_BODY
#define YY_RelParser_ERROR_BODY
#endif
#ifndef YY_RelParser_CONSTRUCTOR_PARAM
#define YY_RelParser_CONSTRUCTOR_PARAM
#endif
#ifndef YY_RelParser_CONSTRUCTOR_CODE
#define YY_RelParser_CONSTRUCTOR_CODE
#endif
#ifndef YY_RelParser_CONSTRUCTOR_INIT
#define YY_RelParser_CONSTRUCTOR_INIT
#endif
/* choose between enum and const */
#ifndef YY_RelParser_USE_CONST_TOKEN
#define YY_RelParser_USE_CONST_TOKEN 0
/* yes enum is more compatible with flex,  */
/* so by default we use it */
#endif
#if YY_RelParser_USE_CONST_TOKEN != 0
#ifndef YY_RelParser_ENUM_TOKEN
#define YY_RelParser_ENUM_TOKEN yy_RelParser_enum_token
#endif
#endif

class YY_RelParser_CLASS YY_RelParser_INHERIT {
 public:
#if YY_RelParser_USE_CONST_TOKEN != 0
  /* static const int token ... */

#line 307 "../bison++/bison.cc"
  static const int IFACE_;
  static const int CLIENT_;
  static const int SERVER_;
  static const int UNICAST_;
  static const int MULTICAST_;
  static const int IFACE_ID_;
  static const int IFACE_ID_ORDER_;
  static const int LOGNAME_;
  static const int LOGLEVEL_;
  static const int LOGMODE_;
  static const int WORKDIR_;
  static const int DUID_;
  static const int OPTION_;
  static const int REMOTE_ID_;
  static const int ECHO_REQUEST_;
  static const int RELAY_ID_;
  static const int LINK_LAYER_;
  static const int GUESS_MODE_;
  static const int STRING_;
  static const int HEXNUMBER_;
  static const int INTNUMBER_;
  static const int IPV6ADDR_;

#line 307 "../bison++/bison.cc"
  /* decl const */
#else
  enum YY_RelParser_ENUM_TOKEN {
    YY_RelParser_NULL_TOKEN = 0

#line 310 "../bison++/bison.cc"
    ,
    IFACE_ = 258,
    CLIENT_ = 259,
    SERVER_ = 260,
    UNICAST_ = 261,
    MULTICAST_ = 262,
    IFACE_ID_ = 263,
    IFACE_ID_ORDER_ = 264,
    LOGNAME_ = 265,
    LOGLEVEL_ = 266,
    LOGMODE_ = 267,
    WORKDIR_ = 268,
    DUID_ = 269,
    OPTION_ = 270,
    REMOTE_ID_ = 271,
    ECHO_REQUEST_ = 272,
    RELAY_ID_ = 273,
    LINK_LAYER_ = 274,
    GUESS_MODE_ = 275,
    STRING_ = 276,
    HEXNUMBER_ = 277,
    INTNUMBER_ = 278,
    IPV6ADDR_ = 279

#line 310 "../bison++/bison.cc"
    /* enum token */
  }; /* end of enum declaration */
#endif
 public:
  int YY_RelParser_PARSE(YY_RelParser_PARSE_PARAM);
  virtual void YY_RelParser_ERROR(char *msg) YY_RelParser_ERROR_BODY;
#ifdef YY_RelParser_PURE
#ifdef YY_RelParser_LSP_NEEDED
  virtual int YY_RelParser_LEX(YY_RelParser_STYPE *YY_RelParser_LVAL,
                               YY_RelParser_LTYPE *YY_RelParser_LLOC) YY_RelParser_LEX_BODY;
#else
  virtual int YY_RelParser_LEX(YY_RelParser_STYPE *YY_RelParser_LVAL) YY_RelParser_LEX_BODY;
#endif
#else
  virtual int YY_RelParser_LEX() YY_RelParser_LEX_BODY;
  YY_RelParser_STYPE YY_RelParser_LVAL;
#ifdef YY_RelParser_LSP_NEEDED
  YY_RelParser_LTYPE YY_RelParser_LLOC;
#endif
  int YY_RelParser_NERRS;
  int YY_RelParser_CHAR;
#endif
#if YY_RelParser_DEBUG != 0
  int YY_RelParser_DEBUG_FLAG; /*  nonzero means print parse trace     */
#endif
 public:
  YY_RelParser_CLASS(YY_RelParser_CONSTRUCTOR_PARAM);

 public:
  YY_RelParser_MEMBERS
};
/* other declare folow */
#if YY_RelParser_USE_CONST_TOKEN != 0

#line 341 "../bison++/bison.cc"
const int YY_RelParser_CLASS::IFACE_ = 258;
const int YY_RelParser_CLASS::CLIENT_ = 259;
const int YY_RelParser_CLASS::SERVER_ = 260;
const int YY_RelParser_CLASS::UNICAST_ = 261;
const int YY_RelParser_CLASS::MULTICAST_ = 262;
const int YY_RelParser_CLASS::IFACE_ID_ = 263;
const int YY_RelParser_CLASS::IFACE_ID_ORDER_ = 264;
const int YY_RelParser_CLASS::LOGNAME_ = 265;
const int YY_RelParser_CLASS::LOGLEVEL_ = 266;
const int YY_RelParser_CLASS::LOGMODE_ = 267;
const int YY_RelParser_CLASS::WORKDIR_ = 268;
const int YY_RelParser_CLASS::DUID_ = 269;
const int YY_RelParser_CLASS::OPTION_ = 270;
const int YY_RelParser_CLASS::REMOTE_ID_ = 271;
const int YY_RelParser_CLASS::ECHO_REQUEST_ = 272;
const int YY_RelParser_CLASS::RELAY_ID_ = 273;
const int YY_RelParser_CLASS::LINK_LAYER_ = 274;
const int YY_RelParser_CLASS::GUESS_MODE_ = 275;
const int YY_RelParser_CLASS::STRING_ = 276;
const int YY_RelParser_CLASS::HEXNUMBER_ = 277;
const int YY_RelParser_CLASS::INTNUMBER_ = 278;
const int YY_RelParser_CLASS::IPV6ADDR_ = 279;

#line 341 "../bison++/bison.cc"
/* const YY_RelParser_CLASS::token */
#endif
/*apres const  */
YY_RelParser_CLASS::YY_RelParser_CLASS(YY_RelParser_CONSTRUCTOR_PARAM)
    YY_RelParser_CONSTRUCTOR_INIT {
#if YY_RelParser_DEBUG != 0
  YY_RelParser_DEBUG_FLAG = 0;
#endif
  YY_RelParser_CONSTRUCTOR_CODE;
}
#endif

#line 352 "../bison++/bison.cc"

#define YYFINAL 77
#define YYFLAG -32768
#define YYNTBASE 29

#define YYTRANSLATE(x) ((unsigned)(x) <= 279 ? yytranslate[x] : 57)

static const char yytranslate[] = {
    0, 2, 2, 2, 2, 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 2,  2, 2, 2, 2,
    2, 2, 2, 2, 2, 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  28, 27, 2, 2,  2, 2, 2, 2,
    2, 2, 2, 2, 2, 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 2,  2, 2, 2, 2,
    2, 2, 2, 2, 2, 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 2,  2, 2, 2, 2,
    2, 2, 2, 2, 2, 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  25, 2, 26, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 2,  2, 2, 2, 2,
    2, 2, 2, 2, 2, 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 2,  2, 2, 2, 2,
    2, 2, 2, 2, 2, 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 2,  2, 2, 2, 2,
    2, 2, 2, 2, 2, 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 2,  2, 2, 2, 2,
    2, 2, 2, 2, 2, 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 2,  1, 2, 3, 4,
    5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24};

#if YY_RelParser_DEBUG != 0
static const short yyprhs[] = {0,   0,   2,   5,   7,   10,  12,  14,  16,  18,  20, 22, 24,
                               26,  28,  30,  32,  35,  37,  40,  42,  44,  46,  48, 50, 51,
                               58,  59,  66,  68,  70,  74,  78,  82,  85,  89,  92, 95, 98,
                               101, 104, 106, 109, 115, 119, 122, 123, 128, 130, 134};

static const short yyrhs[] = {
    30, 0,  31, 33, 0,  32, 0,  31, 32, 0,  45, 0,  44, 0,  46, 0,  47, 0,  48, 0,  56, 0,  50,
    0,  51, 0,  52, 0,  53, 0,  36, 0,  33, 36, 0,  35, 0,  34, 35, 0,  41, 0,  40, 0,  43, 0,
    42, 0,  49, 0,  0,  3,  21, 25, 37, 34, 26, 0,  0,  3,  39, 25, 38, 34, 26, 0,  22, 0,  23,
    0,  5,  6,  24, 0,  4,  6,  24, 0,  5,  7,  39, 0,  5,  7,  0,  4,  7,  39, 0,  4,  7,  0,
    11, 39, 0,  12, 21, 0,  10, 21, 0,  13, 21, 0,  20, 0,  8,  39, 0,  15, 16, 39, 27, 14, 0,
    15, 18, 14, 0,  15, 19, 0,  0,  15, 17, 54, 55, 0,  39, 0,  55, 28, 39, 0,  9,  21, 0};

#endif

#if (YY_RelParser_DEBUG != 0) || defined(YY_RelParser_ERROR_VERBOSE)
static const short yyrline[] = {0,   86,  90,  94,  95,  99,  100, 101, 102, 103, 104, 105, 106,
                                107, 108, 112, 113, 117, 118, 122, 123, 124, 125, 126, 130, 135,
                                143, 148, 159, 160, 164, 171, 178, 182, 189, 193, 200, 206, 211,
                                218, 225, 231, 238, 245, 252, 259, 265, 270, 275, 282};

static const char *const yytname[] = {"$",
                                      "error",
                                      "$illegal.",
                                      "IFACE_",
                                      "CLIENT_",
                                      "SERVER_",
                                      "UNICAST_",
                                      "MULTICAST_",
                                      "IFACE_ID_",
                                      "IFACE_ID_ORDER_",
                                      "LOGNAME_",
                                      "LOGLEVEL_",
                                      "LOGMODE_",
                                      "WORKDIR_",
                                      "DUID_",
                                      "OPTION_",
                                      "REMOTE_ID_",
                                      "ECHO_REQUEST_",
                                      "RELAY_ID_",
                                      "LINK_LAYER_",
                                      "GUESS_MODE_",
                                      "STRING_",
                                      "HEXNUMBER_",
                                      "INTNUMBER_",
                                      "IPV6ADDR_",
                                      "'{'",
                                      "'}'",
                                      "'-'",
                                      "','",
                                      "Grammar",
                                      "GlobalList",
                                      "GlobalOptionsList",
                                      "GlobalOption",
                                      "IfaceList",
                                      "IfaceOptionList",
                                      "IfaceOptions",
                                      "Iface",
                                      "@1",
                                      "@2",
                                      "Number",
                                      "ServerUnicastOption",
                                      "ClientUnicastOption",
                                      "ServerMulticast",
                                      "ClientMulticastOption",
                                      "LogLevelOption",
                                      "LogModeOption",
                                      "LogNameOption",
                                      "WorkDirOption",
                                      "GuessMode",
                                      "IfaceID",
                                      "RemoteID",
                                      "RelayID",
                                      "LinkLayerOption",
                                      "EchoRequest",
                                      "@3",
                                      "OptionIdList",
                                      "IfaceIDOrder",
                                      ""};
#endif

static const short yyr1[] = {0,  29, 30, 31, 31, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 33, 33,
                             34, 34, 35, 35, 35, 35, 35, 37, 36, 38, 36, 39, 39, 40, 41, 42, 42,
                             43, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 54, 53, 55, 55, 56};

static const short yyr2[] = {0, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2,
                             1, 2, 1, 1, 1, 1, 1, 0, 6, 0, 6, 1, 1, 3, 3, 3, 2,
                             3, 2, 2, 2, 2, 2, 1, 2, 5, 3, 2, 0, 4, 1, 3, 2};

static const short yydefact[] = {0,  0,  0,  0,  0,  0,  0,  40, 1,  0,  3,  6,  5,  7,  8,  9,
                                 11, 12, 13, 14, 10, 49, 38, 28, 29, 36, 37, 39, 0,  45, 0,  44,
                                 0,  4,  2,  15, 0,  0,  43, 0,  0,  16, 0,  47, 46, 24, 26, 42,
                                 0,  0,  0,  48, 0,  0,  0,  0,  17, 20, 19, 22, 21, 23, 0,  0,
                                 35, 0,  33, 41, 25, 18, 27, 31, 34, 30, 32, 0,  0,  0};

static const short yydefgoto[] = {75, 8,  9,  10, 34, 55, 56, 35, 49, 50, 25, 57, 58, 59,
                                  60, 11, 12, 13, 14, 15, 61, 16, 17, 18, 19, 37, 44, 20};

static const short yypact[] = {
    4,      -18,    -13,    -1,     -9,     6,      28,     -32768, -32768, 22,     -32768, -32768,
    -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
    -32768, -32768, -32768, -32768, -1,     -32768, 39,     -32768, 27,     -32768, 38,     -32768,
    29,     -1,     -32768, 30,     32,     -32768, 40,     -32768, 31,     -32768, -32768, -32768,
    -1,     35,     35,     -32768, 23,     45,     -1,     -3,     -32768, -32768, -32768, -32768,
    -32768, -32768, 2,      34,     -1,     36,     -1,     -32768, -32768, -32768, -32768, -32768,
    -32768, -32768, -32768, 61,     62,     -32768};

static const short yypgoto[] = {-32768, -32768, -32768, 54,     -32768, 14,     -44,
                                33,     -32768, -32768, -28,    -32768, -32768, -32768,
                                -32768, -32768, -32768, -32768, -32768, -32768, -32768,
                                -32768, -32768, -32768, -32768, -32768, -32768, -32768};

#define YYLAST 67

static const short yytable[] = {36, 52, 53, 21, 40, 54, 52, 53, 22, 43, 54, 69, 26, 1,  2,  3,  4,
                                5,  69, 6,  51, 23, 24, 68, 7,  32, 67, 27, 70, 63, 64, 1,  2,  3,
                                4,  5,  72, 6,  74, 52, 53, 32, 7,  54, 28, 29, 30, 31, 39, 23, 24,
                                65, 66, 38, 47, 45, 42, 46, 71, 48, 73, 76, 77, 33, 62, 0,  0,  41};

static const short yycheck[] = {28, 4,  5,  21, 32, 8,  4,  5,  21, 37, 8,  55, 21, 9,  10, 11, 12,
                                13, 62, 15, 48, 22, 23, 26, 20, 3,  54, 21, 26, 6,  7,  9,  10, 11,
                                12, 13, 64, 15, 66, 4,  5,  3,  20, 8,  16, 17, 18, 19, 21, 22, 23,
                                6,  7,  14, 14, 25, 27, 25, 24, 28, 24, 0,  0,  9,  50, -1, -1, 34};

#line 352 "../bison++/bison.cc"
/* fattrs + tables */

/* parser code folow  */

/* This is the parser code that is written into each bison parser
  when the %semantic_parser declaration is not specified in the grammar.
  It was written by Richard Stallman by simplifying the hairy parser
  used when %semantic_parser is specified.  */

/* Note: dollar marks section change
   the next  is replaced by the list of actions, each action
   as one case of the switch.  */

#if YY_RelParser_USE_GOTO != 0
/*
 SUPRESSION OF GOTO : on some C++ compiler (sun c++)
  the goto is strictly forbidden if any constructor/destructor
  is used in the whole function (very stupid isn't it ?)
 so goto are to be replaced with a 'while/switch/case construct'
 here are the macro to keep some apparent compatibility
*/
#define YYGOTO(lb)     \
  {                    \
    yy_gotostate = lb; \
    continue;          \
  }
#define YYBEGINGOTO                          \
  enum yy_labels yy_gotostate = yygotostart; \
  for (;;) switch (yy_gotostate) {           \
      case yygotostart: {
#define YYLABEL(lb) \
  }                 \
  case lb: {
#define YYENDGOTO \
  }               \
  }
#define YYBEGINDECLARELABEL enum yy_labels { yygotostart
#define YYDECLARELABEL(lb) , lb
#define YYENDDECLARELABEL }
#else
/* macro to keep goto */
#define YYGOTO(lb) goto lb
#define YYBEGINGOTO
#define YYLABEL(lb) \
  lb:
#define YYENDGOTO
#define YYBEGINDECLARELABEL
#define YYDECLARELABEL(lb)
#define YYENDDECLARELABEL
#endif
/* LABEL DECLARATION */
YYBEGINDECLARELABEL
YYDECLARELABEL(yynewstate)
YYDECLARELABEL(yybackup)
/* YYDECLARELABEL(yyresume) */
YYDECLARELABEL(yydefault)
YYDECLARELABEL(yyreduce)
YYDECLARELABEL(yyerrlab)     /* here on detecting error */
YYDECLARELABEL(yyerrlab1)    /* here on error raised explicitly by an action */
YYDECLARELABEL(yyerrdefault) /* current state does not do anything special for
                                the error token. */
YYDECLARELABEL(yyerrpop)     /* pop the current state because it cannot handle the
                                error token */
YYDECLARELABEL(yyerrhandle)
YYENDDECLARELABEL
/* ALLOCA SIMULATION */
/* __HAVE_NO_ALLOCA */
#ifdef __HAVE_NO_ALLOCA
int __alloca_free_ptr(char *ptr, char *ref) {
  if (ptr != ref) free(ptr);
  return 0;
}

#define __ALLOCA_alloca(size) malloc(size)
#define __ALLOCA_free(ptr, ref) __alloca_free_ptr((char *)ptr, (char *)ref)

#ifdef YY_RelParser_LSP_NEEDED
#define __ALLOCA_return(num)                                                                       \
  do {                                                                                             \
    return (__ALLOCA_free(yyss, yyssa) + __ALLOCA_free(yyvs, yyvsa) + __ALLOCA_free(yyls, yylsa) + \
            (num));                                                                                \
  } while (0)
#else
#define __ALLOCA_return(num)                                                  \
  do {                                                                        \
    return (__ALLOCA_free(yyss, yyssa) + __ALLOCA_free(yyvs, yyvsa) + (num)); \
  } while (0)
#endif
#else
#define __ALLOCA_return(num) \
  do {                       \
    return (num);            \
  } while (0)
#define __ALLOCA_alloca(size) alloca(size)
#define __ALLOCA_free(ptr, ref)
#endif

/* ENDALLOCA SIMULATION */

#define yyerrok (yyerrstatus = 0)
#define yyclearin (YY_RelParser_CHAR = YYEMPTY)
#define YYEMPTY -2
#define YYEOF 0
#define YYACCEPT __ALLOCA_return(0)
#define YYABORT __ALLOCA_return(1)
#define YYERROR YYGOTO(yyerrlab1)
/* Like YYERROR except do call yyerror.
   This remains here temporarily to ease the
   transition to the new meaning of YYERROR, for GCC.
   Once GCC version 2 has supplanted version 1, this can go.  */
#define YYFAIL YYGOTO(yyerrlab)
#define YYRECOVERING() (!!yyerrstatus)
#define YYBACKUP(token, value)                                  \
  do                                                            \
    if (YY_RelParser_CHAR == YYEMPTY && yylen == 1) {           \
      YY_RelParser_CHAR = (token), YY_RelParser_LVAL = (value); \
      yychar1 = YYTRANSLATE(YY_RelParser_CHAR);                 \
      YYPOPSTACK;                                               \
      YYGOTO(yybackup);                                         \
    } else {                                                    \
      YY_RelParser_ERROR("syntax error: cannot back up");       \
      YYERROR;                                                  \
    }                                                           \
  while (0)

#define YYTERROR 1
#define YYERRCODE 256

#ifndef YY_RelParser_PURE
/* UNPURE */
#define YYLEX YY_RelParser_LEX()
#ifndef YY_USE_CLASS
/* If nonreentrant, and not class , generate the variables here */
int YY_RelParser_CHAR;                /*  the lookahead symbol        */
YY_RelParser_STYPE YY_RelParser_LVAL; /*  the semantic value of the */
                                      /*  lookahead symbol    */
int YY_RelParser_NERRS;               /*  number of parse errors so far */
#ifdef YY_RelParser_LSP_NEEDED
YY_RelParser_LTYPE YY_RelParser_LLOC; /*  location data for the lookahead     */
                                      /*  symbol                              */
#endif
#endif

#else
/* PURE */
#ifdef YY_RelParser_LSP_NEEDED
#define YYLEX YY_RelParser_LEX(&YY_RelParser_LVAL, &YY_RelParser_LLOC)
#else
#define YYLEX YY_RelParser_LEX(&YY_RelParser_LVAL)
#endif
#endif
#ifndef YY_USE_CLASS
#if YY_RelParser_DEBUG != 0
int YY_RelParser_DEBUG_FLAG; /*  nonzero means print parse trace     */
/* Since this is uninitialized, it does not stop multiple parsers
   from coexisting.  */
#endif
#endif

/*  YYINITDEPTH indicates the initial size of the parser's stacks       */

#ifndef YYINITDEPTH
#define YYINITDEPTH 200
#endif

/*  YYMAXDEPTH is the maximum size the stacks can grow to
    (effective only if the built-in stack extension method is used).  */

#if YYMAXDEPTH == 0
#undef YYMAXDEPTH
#endif

#ifndef YYMAXDEPTH
#define YYMAXDEPTH 10000
#endif

#if __GNUC__ > 1 /* GNU C and GNU C++ define this.  */
#define __yy_bcopy(FROM, TO, COUNT) __builtin_memcpy(TO, FROM, COUNT)
#else /* not GNU C or C++ */

/* This is the most reliable way to avoid incompatibilities
   in available built-in functions on various systems.  */

#ifdef __cplusplus
static void __yy_bcopy(char *from, char *to, int count)
#else
#ifdef __STDC__
static void __yy_bcopy(char *from, char *to, int count)
#else
static void __yy_bcopy(from, to, count) char *from;
char *to;
int count;
#endif
#endif
{
  register char *f = from;
  register char *t = to;
  register int i = count;

  while (i-- > 0) *t++ = *f++;
}
#endif

int
#ifdef YY_USE_CLASS
 YY_RelParser_CLASS::
#endif
     YY_RelParser_PARSE(YY_RelParser_PARSE_PARAM)
#ifndef __STDC__
#ifndef __cplusplus
#ifndef YY_USE_CLASS
/* parameter definition without protypes */
YY_RelParser_PARSE_PARAM_DEF
#endif
#endif
#endif
{
  register int yystate;
  register int yyn;
  register short *yyssp;
  register YY_RelParser_STYPE *yyvsp;
  int yyerrstatus; /*  number of tokens to shift before error messages enabled
                    */
  int yychar1 = 0; /*  lookahead token as an internal (translated) token number */

  short yyssa[YYINITDEPTH];              /*  the state stack                     */
  YY_RelParser_STYPE yyvsa[YYINITDEPTH]; /*  the semantic value stack */

  short *yyss = yyssa;              /*  refer to the stacks thru separate pointers */
  YY_RelParser_STYPE *yyvs = yyvsa; /*  to allow yyoverflow to reallocate them elsewhere */

#ifdef YY_RelParser_LSP_NEEDED
  YY_RelParser_LTYPE yylsa[YYINITDEPTH]; /*  the location stack */
  YY_RelParser_LTYPE *yyls = yylsa;
  YY_RelParser_LTYPE *yylsp;

#define YYPOPSTACK (yyvsp--, yyssp--, yylsp--)
#else
#define YYPOPSTACK (yyvsp--, yyssp--)
#endif

  int yystacksize = YYINITDEPTH;

#ifdef YY_RelParser_PURE
  int YY_RelParser_CHAR;
  YY_RelParser_STYPE YY_RelParser_LVAL;
  int YY_RelParser_NERRS;
#ifdef YY_RelParser_LSP_NEEDED
  YY_RelParser_LTYPE YY_RelParser_LLOC;
#endif
#endif

  YY_RelParser_STYPE yyval; /*  the variable used to return         */
  /*  semantic values from the action     */
  /*  routines                            */

  int yylen;
  /* start loop, in which YYGOTO may be used. */
  YYBEGINGOTO

#if YY_RelParser_DEBUG != 0
  if (YY_RelParser_DEBUG_FLAG) fprintf(stderr, "Starting parse\n");
#endif
  yystate = 0;
  yyerrstatus = 0;
  YY_RelParser_NERRS = 0;
  YY_RelParser_CHAR = YYEMPTY; /* Cause a token to be read.  */

  /* Initialize stack pointers.
     Waste one element of value and location stack
     so that they stay on the same level as the state stack.
     The wasted elements are never initialized.  */

  yyssp = yyss - 1;
  yyvsp = yyvs;
#ifdef YY_RelParser_LSP_NEEDED
  yylsp = yyls;
#endif

  /* Push a new state, which is found in  yystate  .  */
  /* In all cases, when you get here, the value and location stacks
     have just been pushed. so pushing a state here evens the stacks.  */
  YYLABEL(yynewstate)

  *++yyssp = yystate;

  if (yyssp >= yyss + yystacksize - 1) {
    /* Give user a chance to reallocate the stack */
    /* Use copies of these so that the &'s don't force the real ones into
     * memory. */
    YY_RelParser_STYPE *yyvs1 = yyvs;
    short *yyss1 = yyss;
#ifdef YY_RelParser_LSP_NEEDED
    YY_RelParser_LTYPE *yyls1 = yyls;
#endif

    /* Get the current used size of the three stacks, in elements.  */
    int size = yyssp - yyss + 1;

#ifdef yyoverflow
    /* Each stack pointer address is followed by the size of
       the data in use in that stack, in bytes.  */
#ifdef YY_RelParser_LSP_NEEDED
    /* This used to be a conditional around just the two extra args,
       but that might be undefined if yyoverflow is a macro.  */
    yyoverflow("parser stack overflow", &yyss1, size * sizeof(*yyssp), &yyvs1,
               size * sizeof(*yyvsp), &yyls1, size * sizeof(*yylsp), &yystacksize);
#else
    // cppcheck-suppress constStatement
    yyoverflow("parser stack overflow", &yyss1, size * sizeof(*yyssp), &yyvs1,
               size * sizeof(*yyvsp), &yystacksize);
#endif

    yyss = yyss1;
    yyvs = yyvs1;
#ifdef YY_RelParser_LSP_NEEDED
    yyls = yyls1;
#endif
#else /* no yyoverflow */
    /* Extend the stack our own way.  */
    if (yystacksize >= YYMAXDEPTH) {
      YY_RelParser_ERROR(((char *)"parser stack overflow"));
      __ALLOCA_return(2);
    }
    yystacksize *= 2;
    if (yystacksize > YYMAXDEPTH) yystacksize = YYMAXDEPTH;
    yyss = (short *)__ALLOCA_alloca(yystacksize * sizeof(*yyssp));
    __yy_bcopy((char *)yyss1, (char *)yyss, size * sizeof(*yyssp));
    __ALLOCA_free(yyss1, yyssa);
    yyvs = (YY_RelParser_STYPE *)__ALLOCA_alloca(yystacksize * sizeof(*yyvsp));
    __yy_bcopy((char *)yyvs1, (char *)yyvs, size * sizeof(*yyvsp));
    __ALLOCA_free(yyvs1, yyvsa);
#ifdef YY_RelParser_LSP_NEEDED
    yyls = (YY_RelParser_LTYPE *)__ALLOCA_alloca(yystacksize * sizeof(*yylsp));
    __yy_bcopy((char *)yyls1, (char *)yyls, size * sizeof(*yylsp));
    __ALLOCA_free(yyls1, yylsa);
#endif
#endif /* no yyoverflow */

    yyssp = yyss + size - 1;
    yyvsp = yyvs + size - 1;
#ifdef YY_RelParser_LSP_NEEDED
    yylsp = yyls + size - 1;
#endif

#if YY_RelParser_DEBUG != 0
    if (YY_RelParser_DEBUG_FLAG) fprintf(stderr, "Stack size increased to %d\n", yystacksize);
#endif

    if (yyssp >= yyss + yystacksize - 1) YYABORT;
  }

#if YY_RelParser_DEBUG != 0
  if (YY_RelParser_DEBUG_FLAG) fprintf(stderr, "Entering state %d\n", yystate);
#endif

  YYGOTO(yybackup);
  YYLABEL(yybackup)

  /* Do appropriate processing given the current state.  */
  /* Read a lookahead token if we need one and don't already have one.  */
  /* YYLABEL(yyresume) */

  /* First try to decide what to do without reference to lookahead token.  */

  yyn = yypact[yystate];
  if (yyn == YYFLAG) YYGOTO(yydefault);

  /* Not known => get a lookahead token if don't already have one.  */

  /* yychar is either YYEMPTY or YYEOF
     or a valid token in external form.  */

  if (YY_RelParser_CHAR == YYEMPTY) {
#if YY_RelParser_DEBUG != 0
    if (YY_RelParser_DEBUG_FLAG) fprintf(stderr, "Reading a token: ");
#endif
    YY_RelParser_CHAR = YYLEX;
  }

  /* Convert token to internal form (in yychar1) for indexing tables with */

  if (YY_RelParser_CHAR <= 0) /* This means end of input. */
  {
    yychar1 = 0;
    YY_RelParser_CHAR = YYEOF; /* Don't call YYLEX any more */

#if YY_RelParser_DEBUG != 0
    if (YY_RelParser_DEBUG_FLAG) fprintf(stderr, "Now at end of input.\n");
#endif
  } else {
    yychar1 = YYTRANSLATE(YY_RelParser_CHAR);

#if YY_RelParser_DEBUG != 0
    if (YY_RelParser_DEBUG_FLAG) {
      fprintf(stderr, "Next token is %d (%s", YY_RelParser_CHAR, yytname[yychar1]);
      /* Give the individual parser a way to print the precise meaning
         of a token, for further debugging info.  */
#ifdef YYPRINT
      YYPRINT(stderr, YY_RelParser_CHAR, YY_RelParser_LVAL);
#endif
      fprintf(stderr, ")\n");
    }
#endif
  }

  yyn += yychar1;
  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != yychar1) YYGOTO(yydefault);

  yyn = yytable[yyn];

  /* yyn is what to do for this token type in this state.
     Negative => reduce, -yyn is rule number.
     Positive => shift, yyn is new state.
       New state is final state => don't bother to shift,
       just return success.
     0, or most negative number => error.  */

  if (yyn < 0) {
    if (yyn == YYFLAG) YYGOTO(yyerrlab);
    yyn = -yyn;
    YYGOTO(yyreduce);
  } else if (yyn == 0)
    YYGOTO(yyerrlab);

  if (yyn == YYFINAL) YYACCEPT;

    /* Shift the lookahead token.  */

#if YY_RelParser_DEBUG != 0
  if (YY_RelParser_DEBUG_FLAG)
    fprintf(stderr, "Shifting token %d (%s), ", YY_RelParser_CHAR, yytname[yychar1]);
#endif

  /* Discard the token being shifted unless it is eof.  */
  if (YY_RelParser_CHAR != YYEOF) YY_RelParser_CHAR = YYEMPTY;

  *++yyvsp = YY_RelParser_LVAL;
#ifdef YY_RelParser_LSP_NEEDED
  *++yylsp = YY_RelParser_LLOC;
#endif

  /* count tokens shifted since error; after three, turn off error status.  */
  if (yyerrstatus) yyerrstatus--;

  yystate = yyn;
  YYGOTO(yynewstate);

  /* Do the default action for the current state.  */
  YYLABEL(yydefault)

  yyn = yydefact[yystate];
  if (yyn == 0) YYGOTO(yyerrlab);

  /* Do a reduction.  yyn is the number of a rule to reduce with.  */
  YYLABEL(yyreduce)
  yylen = yyr2[yyn];
  if (yylen > 0) yyval = yyvsp[1 - yylen]; /* implement default value of the action */

#if YY_RelParser_DEBUG != 0
  if (YY_RelParser_DEBUG_FLAG) {
    int i;

    fprintf(stderr, "Reducing via rule %d (line %d), ", yyn, yyrline[yyn]);

    /* Print the symbols being reduced, and their result.  */
    for (i = yyprhs[yyn]; yyrhs[i] > 0; i++) fprintf(stderr, "%s ", yytname[yyrhs[i]]);
    fprintf(stderr, " -> %s\n", yytname[yyr1[yyn]]);
  }
#endif

#line 840 "../bison++/bison.cc"

  switch (yyn) {

    case 24:
#line 131 "RelParser.y"
    {
      CheckIsIface(string(yyvsp[-1].strval));  // If no - everything is ok
      StartIfaceDeclaration();
      ;
      break;
    }
    case 25:
#line 136 "RelParser.y"
    {
      // Information about new interface has been read
      // Add it to list of read interfaces
      RelCfgIfaceLst.append(new TRelCfgIface(yyvsp[-4].strval));
      delete[] yyvsp[-4].strval;
      EndIfaceDeclaration();
      ;
      break;
    }
    case 26:
#line 144 "RelParser.y"
    {
      CheckIsIface(yyvsp[-1].ival);  // If no - everything is ok
      StartIfaceDeclaration();
      ;
      break;
    }
    case 27:
#line 149 "RelParser.y"
    {
      RelCfgIfaceLst.append(new TRelCfgIface(yyvsp[-4].ival));
      EndIfaceDeclaration();
      ;
      break;
    }
    case 28:
#line 159 "RelParser.y"
    {
      yyval.ival = yyvsp[0].ival;
      ;
      break;
    }
    case 29:
#line 160 "RelParser.y"
    {
      yyval.ival = yyvsp[0].ival;
      ;
      break;
    }
    case 30:
#line 165 "RelParser.y"
    {
      ParserOptStack.getLast()->setServerUnicast(new TIPv6Addr(yyvsp[0].addrval));
      ;
      break;
    }
    case 31:
#line 172 "RelParser.y"
    {
      ParserOptStack.getLast()->setClientUnicast(new TIPv6Addr(yyvsp[0].addrval));
      ;
      break;
    }
    case 32:
#line 179 "RelParser.y"
    {
      ParserOptStack.getLast()->setServerMulticast(yyvsp[0].ival);
      ;
      break;
    }
    case 33:
#line 183 "RelParser.y"
    {
      ParserOptStack.getLast()->setServerMulticast(true);
      ;
      break;
    }
    case 34:
#line 190 "RelParser.y"
    {
      ParserOptStack.getLast()->setClientMulticast(yyvsp[0].ival);
      ;
      break;
    }
    case 35:
#line 194 "RelParser.y"
    {
      ParserOptStack.getLast()->setClientMulticast(true);
      ;
      break;
    }
    case 36:
#line 200 "RelParser.y"
    {
      logger::setLogLevel(yyvsp[0].ival);
      ;
      break;
    }
    case 37:
#line 206 "RelParser.y"
    {
      logger::setLogMode(yyvsp[0].strval);
      ;
      break;
    }
    case 38:
#line 212 "RelParser.y"
    {
      logger::setLogName(yyvsp[0].strval);
      ;
      break;
    }
    case 39:
#line 219 "RelParser.y"
    {
      ParserOptStack.getLast()->setWorkDir(yyvsp[0].strval);
      ;
      break;
    }
    case 40:
#line 226 "RelParser.y"
    {
      ParserOptStack.getLast()->setGuessMode(true);
      ;
      break;
    }
    case 41:
#line 232 "RelParser.y"
    {
      ParserOptStack.getLast()->setInterfaceID(yyvsp[0].ival);
      ;
      break;
    }
    case 42:
#line 239 "RelParser.y"
    {
      Log(Debug) << "RemoteID set: enterprise-number=" << yyvsp[-2].ival
                 << ", remote-id length=" << yyvsp[0].duidval.length << LogEnd;
      ParserOptStack.getLast()->setRemoteID(new TOptVendorData(
          OPTION_REMOTE_ID, yyvsp[-2].ival, yyvsp[0].duidval.duid, yyvsp[0].duidval.length, 0));
      ;
      break;
    }
    case 43:
#line 246 "RelParser.y"
    {
      Log(Debug) << "Relay-id set: length=" << yyvsp[0].duidval.length << LogEnd;
      CfgMgr->setRelayID(
          new TOptDUID(OPTION_RELAY_ID, yyvsp[0].duidval.duid, yyvsp[0].duidval.length, NULL));
      ;
      break;
    }
    case 44:
#line 253 "RelParser.y"
    {
      Log(Debug) << "Client link-local address option (RFC6939) enabled." << LogEnd;
      CfgMgr->setClientLinkLayerAddress(true);
      ;
      break;
    }
    case 45:
#line 260 "RelParser.y"
    {
      EchoOpt = new TRelOptEcho(0);
      ParserOptStack.getLast()->setEcho(EchoOpt);
      Log(Debug) << "Echo Request option will be added with opt(s): ";
      ;
      break;
    }
    case 46:
#line 265 "RelParser.y"
    {
      Log(Cont) << ", " << EchoOpt->count() << " opt(s) total." << LogEnd;
      ;
      break;
    }
    case 47:
#line 271 "RelParser.y"
    {
      EchoOpt->addOption(yyvsp[0].ival);
      Log(Cont) << " " << yyvsp[0].ival;
      ;
      break;
    }
    case 48:
#line 276 "RelParser.y"
    {
      EchoOpt->addOption(yyvsp[0].ival);
      Log(Cont) << " " << yyvsp[0].ival;
      ;
      break;
    }
    case 49:
#line 283 "RelParser.y"
    {
      if (!strncasecmp(yyvsp[0].strval, "before", 6)) {
        ParserOptStack.getLast()->setInterfaceIDOrder(REL_IFACE_ID_ORDER_BEFORE);
      } else if (!strncasecmp(yyvsp[0].strval, "after", 5)) {
        ParserOptStack.getLast()->setInterfaceIDOrder(REL_IFACE_ID_ORDER_AFTER);
      } else if (!strncasecmp(yyvsp[0].strval, "omit", 4)) {
        ParserOptStack.getLast()->setInterfaceIDOrder(REL_IFACE_ID_ORDER_NONE);
      } else {
        Log(Crit) << "Invalid interface-id-order specified. Allowed values: "
                     "before, after, none"
                  << LogEnd;
        YYABORT;
      };
      break;
    }
  }

#line 840 "../bison++/bison.cc"
  /* the action file gets copied in in place of this dollarsign  */
  yyvsp -= yylen;
  yyssp -= yylen;
#ifdef YY_RelParser_LSP_NEEDED
  yylsp -= yylen;
#endif

#if YY_RelParser_DEBUG != 0
  if (YY_RelParser_DEBUG_FLAG) {
    short *ssp1 = yyss - 1;
    fprintf(stderr, "state stack now");
    while (ssp1 != yyssp) fprintf(stderr, " %d", *++ssp1);
    fprintf(stderr, "\n");
  }
#endif

  *++yyvsp = yyval;

#ifdef YY_RelParser_LSP_NEEDED
  yylsp++;
  if (yylen == 0) {
    yylsp->first_line = YY_RelParser_LLOC.first_line;
    yylsp->first_column = YY_RelParser_LLOC.first_column;
    yylsp->last_line = (yylsp - 1)->last_line;
    yylsp->last_column = (yylsp - 1)->last_column;
    yylsp->text = 0;
  } else {
    yylsp->last_line = (yylsp + yylen - 1)->last_line;
    yylsp->last_column = (yylsp + yylen - 1)->last_column;
  }
#endif

  /* Now "shift" the result of the reduction.
     Determine what state that goes to,
     based on the state we popped back to
     and the rule number reduced by.  */

  yyn = yyr1[yyn];

  yystate = yypgoto[yyn - YYNTBASE] + *yyssp;
  if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *yyssp)
    yystate = yytable[yystate];
  else
    yystate = yydefgoto[yyn - YYNTBASE];

  YYGOTO(yynewstate);

  YYLABEL(yyerrlab) /* here on detecting error */

  if (!yyerrstatus)
  /* If not already recovering from an error, report this error.  */
  {
    ++YY_RelParser_NERRS;

#ifdef YY_RelParser_ERROR_VERBOSE
    yyn = yypact[yystate];

    if (yyn > YYFLAG && yyn < YYLAST) {
      int size = 0;
      char *msg;
      int x, count;

      count = 0;
      /* Start X at -yyn if nec to avoid negative indexes in yycheck.  */
      for (x = (yyn < 0 ? -yyn : 0); x < (sizeof(yytname) / sizeof(char *)); x++)
        if (yycheck[x + yyn] == x) size += strlen(yytname[x]) + 15, count++;
      msg = (char *)malloc(size + 15);
      if (msg != 0) {
        strcpy(msg, "parse error");

        if (count < 5) {
          count = 0;
          for (x = (yyn < 0 ? -yyn : 0); x < (sizeof(yytname) / sizeof(char *)); x++)
            if (yycheck[x + yyn] == x) {
              strcat(msg, count == 0 ? ", expecting `" : " or `");
              strcat(msg, yytname[x]);
              strcat(msg, "'");
              count++;
            }
        }
        YY_RelParser_ERROR(msg);
        free(msg);
      } else
        YY_RelParser_ERROR("parse error; also virtual memory exceeded");
    } else
#endif /* YY_RelParser_ERROR_VERBOSE */
      YY_RelParser_ERROR((char *)"parse error");
  }

  YYGOTO(yyerrlab1);
  YYLABEL(yyerrlab1) /* here on error raised explicitly by an action */

  if (yyerrstatus == 3) {
    /* if just tried and failed to reuse lookahead token after an error, discard
     * it.  */

    /* return failure if at end of input */
    if (YY_RelParser_CHAR == YYEOF) YYABORT;

#if YY_RelParser_DEBUG != 0
    if (YY_RelParser_DEBUG_FLAG)
      fprintf(stderr, "Discarding token %d (%s).\n", YY_RelParser_CHAR, yytname[yychar1]);
#endif

    YY_RelParser_CHAR = YYEMPTY;
  }

  /* Else will try to reuse lookahead token
     after shifting the error token.  */

  yyerrstatus = 3; /* Each real token shifted decrements this */

  YYGOTO(yyerrhandle);

  YYLABEL(yyerrdefault) /* current state does not do anything special for the
                           error token. */

#if 0
  /* This is wrong; only states that explicitly want error tokens
     should shift them.  */
  yyn = yydefact[yystate];  /* If its default is to accept any token, ok.  Otherwise pop it.*/
  if (yyn) YYGOTO(yydefault);
#endif

  YYLABEL(yyerrpop) /* pop the current state because it cannot handle the error
                       token */

  if (yyssp == yyss) YYABORT;
  yyvsp--;
  yystate = *--yyssp;
#ifdef YY_RelParser_LSP_NEEDED
  yylsp--;
#endif

#if YY_RelParser_DEBUG != 0
  if (YY_RelParser_DEBUG_FLAG) {
    short *ssp1 = yyss - 1;
    fprintf(stderr, "Error: state stack now");
    while (ssp1 != yyssp) fprintf(stderr, " %d", *++ssp1);
    fprintf(stderr, "\n");
  }
#endif

  YYLABEL(yyerrhandle)

  yyn = yypact[yystate];
  if (yyn == YYFLAG) YYGOTO(yyerrdefault);

  yyn += YYTERROR;
  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != YYTERROR) YYGOTO(yyerrdefault);

  yyn = yytable[yyn];
  if (yyn < 0) {
    if (yyn == YYFLAG) YYGOTO(yyerrpop);
    yyn = -yyn;
    YYGOTO(yyreduce);
  } else if (yyn == 0)
    YYGOTO(yyerrpop);

  if (yyn == YYFINAL) YYACCEPT;

#if YY_RelParser_DEBUG != 0
  if (YY_RelParser_DEBUG_FLAG) fprintf(stderr, "Shifting error token, ");
#endif

  *++yyvsp = YY_RelParser_LVAL;
#ifdef YY_RelParser_LSP_NEEDED
  *++yylsp = YY_RelParser_LLOC;
#endif

  yystate = yyn;
  YYGOTO(yynewstate);
  /* end loop, in which YYGOTO may be used. */
  YYENDGOTO
}

/* END */

#line 1039 "../bison++/bison.cc"
#line 303 "RelParser.y"

/////////////////////////////////////////////////////////////////////////////
// programs section

// method check whether interface with id=ifaceNr has been
// already declared
bool RelParser::CheckIsIface(int ifaceNr) {
  SPtr<TRelCfgIface> ptr;
  RelCfgIfaceLst.first();
  while (ptr = RelCfgIfaceLst.get()) {
    if ((ptr->getID()) == ifaceNr) {
      Log(Crit) << "Interface with ID=" << ifaceNr << " is already defined." << LogEnd;
      YYABORT;
    }
  }
  return true;
}

// method check whether interface with id=ifaceName has been
// already declared
bool RelParser::CheckIsIface(string ifaceName) {
  SPtr<TRelCfgIface> ptr;
  RelCfgIfaceLst.first();
  while (ptr = RelCfgIfaceLst.get()) {
    string presName = ptr->getName();
    if (presName == ifaceName) {
      Log(Crit) << "Interface " << ifaceName << " is already defined." << LogEnd;
      YYABORT;
    }
  }
  return true;
}

// method creates new scope appropriately for interface options and declarations
// clears all lists except the list of interfaces and adds new group
void RelParser::StartIfaceDeclaration() {
  // Interface scope, so parameters associated with global scope are pushed on
  // stack
  ParserOptStack.append(new TRelParsGlobalOpt(*ParserOptStack.getLast()));
}

bool RelParser::EndIfaceDeclaration() {
  // setting interface options on the basis of just read information
  RelCfgIfaceLst.getLast()->setOptions(ParserOptStack.getLast());
  ParserOptStack.delLast();
  return true;
}

namespace std {
extern yy_RelParser_stype yylval;
}

int RelParser::yylex() {
  memset(&std::yylval, 0, sizeof(std::yylval));
  memset(&this->yylval, 0, sizeof(this->yylval));
  int x = this->lex->yylex();
  this->yylval = std::yylval;
  return x;
}

void RelParser::yyerror(char *m) {
  Log(Crit) << "Config parse error: line " << lex->lineno() << ", unexpected [" << lex->YYText()
            << "] token." << LogEnd;
}

RelParser::~RelParser() {}
