#line 2 "RelLexer.cpp"

#line 4 "RelLexer.cpp"

#define YY_INT_ALIGNED short int

/* A lexical scanner generated by flex */

#define FLEX_SCANNER
#define YY_FLEX_MAJOR_VERSION 2
#define YY_FLEX_MINOR_VERSION 5
#define YY_FLEX_SUBMINOR_VERSION 39
#if YY_FLEX_SUBMINOR_VERSION > 0
#define FLEX_BETA
#endif

/* The c++ scanner is a mess. The FlexLexer.h header file relies on the
 * following macro. This is required in order to pass the c++-multiple-scanners
 * test in the regression suite. We get reports that it breaks inheritance.
 * We will address this in a future release of flex, or omit the C++ scanner
 * altogether.
 */
#define yyFlexLexer yyFlexLexer

/* First, we deal with  platform-specific or compiler-specific issues. */

/* begin standard C headers. */

/* end standard C headers. */

/* flex integer type definitions */

#ifndef FLEXINT_H
#define FLEXINT_H

/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */

#if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L

/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
 * if you want the limit (max/min) macros for int types.
 */
#ifndef __STDC_LIMIT_MACROS
#define __STDC_LIMIT_MACROS 1
#endif

#include <inttypes.h>
typedef int8_t flex_int8_t;
typedef uint8_t flex_uint8_t;
typedef int16_t flex_int16_t;
typedef uint16_t flex_uint16_t;
typedef int32_t flex_int32_t;
typedef uint32_t flex_uint32_t;
#else
typedef signed char flex_int8_t;
typedef short int flex_int16_t;
typedef int flex_int32_t;
typedef unsigned char flex_uint8_t;
typedef unsigned short int flex_uint16_t;
typedef unsigned int flex_uint32_t;

/* Limits of integral types. */
#ifndef INT8_MIN
#define INT8_MIN (-128)
#endif
#ifndef INT16_MIN
#define INT16_MIN (-32767 - 1)
#endif
#ifndef INT32_MIN
#define INT32_MIN (-2147483647 - 1)
#endif
#ifndef INT8_MAX
#define INT8_MAX (127)
#endif
#ifndef INT16_MAX
#define INT16_MAX (32767)
#endif
#ifndef INT32_MAX
#define INT32_MAX (2147483647)
#endif
#ifndef UINT8_MAX
#define UINT8_MAX (255U)
#endif
#ifndef UINT16_MAX
#define UINT16_MAX (65535U)
#endif
#ifndef UINT32_MAX
#define UINT32_MAX (4294967295U)
#endif

#endif /* ! C99 */

#endif /* ! FLEXINT_H */

/* begin standard C++ headers. */
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <errno.h>
#include <iostream>
/* end standard C++ headers. */

#ifdef __cplusplus

/* The "const" storage-class-modifier is valid. */
#define YY_USE_CONST

#else /* ! __cplusplus */

/* C99 requires __STDC__ to be defined as 1. */
#if defined(__STDC__)

#define YY_USE_CONST

#endif /* defined (__STDC__) */
#endif /* ! __cplusplus */

#ifdef YY_USE_CONST
#define yyconst const
#else
#define yyconst
#endif

/* Returned upon end-of-file. */
#define YY_NULL 0

/* Promotes a possibly negative, possibly signed char to an unsigned
 * integer for use as an array index.  If the signed char is negative,
 * we want to instead treat it as an 8-bit unsigned char, hence the
 * double cast.
 */
#define YY_SC_TO_UI(c) ((unsigned int)(unsigned char)c)

/* Enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way forced on us by the ()-less
 * definition of BEGIN.
 */
#define BEGIN (yy_start) = 1 + 2 *

/* Translate the current start state into a value that can be later handed
 * to BEGIN to return to the state.  The YYSTATE alias is for lex
 * compatibility.
 */
#define YY_START (((yy_start)-1) / 2)
#define YYSTATE YY_START

/* Action number for EOF rule of a given start state. */
#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)

/* Special action meaning "start processing a new file". */
#define YY_NEW_FILE yyrestart(yyin)

#define YY_END_OF_BUFFER_CHAR 0

/* Size of default input buffer. */
#ifndef YY_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k.
 * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
 * Ditto for the __ia64__ case accordingly.
 */
#define YY_BUF_SIZE 32768
#else
#define YY_BUF_SIZE 16384
#endif /* __ia64__ */
#endif

/* The state buf must be large enough to hold one state per character in the
 * main buffer.
 */
#define YY_STATE_BUF_SIZE ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))

#ifndef YY_TYPEDEF_YY_BUFFER_STATE
#define YY_TYPEDEF_YY_BUFFER_STATE
typedef struct yy_buffer_state *YY_BUFFER_STATE;
#endif

#ifndef YY_TYPEDEF_YY_SIZE_T
#define YY_TYPEDEF_YY_SIZE_T
typedef size_t yy_size_t;
#endif

extern yy_size_t yyleng;

#define EOB_ACT_CONTINUE_SCAN 0
#define EOB_ACT_END_OF_FILE 1
#define EOB_ACT_LAST_MATCH 2

/* Note: We specifically omit the test for yy_rule_can_match_eol because it
 * requires access to the local variable yy_act. Since yyless() is a macro, it
 * would break existing scanners that call yyless() from OUTSIDE yylex. One
 * obvious solution it to make yy_act a global. I tried that, and saw a 5%
 * performance hit in a non-yylineno scanner, because yy_act is normally
 * declared as a register variable-- so it is not worth it.
 */
#define YY_LESS_LINENO(n)                  \
  do {                                     \
    int yyl;                               \
    for (yyl = n; yyl < yyleng; ++yyl)     \
      if (yytext[yyl] == '\n') --yylineno; \
  } while (0)
#define YY_LINENO_REWIND_TO(dst)         \
  do {                                   \
    const char *p;                       \
    for (p = yy_cp - 1; p >= (dst); --p) \
      if (*p == '\n') --yylineno;        \
  } while (0)

/* Return all but the first "n" matched characters back to the input stream. */
#define yyless(n)                                                                           \
  do {                                                                                      \
    /* Undo effects of setting up yytext. */                                                \
    int yyless_macro_arg = (n);                                                             \
    YY_LESS_LINENO(yyless_macro_arg);                                                       \
    *yy_cp = (yy_hold_char);                                                                \
    YY_RESTORE_YY_MORE_OFFSET(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
    YY_DO_BEFORE_ACTION; /* set up yytext again */                                          \
  } while (0)

#define unput(c) yyunput(c, (yytext_ptr))

#ifndef YY_STRUCT_YY_BUFFER_STATE
#define YY_STRUCT_YY_BUFFER_STATE
struct yy_buffer_state {

  std::istream *yy_input_file;

  char *yy_ch_buf;  /* input buffer */
  char *yy_buf_pos; /* current position in input buffer */

  /* Size of input buffer in bytes, not including room for EOB
   * characters.
   */
  yy_size_t yy_buf_size;

  /* Number of characters read into yy_ch_buf, not including EOB
   * characters.
   */
  yy_size_t yy_n_chars;

  /* Whether we "own" the buffer - i.e., we know we created it,
   * and can realloc() it to grow it, and should free() it to
   * delete it.
   */
  int yy_is_our_buffer;

  /* Whether this is an "interactive" input source; if so, and
   * if we're using stdio for input, then we want to use getc()
   * instead of fread(), to make sure we stop fetching input after
   * each newline.
   */
  int yy_is_interactive;

  /* Whether we're considered to be at the beginning of a line.
   * If so, '^' rules will be active on the next match, otherwise
   * not.
   */
  int yy_at_bol;

  int yy_bs_lineno; /**< The line count. */
  int yy_bs_column; /**< The column count. */

  /* Whether to try to fill the input buffer when we reach the
   * end of it.
   */
  int yy_fill_buffer;

  int yy_buffer_status;

#define YY_BUFFER_NEW 0
#define YY_BUFFER_NORMAL 1
  /* When an EOF's been seen but there's still some text to process
   * then we mark the buffer as YY_EOF_PENDING, to indicate that we
   * shouldn't try reading from the input source any more.  We might
   * still have a bunch of tokens to match, though, because of
   * possible backing-up.
   *
   * When we actually see the EOF, we change the status to "new"
   * (via yyrestart()), so that the user can continue scanning by
   * just pointing yyin at a new input file.
   */
#define YY_BUFFER_EOF_PENDING 2
};
#endif /* !YY_STRUCT_YY_BUFFER_STATE */

/* We provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state".
 *
 * Returns the top of the stack, or NULL.
 */
#define YY_CURRENT_BUFFER ((yy_buffer_stack) ? (yy_buffer_stack)[(yy_buffer_stack_top)] : NULL)

/* Same as previous macro, but useful when we know that the buffer stack is not
 * NULL or when we need an lvalue. For internal use only.
 */
#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]

void *yyalloc(yy_size_t);
void *yyrealloc(void *, yy_size_t);
void yyfree(void *);

#define yy_new_buffer yy_create_buffer

#define yy_set_interactive(is_interactive)                            \
  {                                                                   \
    if (!YY_CURRENT_BUFFER) {                                         \
      yyensure_buffer_stack();                                        \
      YY_CURRENT_BUFFER_LVALUE = yy_create_buffer(yyin, YY_BUF_SIZE); \
    }                                                                 \
    YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive;     \
  }

#define yy_set_bol(at_bol)                                            \
  {                                                                   \
    if (!YY_CURRENT_BUFFER) {                                         \
      yyensure_buffer_stack();                                        \
      YY_CURRENT_BUFFER_LVALUE = yy_create_buffer(yyin, YY_BUF_SIZE); \
    }                                                                 \
    YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol;                     \
  }

#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)

/* Begin user sect3 */
#define YY_SKIP_YYWRAP

typedef unsigned char YY_CHAR;

#define yytext_ptr yytext
#define YY_INTERACTIVE

#include <FlexLexer.h>

int yyFlexLexer::yywrap() { return 1; }

/* Done after the current pattern has been matched and before the
 * corresponding action - sets up yytext.
 */
#define YY_DO_BEFORE_ACTION         \
  (yytext_ptr) = yy_bp;             \
  yyleng = (size_t)(yy_cp - yy_bp); \
  (yy_hold_char) = *yy_cp;          \
  *yy_cp = '\0';                    \
  (yy_c_buf_p) = yy_cp;

#define YY_NUM_RULES 43
#define YY_END_OF_BUFFER 44
/* This struct is not used in this scanner,
   but its presence is necessary. */
struct yy_trans_info {
  flex_int32_t yy_verify;
  flex_int32_t yy_nxt;
};
static yyconst flex_int16_t yy_accept[433] = {
    0,  1,  1,  0,  0,  0,  0,  44, 42, 2,  1,  1,  42, 24, 42, 42, 39, 39, 42, 42, 42,
    42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 28, 28, 43, 1,  1,  1,
    0,  36, 24, 0,  36, 26, 25, 39, 0,  0,  38, 0,  33, 37, 37, 37, 37, 37, 37, 37, 37,
    37, 37, 37, 37, 21, 37, 37, 37, 37, 37, 37, 37, 27, 25, 39, 0,  0,  0,  32, 40, 31,
    31, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37,

    37, 20, 39, 0,  0,  0,  0,  30, 30, 0,  31, 0,  31, 37, 37, 37, 37, 37, 37, 37, 37,
    37, 37, 37, 37, 37, 37, 22, 37, 37, 39, 0,  41, 0,  0,  0,  30, 0,  30, 0,  31, 31,
    31, 31, 37, 37, 37, 23, 37, 3,  37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 0,
    0,  0,  0,  0,  30, 30, 30, 30, 0,  31, 31, 31, 0,  31, 4,  37, 37, 37, 37, 37, 37,
    37, 37, 11, 37, 37, 5,  37, 37, 0,  0,  0,  0,  30, 30, 30, 0,

    30, 0,  0,  31, 31, 31, 31, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 6,  37, 41, 0,
    0,  0,  0,  0,  30, 30, 30, 30, 0,  31, 31, 31, 0,  31, 37, 37, 37, 37, 37, 18, 16,
    37, 13, 37, 19, 0,  0,  0,  0,  30, 30, 30, 0,  30, 35, 31, 31, 31, 31, 37, 37, 37,
    37, 17, 7,  12, 0,  0,  0,  0,  34, 30, 30, 30, 30, 31, 31, 31, 0,  31, 37, 10, 37,
    14, 41, 0,  0,  30, 30, 30, 0,  30, 31, 31, 31, 31, 37, 37, 0,

    0,  0,  0,  30, 30, 30, 30, 31, 31, 31, 0,  31, 15, 8,  0,  0,  0,  30, 30, 30, 0,
    30, 31, 31, 31, 31, 37, 41, 0,  0,  0,  30, 30, 30, 30, 31, 31, 31, 0,  31, 37, 0,
    0,  29, 32, 30, 30, 30, 0,  30, 31, 31, 31, 31, 37, 0,  0,  29, 0,  30, 30, 30, 30,
    30, 31, 31, 31, 0,  31, 37, 41, 29, 32, 30, 0,  30, 30, 30, 30, 31, 31, 31, 37, 0,
    29, 30, 30, 30, 30, 31, 31, 31, 9,  0,  30, 30, 0,  30, 30, 31,

    41, 30, 30, 31, 0,  30, 30, 0,  29, 30, 30, 29, 30, 30, 0,  0,  30, 30, 0,  30, 30,
    0,  41, 30, 30, 0,  30, 30, 0,  30, 30, 0};

static yyconst flex_int32_t yy_ec[256] = {
    0,  1,  1,  1,  1,  1,  1,  1,  1,  2,  3,  1,  1,  4,  1,  1,  1,  1,  1,  1,  1,
    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  2,  1,  5,  6,  1,  1,  1,  7,  1,  1,
    8,  1,  1,  9,  10, 11, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 1,  1,  1,  1,
    1,  1,  15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33,
    34, 35, 36, 37, 38, 39, 24, 1,  1,  1,  1,  1,  1,  40, 16, 41, 42,

    43, 44, 45, 46, 47, 24, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62,
    24, 1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,

    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1};

static yyconst flex_int32_t yy_meta[63] = {
    0, 1, 1, 2, 1, 1, 1, 1, 1, 3, 4, 1, 5, 5, 6, 5, 5, 5, 5, 5, 5, 3, 7, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 8, 3, 5, 5, 5, 5, 5, 3, 7, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 8, 3};

static yyconst flex_int16_t yy_base[576] = {
    0,    0,    0,    1384, 1383, 0,    0,    1390, 1393, 1393, 60,   62,   1384, 0,    1381,
    59,   59,   62,   1373, 112,  147,  52,   62,   54,   1372, 66,   69,   122,  85,   65,
    90,   125,  160,  68,   93,   127,  1393, 1374, 1393, 87,   139,  144,  1379, 1393, 0,
    1376, 1375, 1393, 0,    163,  1367, 157,  1393, 0,    137,  1366, 204,  1365, 158,  156,
    89,   185,  168,  172,  183,  180,  181,  1364, 198,  213,  199,  200,  219,  224,  227,
    1393, 0,    239,  1363, 235,  1362, 224,  0,    255,  260,  274,  257,  268,  245,  263,
    258,  284,  259,  126,  288,  281,  291,  294,  296,  307,  295,

    299,  1361, 321,  315,  1360, 1359, 1358, 328,  334,  339,  344,  347,  339,  356,  311,
    356,  363,  352,  364,  349,  370,  366,  372,  373,  350,  376,  395,  1357, 406,  404,
    410,  414,  1356, 1355, 1354, 416,  427,  418,  391,  432,  437,  438,  445,  450,  1353,
    377,  421,  1352, 452,  1351, 448,  449,  451,  453,  457,  460,  455,  464,  465,  467,
    471,  472,  1350, 1349, 1348, 1347, 483,  497,  477,  503,  509,  476,  516,  1346, 521,
    490,  510,  1345, 518,  498,  524,  526,  522,  528,  529,  535,  1344, 530,  538,  1343,
    531,  537,  1342, 1341, 1340, 542,  559,  1339, 573,  550,

    564,  579,  583,  587,  566,  592,  580,  584,  589,  593,  594,  597,  600,  603,  595,
    606,  598,  1338, 599,  1337, 1336, 1335, 1334, 613,  617,  645,  622,  650,  625,  555,
    655,  1333, 660,  637,  661,  647,  662,  623,  664,  663,  1332, 1331, 665,  1330, 667,
    1329, 1328, 1327, 1326, 640,  674,  1325, 680,  683,  687,  690,  701,  696,  706,  707,
    709,  710,  716,  694,  1324, 1323, 1322, 1321, 1320, 1319, 1318, 719,  723,  724,  729,
    730,  744,  1317, 749,  733,  737,  734,  1316, 741,  1315, 1314, 1313, 1312, 756,  1311,
    761,  764,  768,  771,  777,  782,  779,  746,  783,  1310,

    1309, 1308, 1307, 792,  797,  800,  805,  808,  1306, 814,  786,  819,  1305, 821,  1304,
    1303, 1302, 824,  1301, 829,  796,  830,  835,  836,  841,  842,  843,  1300, 1299, 1298,
    1297, 848,  849,  854,  855,  861,  1296, 866,  804,  867,  856,  1295, 1294, 1293, 0,
    872,  1292, 877,  819,  882,  887,  884,  892,  893,  894,  1291, 1290, 1289, 1288, 1287,
    903,  900,  908,  1290, 912,  1285, 917,  0,    909,  914,  1284, 1283, 1393, 1282, 0,
    925,  1281, 930,  1284, 934,  931,  0,    918,  1279, 1278, 1277, 1276, 939,  1015, 946,
    985,  0,    958,  957,  956,  955,  0,    951,  1393, 0,

    954,  953,  952,  1393, 951,  948,  941,  0,    940,  939,  920,  895,  879,  869,  0,
    809,  786,  772,  0,    765,  758,  0,    751,  736,  713,  686,  684,  677,  0,    633,
    630,  1393, 973,  981,  989,  997,  1005, 1009, 1015, 1023, 1027, 1030, 577,  554,  1032,
    1035, 1037, 552,  1040, 1042, 1045, 1047, 1049, 1052, 1055, 516,  1057, 1059, 1062, 513,
    1065, 1068, 1070, 1072, 1074, 1077, 1080, 1083, 495,  1085, 1087, 1089, 1092, 475,  1095,
    1098, 1100, 1102, 1105, 1108, 1111, 449,  1113, 1115, 1117, 1120, 438,  1123, 1126, 1128,
    1130, 1132, 1135, 1138, 1141, 431,  1143, 1145, 1148, 398,

    1151, 1154, 1156, 1158, 1160, 1163, 1166, 1169, 383,  1171, 1173, 1175, 1178, 325,  1181,
    1184, 1186, 1188, 1191, 1194, 1197, 306,  1199, 1201, 1203, 275,  1206, 259,  1209, 1212,
    1214, 1216, 1218, 1221, 1224, 1226, 238,  1228, 1230, 1232, 205,  1235, 1237, 195,  1239,
    1241, 1243, 1246, 193,  1247, 1249, 179,  146,  1251, 1253, 1255, 1257, 1259, 108,  1261,
    1263, 1265, 1267, 101,  1269, 1271, 1273, 98,   1275, 82,   1277, 1279, 1281, 80,   1283};

static yyconst flex_int16_t yy_def[576] = {
    0,   432, 1,   433, 433, 434, 434, 432, 432, 432, 432, 432, 435, 436, 437, 432, 438, 438, 432,
    439, 439, 20,  20,  439, 439, 439, 439, 439, 439, 439, 439, 439, 439, 439, 439, 439, 432, 432,
    432, 432, 432, 432, 435, 432, 436, 437, 432, 432, 440, 441, 442, 441, 432, 443, 444, 439, 439,
    439, 439, 56,  56,  439, 439, 439, 439, 439, 439, 439, 439, 439, 439, 439, 439, 439, 439, 432,
    440, 445, 446, 445, 447, 448, 443, 449, 449, 56,  439, 439, 439, 439, 439, 439, 439, 439, 439,
    439, 439, 439, 439, 439, 439,

    439, 439, 450, 450, 451, 452, 453, 454, 454, 432, 455, 456, 455, 85,  439, 439, 439, 439, 439,
    439, 439, 439, 439, 439, 439, 439, 439, 439, 439, 439, 450, 131, 452, 457, 458, 432, 459, 460,
    459, 432, 461, 461, 462, 462, 114, 439, 439, 439, 439, 439, 439, 439, 439, 439, 439, 439, 439,
    439, 439, 439, 439, 439, 463, 432, 464, 465, 432, 466, 466, 467, 467, 432, 432, 432, 468, 469,
    468, 439, 439, 439, 439, 439, 439, 439, 439, 439, 439, 439, 439, 439, 439, 439, 470, 471, 472,
    432, 432, 432, 473, 474,

    473, 432, 432, 475, 475, 476, 476, 439, 439, 439, 439, 439, 439, 439, 439, 439, 439, 439, 439,
    464, 432, 477, 478, 432, 432, 479, 479, 480, 480, 432, 432, 432, 481, 482, 481, 439, 439, 439,
    439, 439, 439, 439, 439, 439, 439, 439, 483, 484, 485, 432, 432, 432, 486, 487, 486, 432, 488,
    488, 489, 489, 439, 439, 439, 439, 439, 439, 439, 490, 432, 491, 492, 432, 493, 493, 494, 494,
    432, 432, 495, 496, 495, 439, 439, 439, 439, 477, 497, 498, 432, 432, 499, 500, 499, 501, 501,
    502, 502, 439, 439, 503,

    432, 504, 505, 506, 506, 507, 507, 432, 432, 508, 509, 508, 439, 439, 510, 511, 512, 432, 432,
    513, 514, 513, 515, 515, 516, 516, 439, 491, 432, 517, 518, 519, 519, 520, 520, 432, 432, 521,
    522, 521, 439, 523, 524, 525, 526, 432, 432, 527, 528, 527, 529, 529, 530, 530, 439, 531, 432,
    532, 432, 533, 534, 534, 535, 535, 432, 432, 536, 537, 536, 439, 538, 539, 432, 540, 541, 432,
    432, 542, 542, 543, 543, 544, 439, 545, 432, 546, 547, 548, 548, 432, 432, 549, 439, 550, 432,
    551, 552, 432, 432, 553,

    554, 555, 556, 432, 557, 432, 558, 559, 560, 561, 562, 532, 432, 563, 564, 565, 566, 567, 568,
    432, 569, 570, 432, 571, 572, 565, 432, 573, 574, 575, 432, 0,   432, 432, 432, 432, 432, 432,
    432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432,
    432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432,
    432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432,
    432, 432, 432, 432, 432,

    432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432,
    432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432,
    432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432,
    432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432};

static yyconst flex_int16_t yy_nxt[1456] = {
    0,   8,   9,   10,  11,  12,  13,  14,  8,   8,   8,   15,  16,  17,  18,  19,  19,  20,  19,
    21,  22,  23,  24,  25,  24,  24,  26,  27,  28,  29,  24,  24,  30,  31,  32,  33,  24,  34,
    24,  35,  19,  20,  19,  21,  22,  23,  24,  25,  24,  26,  27,  28,  29,  24,  24,  30,  31,
    32,  33,  24,  34,  24,  35,  39,  40,  41,  40,  47,  432, 59,  48,  49,  49,  50,  49,  49,
    50,  60,  55,  432, 432, 52,  432, 432, 52,  364, 62,  425, 55,  61,  39,  40,  64,  59,  63,
    68,  72,  53,  65,  432, 432,

    55,  60,  423, 432, 52,  418, 432, 52,  69,  62,  55,  61,  411, 67,  88,  64,  63,  68,  72,
    53,  65,  73,  432, 56,  56,  50,  56,  56,  56,  56,  56,  56,  69,  57,  122, 432, 67,  88,
    432, 432, 432, 41,  40,  70,  73,  74,  39,  40,  83,  83,  404, 56,  56,  56,  56,  56,  66,
    57,  56,  56,  50,  56,  56,  56,  56,  56,  56,  70,  57,  74,  78,  432, 58,  432, 77,  77,
    78,  87,  52,  66,  86,  432, 90,  403, 52,  432, 56,  56,  56,  56,  56,  71,  57,  432, 432,
    58,  432, 400, 432, 392,

    93,  87,  52,  89,  86,  91,  94,  90,  52,  387, 92,  432, 432, 432, 71,  85,  85,  78,  85,
    85,  85,  85,  85,  85,  93,  57,  432, 89,  91,  94,  98,  95,  432, 92,  99,  108, 108, 432,
    96,  97,  432, 100, 382, 85,  85,  85,  85,  85,  50,  57,  103, 103, 50,  98,  95,  101, 52,
    99,  432, 102, 52,  96,  97,  364, 110, 100, 111, 111, 112, 432, 432, 432, 432, 112, 119, 115,
    432, 117, 101, 360, 52,  432, 102, 121, 52,  114, 114, 50,  114, 114, 114, 114, 114, 114, 432,
    118, 116, 432, 119, 115,

    117, 432, 120, 124, 432, 125, 121, 432, 432, 432, 354, 129, 432, 114, 114, 114, 114, 114, 118,
    116, 432, 123, 126, 130, 432, 128, 120, 124, 50,  335, 125, 127, 131, 131, 50,  129, 52,  136,
    146, 137, 137, 138, 52,  432, 123, 126, 130, 138, 432, 128, 140, 140, 112, 110, 127, 141, 141,
    112, 143, 143, 52,  146, 432, 432, 147, 432, 52,  145, 145, 432, 145, 145, 145, 145, 145, 145,
    432, 432, 152, 432, 151, 148, 150, 432, 149, 432, 432, 326, 158, 432, 432, 153, 154, 155, 156,
    145, 145, 145, 145, 145,

    432, 157, 307, 151, 138, 148, 150, 149, 432, 159, 178, 158, 162, 160, 153, 154, 155, 432, 156,
    432, 161, 131, 131, 432, 157, 132, 132, 167, 167, 170, 170, 52,  159, 178, 432, 297, 136, 160,
    168, 168, 138, 172, 276, 140, 140, 161, 110, 432, 173, 173, 112, 112, 179, 260, 110, 52,  175,
    175, 176, 432, 180, 432, 432, 176, 432, 432, 432, 181, 432, 183, 432, 185, 188, 432, 182, 179,
    186, 432, 432, 229, 432, 184, 187, 189, 432, 432, 432, 202, 202, 192, 138, 181, 196, 183, 167,
    167, 185, 182, 190, 207,

    186, 206, 206, 191, 184, 187, 136, 189, 197, 197, 138, 432, 136, 192, 199, 199, 200, 171, 432,
    432, 144, 190, 200, 176, 209, 110, 191, 203, 203, 112, 110, 432, 204, 204, 176, 432, 208, 432,
    210, 432, 211, 432, 432, 432, 432, 213, 217, 209, 432, 215, 432, 432, 216, 224, 224, 214, 109,
    212, 84,  219, 208, 228, 228, 210, 218, 211, 256, 256, 136, 213, 225, 225, 138, 432, 215, 432,
    216, 200, 214, 176, 212, 82,  136, 219, 226, 226, 200, 218, 230, 432, 202, 202, 110, 234, 203,
    203, 110, 432, 231, 231,

    176, 110, 432, 233, 233, 234, 432, 432, 432, 238, 432, 432, 432, 432, 236, 240, 432, 237, 241,
    432, 245, 242, 250, 244, 224, 224, 136, 243, 225, 225, 246, 432, 239, 238, 432, 200, 432, 236,
    254, 240, 237, 263, 241, 429, 245, 242, 429, 244, 259, 259, 243, 272, 272, 246, 136, 239, 251,
    251, 200, 136, 432, 253, 253, 254, 110, 263, 203, 203, 176, 110, 432, 257, 257, 234, 234, 432,
    432, 432, 432, 262, 432, 261, 264, 136, 267, 225, 225, 200, 265, 136, 429, 273, 273, 254, 275,
    275, 432, 422, 266, 432,

    254, 256, 256, 262, 261, 432, 264, 432, 267, 234, 110, 265, 277, 277, 234, 110, 432, 279, 279,
    280, 280, 266, 432, 432, 284, 285, 429, 282, 283, 432, 272, 272, 136, 432, 289, 289, 254, 254,
    136, 432, 291, 291, 292, 292, 296, 296, 432, 432, 285, 422, 280, 282, 283, 110, 432, 203, 203,
    234, 110, 432, 294, 294, 280, 299, 426, 136, 298, 225, 225, 254, 136, 422, 304, 304, 292, 306,
    306, 432, 415, 313, 110, 292, 308, 308, 280, 422, 432, 299, 432, 298, 280, 110, 311, 310, 310,
    311, 432, 325, 325, 415,

    314, 136, 313, 318, 318, 292, 432, 334, 334, 136, 292, 320, 320, 321, 432, 353, 353, 110, 321,
    203, 203, 280, 373, 110, 314, 323, 323, 311, 432, 327, 363, 363, 311, 136, 432, 225, 225, 292,
    136, 432, 332, 332, 321, 321, 110, 432, 336, 336, 311, 311, 110, 432, 338, 338, 339, 339, 432,
    136, 432, 346, 346, 321, 321, 136, 432, 348, 348, 349, 349, 432, 110, 341, 203, 203, 311, 110,
    432, 351, 351, 339, 339, 136, 415, 225, 225, 321, 136, 355, 361, 361, 349, 432, 408, 432, 341,
    349, 110, 339, 365, 365,

    339, 110, 432, 367, 367, 368, 368, 432, 416, 432, 355, 370, 136, 349, 376, 376, 349, 136, 432,
    378, 378, 110, 368, 203, 203, 339, 110, 432, 380, 380, 368, 432, 383, 415, 136, 370, 225, 225,
    349, 136, 432, 388, 388, 110, 368, 390, 390, 368, 136, 393, 398, 398, 408, 359, 408, 110, 383,
    203, 203, 368, 136, 397, 225, 225, 345, 408, 397, 405, 397, 375, 331, 432, 393, 36,  36,  36,
    36,  36,  36,  36,  36,  38,  38,  38,  38,  38,  38,  38,  38,  42,  42,  42,  42,  42,  42,
    42,  42,  44,  368, 44,

    44,  44,  44,  44,  44,  45,  45,  45,  45,  45,  45,  45,  45,  51,  51,  51,  51,  55,  55,
    55,  55,  55,  55,  76,  432, 76,  76,  76,  76,  76,  76,  79,  79,  79,  80,  80,  104, 104,
    104, 105, 105, 106, 106, 113, 113, 113, 132, 132, 132, 133, 133, 134, 134, 135, 135, 139, 139,
    139, 142, 142, 142, 164, 164, 165, 165, 169, 169, 169, 174, 174, 174, 177, 177, 177, 193, 193,
    194, 194, 195, 195, 198, 198, 198, 201, 201, 201, 205, 205, 205, 220, 220, 221, 221, 222, 222,
    227, 227, 227, 232, 232,

    232, 235, 235, 235, 248, 248, 249, 249, 252, 252, 252, 255, 255, 255, 258, 258, 258, 268, 268,
    269, 269, 270, 270, 274, 274, 274, 278, 278, 278, 281, 281, 281, 286, 286, 287, 287, 288, 288,
    290, 290, 290, 293, 293, 293, 295, 295, 295, 301, 301, 302, 302, 305, 305, 305, 309, 309, 309,
    312, 312, 312, 315, 315, 316, 316, 317, 317, 319, 319, 319, 322, 322, 322, 324, 324, 324, 328,
    328, 329, 329, 330, 330, 333, 333, 333, 337, 337, 337, 340, 340, 340, 343, 343, 344, 344, 347,
    347, 347, 350, 350, 350,

    352, 352, 352, 356, 356, 357, 357, 358, 358, 362, 362, 362, 366, 366, 366, 369, 369, 369, 371,
    371, 372, 372, 374, 374, 377, 377, 377, 379, 379, 381, 381, 381, 316, 316, 385, 385, 386, 386,
    389, 389, 391, 391, 391, 394, 394, 395, 395, 396, 396, 399, 399, 401, 401, 402, 402, 343, 343,
    406, 406, 407, 407, 409, 409, 410, 410, 412, 412, 413, 413, 414, 414, 417, 417, 419, 419, 420,
    420, 421, 421, 424, 424, 427, 427, 428, 428, 430, 430, 431, 431, 397, 375, 359, 81,  432, 349,
    375, 359, 384, 339, 432,

    375, 373, 359, 331, 303, 321, 359, 331, 81,  311, 345, 331, 303, 342, 292, 331, 303, 271, 432,
    280, 81,  303, 271, 81,  254, 303, 271, 300, 432, 432, 234, 81,  271, 223, 223, 432, 432, 432,
    200, 271, 223, 81,  432, 432, 432, 432, 176, 81,  223, 166, 247, 432, 138, 223, 166, 166, 432,
    432, 432, 112, 81,  166, 107, 81,  432, 432, 432, 166, 107, 163, 432, 81,  107, 107, 432, 107,
    81,  432, 432, 432, 81,  45,  46,  43,  75,  432, 54,  46,  43,  432, 37,  37,  7,   432, 432,
    432, 432, 432, 432, 432,

    432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432,
    432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432,
    432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432};

static yyconst flex_int16_t yy_chk[1456] = {
    0,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
    1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
    1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
    1,   1,   1,   1,   1,   1,   10,  10,  11,  11,  15,  23,  21,  15,  16,  16,  16,  17,  17,
    17,  22,  21,  29,  25,  16,  33,  26,  17,  574, 25,  570, 22,  23,  39,  39,  26,  21,  25,
    29,  33,  16,  26,  28,  17,

    21,  22,  568, 30,  16,  564, 34,  17,  30,  25,  22,  23,  559, 28,  60,  26,  25,  29,  33,
    16,  26,  34,  17,  19,  19,  19,  19,  19,  19,  19,  19,  19,  30,  19,  93,  27,  28,  60,
    31,  93,  35,  40,  40,  31,  34,  35,  41,  41,  54,  54,  553, 19,  19,  19,  19,  19,  27,
    19,  20,  20,  20,  20,  20,  20,  20,  20,  20,  31,  20,  35,  51,  58,  20,  32,  49,  49,
    49,  59,  51,  27,  58,  62,  62,  552, 49,  63,  20,  20,  20,  20,  20,  32,  20,  65,  66,
    20,  64,  549, 61,  544,

    65,  59,  51,  61,  58,  63,  66,  62,  49,  541, 64,  68,  70,  71,  32,  56,  56,  56,  56,
    56,  56,  56,  56,  56,  65,  56,  69,  61,  63,  66,  70,  68,  72,  64,  71,  81,  81,  73,
    69,  69,  74,  72,  537, 56,  56,  56,  56,  56,  79,  56,  77,  77,  77,  70,  68,  73,  79,
    71,  88,  74,  77,  69,  69,  528, 83,  72,  83,  83,  83,  84,  86,  90,  92,  84,  90,  86,
    89,  88,  73,  526, 79,  87,  74,  92,  77,  85,  85,  85,  85,  85,  85,  85,  85,  85,  95,
    89,  87,  91,  90,  86,

    88,  94,  91,  95,  96,  96,  92,  97,  100, 98,  522, 100, 101, 85,  85,  85,  85,  85,  89,
    87,  99,  94,  97,  101, 115, 99,  91,  95,  104, 514, 96,  98,  103, 103, 103, 100, 104, 108,
    115, 108, 108, 108, 103, 109, 94,  97,  101, 109, 113, 99,  110, 110, 113, 111, 98,  111, 111,
    111, 112, 112, 104, 115, 120, 125, 116, 118, 103, 114, 114, 116, 114, 114, 114, 114, 114, 114,
    117, 119, 121, 122, 120, 117, 119, 121, 118, 123, 124, 509, 125, 126, 146, 122, 122, 122, 123,
    114, 114, 114, 114, 114,

    139, 124, 500, 120, 139, 117, 119, 118, 127, 126, 146, 125, 130, 127, 122, 122, 122, 130, 123,
    129, 129, 131, 131, 131, 124, 132, 132, 136, 136, 138, 138, 131, 126, 146, 147, 496, 137, 127,
    137, 137, 137, 140, 487, 140, 140, 129, 141, 142, 141, 141, 141, 142, 147, 482, 143, 131, 143,
    143, 143, 144, 149, 151, 152, 144, 153, 149, 154, 151, 157, 153, 155, 155, 158, 156, 152, 147,
    156, 158, 159, 474, 160, 154, 157, 159, 161, 162, 169, 172, 172, 162, 169, 151, 167, 153, 167,
    167, 155, 152, 160, 469,

    156, 176, 176, 161, 154, 157, 168, 159, 168, 168, 168, 180, 170, 162, 170, 170, 170, 460, 171,
    177, 456, 160, 171, 177, 180, 173, 161, 173, 173, 173, 175, 179, 175, 175, 175, 183, 179, 181,
    181, 182, 182, 184, 185, 188, 191, 184, 189, 180, 186, 186, 192, 189, 188, 196, 196, 185, 448,
    183, 444, 192, 179, 200, 200, 181, 191, 182, 230, 230, 197, 184, 197, 197, 197, 201, 186, 205,
    188, 201, 185, 205, 183, 443, 199, 192, 199, 199, 199, 191, 202, 207, 202, 202, 203, 207, 203,
    203, 204, 208, 204, 204,

    204, 206, 209, 206, 206, 206, 210, 211, 215, 210, 212, 217, 219, 213, 208, 212, 214, 209, 213,
    216, 217, 214, 224, 216, 224, 224, 225, 215, 225, 225, 219, 227, 211, 210, 229, 227, 238, 208,
    229, 212, 209, 238, 213, 431, 217, 214, 430, 216, 234, 234, 215, 250, 250, 219, 226, 211, 226,
    226, 226, 228, 236, 228, 228, 228, 231, 238, 231, 231, 231, 233, 235, 233, 233, 233, 235, 237,
    240, 239, 243, 237, 245, 236, 239, 251, 245, 251, 251, 251, 240, 253, 428, 253, 253, 253, 254,
    254, 255, 427, 243, 426,

    255, 256, 256, 237, 236, 258, 239, 264, 245, 258, 257, 240, 257, 257, 257, 259, 260, 259, 259,
    259, 260, 243, 261, 262, 263, 264, 425, 261, 262, 263, 272, 272, 273, 274, 273, 273, 273, 274,
    275, 276, 275, 275, 275, 276, 280, 280, 281, 282, 264, 424, 281, 261, 262, 277, 284, 277, 277,
    277, 279, 298, 279, 279, 279, 284, 423, 289, 282, 289, 289, 289, 291, 421, 291, 291, 291, 292,
    292, 293, 420, 298, 294, 293, 294, 294, 294, 418, 295, 284, 297, 282, 295, 296, 297, 296, 296,
    296, 299, 311, 311, 417,

    299, 304, 298, 304, 304, 304, 305, 321, 321, 306, 305, 306, 306, 306, 307, 339, 339, 308, 307,
    308, 308, 308, 416, 310, 299, 310, 310, 310, 312, 314, 349, 349, 312, 318, 314, 318, 318, 318,
    320, 322, 320, 320, 320, 322, 323, 324, 323, 323, 323, 324, 325, 326, 325, 325, 325, 326, 327,
    332, 333, 332, 332, 332, 333, 334, 335, 334, 334, 334, 335, 341, 336, 327, 336, 336, 336, 338,
    340, 338, 338, 338, 340, 346, 414, 346, 346, 346, 348, 341, 348, 348, 348, 350, 413, 352, 327,
    350, 351, 352, 351, 351,

    351, 353, 354, 353, 353, 353, 354, 355, 412, 362, 341, 355, 361, 362, 361, 361, 361, 363, 369,
    363, 363, 365, 369, 365, 365, 365, 367, 370, 367, 367, 367, 383, 370, 411, 376, 355, 376, 376,
    376, 378, 381, 378, 378, 380, 381, 380, 380, 380, 388, 383, 388, 388, 410, 409, 407, 390, 370,
    390, 390, 390, 398, 406, 398, 398, 405, 403, 402, 401, 396, 395, 394, 393, 383, 433, 433, 433,
    433, 433, 433, 433, 433, 434, 434, 434, 434, 434, 434, 434, 434, 435, 435, 435, 435, 435, 435,
    435, 435, 436, 391, 436,

    436, 436, 436, 436, 436, 437, 437, 437, 437, 437, 437, 437, 437, 438, 438, 438, 438, 439, 439,
    439, 439, 439, 439, 440, 389, 440, 440, 440, 440, 440, 440, 441, 441, 441, 442, 442, 445, 445,
    445, 446, 446, 447, 447, 449, 449, 449, 450, 450, 450, 451, 451, 452, 452, 453, 453, 454, 454,
    454, 455, 455, 455, 457, 457, 458, 458, 459, 459, 459, 461, 461, 461, 462, 462, 462, 463, 463,
    464, 464, 465, 465, 466, 466, 466, 467, 467, 467, 468, 468, 468, 470, 470, 471, 471, 472, 472,
    473, 473, 473, 475, 475,

    475, 476, 476, 476, 477, 477, 478, 478, 479, 479, 479, 480, 480, 480, 481, 481, 481, 483, 483,
    484, 484, 485, 485, 486, 486, 486, 488, 488, 488, 489, 489, 489, 490, 490, 491, 491, 492, 492,
    493, 493, 493, 494, 494, 494, 495, 495, 495, 497, 497, 498, 498, 499, 499, 499, 501, 501, 501,
    502, 502, 502, 503, 503, 504, 504, 505, 505, 506, 506, 506, 507, 507, 507, 508, 508, 508, 510,
    510, 511, 511, 512, 512, 513, 513, 513, 515, 515, 515, 516, 516, 516, 517, 517, 518, 518, 519,
    519, 519, 520, 520, 520,

    521, 521, 521, 523, 523, 524, 524, 525, 525, 527, 527, 527, 529, 529, 529, 530, 530, 530, 531,
    531, 532, 532, 533, 533, 534, 534, 534, 535, 535, 536, 536, 536, 538, 538, 539, 539, 540, 540,
    542, 542, 543, 543, 543, 545, 545, 546, 546, 547, 547, 548, 548, 550, 550, 551, 551, 554, 554,
    555, 555, 556, 556, 557, 557, 558, 558, 560, 560, 561, 561, 562, 562, 563, 563, 565, 565, 566,
    566, 567, 567, 569, 569, 571, 571, 572, 572, 573, 573, 575, 575, 387, 386, 385, 384, 379, 377,
    374, 372, 371, 366, 364,

    360, 359, 358, 357, 356, 347, 344, 343, 342, 337, 331, 330, 329, 328, 319, 317, 316, 315, 313,
    309, 303, 302, 301, 300, 290, 288, 287, 286, 285, 283, 278, 271, 270, 269, 268, 267, 266, 265,
    252, 249, 248, 247, 246, 244, 242, 241, 232, 223, 222, 221, 220, 218, 198, 195, 194, 193, 190,
    187, 178, 174, 166, 165, 164, 163, 150, 148, 145, 135, 134, 133, 128, 107, 106, 105, 102, 80,
    78,  67,  57,  55,  50,  46,  45,  42,  37,  24,  18,  14,  12,  7,   4,   3,   432, 432, 432,
    432, 432, 432, 432, 432,

    432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432,
    432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432,
    432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432, 432};

/* Table of booleans, true if rule could match eol. */
static yyconst flex_int32_t yy_rule_can_match_eol[44] = {
    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
};

/* The intent behind this definition is that it'll catch
 * any uses of REJECT which flex missed.
 */
#define REJECT reject_used_but_not_detected
#define yymore() yymore_used_but_not_detected
#define YY_MORE_ADJ 0
#define YY_RESTORE_YY_MORE_OFFSET
#line 1 "RelLexer.l"
#line 5 "RelLexer.l"
#ifdef WIN32
#define strncasecmp _strnicmp
#endif

using namespace std;
#include "Portable.h"
#include "RelParser.h"
#define YYABORT yyterminate();

/* duplicate default definition from flex. This makes cppcheck
   check for defined YY_FATAL_ERROR() go away. */
#define YY_FATAL_ERROR(msg) LexerError(msg)

#line 36 "RelLexer.l"
using namespace std;
unsigned ComBeg;   // line, in which comment begins
unsigned LftCnt;   // how many chars : on the left side of '::' char was interpreted
unsigned RgtCnt;   // the same as above, but on the right side of '::'
char Address[16];  // address, which is analizing right now
char AddrPart[16];
unsigned intpos, pos;

namespace std {
yy_RelParser_stype yylval;
}
#line 967 "RelLexer.cpp"

#define INITIAL 0
#define COMMENT 1
#define ADDR 2

#ifndef YY_NO_UNISTD_H
/* Special case for "unistd.h", since it is non-ANSI. We include it way
 * down here because we want the user's section 1 to have been scanned first.
 * The user has a chance to override it with an option.
 */
#include <unistd.h>
#endif

#ifndef YY_EXTRA_TYPE
#define YY_EXTRA_TYPE void *
#endif

#ifndef yytext_ptr
static void yy_flex_strncpy(char *, yyconst char *, int);
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen(yyconst char *);
#endif

#ifndef YY_NO_INPUT

#endif

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k */
#define YY_READ_BUF_SIZE 16384
#else
#define YY_READ_BUF_SIZE 8192
#endif /* __ia64__ */
#endif

/* Copy whatever the last rule matched to the standard output. */
#ifndef ECHO
#define ECHO LexerOutput(yytext, yyleng)
#endif

/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
 * is returned in "result".
 */
#ifndef YY_INPUT
#define YY_INPUT(buf, result, max_size)                 \
                                                        \
  if ((result = LexerInput((char *)buf, max_size)) < 0) \
    YY_FATAL_ERROR("input in flex scanner failed");

#endif

/* No semi-colon after return; correct usage is to write "yyterminate();" -
 * we don't want an extra ';' after the "return" because that will cause
 * some compilers to complain about unreachable statements.
 */
#ifndef yyterminate
#define yyterminate() return YY_NULL
#endif

/* Number of entries by which start-condition stack grows. */
#ifndef YY_START_STACK_INCR
#define YY_START_STACK_INCR 25
#endif

/* Report a fatal error. */
#ifndef YY_FATAL_ERROR
#define YY_FATAL_ERROR(msg) LexerError(msg)
#endif

/* end tables serialization structures and prototypes */

/* Default declaration of generated scanner - a define so the user can
 * easily add parameters.
 */
#ifndef YY_DECL
#define YY_DECL_IS_OURS 1
#define YY_DECL int yyFlexLexer::yylex()
#endif /* !YY_DECL */

/* Code executed at the beginning of each rule, after yytext and yyleng
 * have been set up.
 */
#ifndef YY_USER_ACTION
#define YY_USER_ACTION
#endif

/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK break;
#endif

#define YY_RULE_SETUP YY_USER_ACTION

/** The main scanner function which does all the work.
 */
YY_DECL {
  register yy_state_type yy_current_state;
  register char *yy_cp, *yy_bp;
  register int yy_act;

  if (!(yy_init)) {
    (yy_init) = 1;

#ifdef YY_USER_INIT
    YY_USER_INIT;
#endif

    if (!(yy_start)) (yy_start) = 1; /* first start state */

    if (!yyin) yyin = &std::cin;

    if (!yyout) yyout = &std::cout;

    if (!YY_CURRENT_BUFFER) {
      yyensure_buffer_stack();
      YY_CURRENT_BUFFER_LVALUE = yy_create_buffer(yyin, YY_BUF_SIZE);
    }

    yy_load_buffer_state();
  }

  {
#line 49 "RelLexer.l"

#line 1104 "RelLexer.cpp"

    while (1) /* loops until end-of-file is reached */
    {
      yy_cp = (yy_c_buf_p);

      /* Support of yytext. */
      *yy_cp = (yy_hold_char);

      /* yy_bp points to the position in yy_ch_buf of the start of
       * the current run.
       */
      yy_bp = yy_cp;

      yy_current_state = (yy_start);
    yy_match:
      do {
        register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
        if (yy_accept[yy_current_state]) {
          (yy_last_accepting_state) = yy_current_state;
          (yy_last_accepting_cpos) = yy_cp;
        }
        while (yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state) {
          yy_current_state = (int)yy_def[yy_current_state];
          if (yy_current_state >= 433) yy_c = yy_meta[(unsigned int)yy_c];
        }
        yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int)yy_c];
        ++yy_cp;
      } while (yy_base[yy_current_state] != 1393);

    yy_find_action:
      yy_act = yy_accept[yy_current_state];
      if (yy_act == 0) { /* have to back up */
        yy_cp = (yy_last_accepting_cpos);
        yy_current_state = (yy_last_accepting_state);
        yy_act = yy_accept[yy_current_state];
      }

      YY_DO_BEFORE_ACTION;

      if (yy_act != YY_END_OF_BUFFER && yy_rule_can_match_eol[yy_act]) {
        yy_size_t yyl;
        for (yyl = 0; yyl < yyleng; ++yyl)
          if (yytext[yyl] == '\n') yylineno++;
        ;
      }

    do_action: /* This label is used only to access EOF actions. */

      switch (yy_act) { /* beginning of action switch */
        case 0:         /* must back up */
          /* undo the effects of YY_DO_BEFORE_ACTION */
          *yy_cp = (yy_hold_char);
          yy_cp = (yy_last_accepting_cpos);
          yy_current_state = (yy_last_accepting_state);
          goto yy_find_action;

        case 1:
          /* rule 1 can match eol */
          YY_RULE_SETUP
#line 51 "RelLexer.l"
              ;  // ignore end of line
          YY_BREAK
        case 2:
          YY_RULE_SETUP
#line 52 "RelLexer.l"
              ;  // ignore TABs and spaces
          YY_BREAK
        case 3:
          YY_RULE_SETUP
#line 54 "RelLexer.l"
          {
            return RelParser::IFACE_;
          }
          YY_BREAK
        case 4:
          YY_RULE_SETUP
#line 55 "RelLexer.l"
          {
            return RelParser::CLIENT_;
          }
          YY_BREAK
        case 5:
          YY_RULE_SETUP
#line 56 "RelLexer.l"
          {
            return RelParser::SERVER_;
          }
          YY_BREAK
        case 6:
          YY_RULE_SETUP
#line 57 "RelLexer.l"
          {
            return RelParser::UNICAST_;
          }
          YY_BREAK
        case 7:
          YY_RULE_SETUP
#line 58 "RelLexer.l"
          {
            return RelParser::MULTICAST_;
          }
          YY_BREAK
        case 8:
          YY_RULE_SETUP
#line 59 "RelLexer.l"
          {
            return RelParser::IFACE_ID_;
          }
          YY_BREAK
        case 9:
          YY_RULE_SETUP
#line 60 "RelLexer.l"
          {
            return RelParser::IFACE_ID_ORDER_;
          }
          YY_BREAK
        case 10:
          YY_RULE_SETUP
#line 61 "RelLexer.l"
          {
            return RelParser::GUESS_MODE_;
          }
          YY_BREAK
        case 11:
          YY_RULE_SETUP
#line 62 "RelLexer.l"
          {
            return RelParser::OPTION_;
          }
          YY_BREAK
        case 12:
          YY_RULE_SETUP
#line 63 "RelLexer.l"
          {
            return RelParser::REMOTE_ID_;
          }
          YY_BREAK
        case 13:
          YY_RULE_SETUP
#line 64 "RelLexer.l"
          {
            return RelParser::RELAY_ID_;
          }
          YY_BREAK
        case 14:
          YY_RULE_SETUP
#line 65 "RelLexer.l"
          {
            return RelParser::LINK_LAYER_;
          }
          YY_BREAK
        case 15:
          YY_RULE_SETUP
#line 66 "RelLexer.l"
          {
            return RelParser::ECHO_REQUEST_;
          }
          YY_BREAK
        case 16:
          YY_RULE_SETUP
#line 68 "RelLexer.l"
          {
            return RelParser::LOGNAME_;
          }
          YY_BREAK
        case 17:
          YY_RULE_SETUP
#line 69 "RelLexer.l"
          {
            return RelParser::LOGLEVEL_;
          }
          YY_BREAK
        case 18:
          YY_RULE_SETUP
#line 70 "RelLexer.l"
          {
            return RelParser::LOGMODE_;
          }
          YY_BREAK
        case 19:
          YY_RULE_SETUP
#line 72 "RelLexer.l"
          {
            return RelParser::WORKDIR_;
          }
          YY_BREAK
        case 20:
          YY_RULE_SETUP
#line 74 "RelLexer.l"
          {
            yylval.ival = 1;
            return RelParser::INTNUMBER_;
          }
          YY_BREAK
        case 21:
          YY_RULE_SETUP
#line 75 "RelLexer.l"
          {
            yylval.ival = 0;
            return RelParser::INTNUMBER_;
          }
          YY_BREAK
        case 22:
          YY_RULE_SETUP
#line 76 "RelLexer.l"
          {
            yylval.ival = 1;
            return RelParser::INTNUMBER_;
          }
          YY_BREAK
        case 23:
          YY_RULE_SETUP
#line 77 "RelLexer.l"
          {
            yylval.ival = 0;
            return RelParser::INTNUMBER_;
          }
          YY_BREAK
        case 24:
          YY_RULE_SETUP
#line 79 "RelLexer.l"
              ;
          YY_BREAK
        case 25:
          YY_RULE_SETUP
#line 81 "RelLexer.l"
              ;
          YY_BREAK
        case 26:
          YY_RULE_SETUP
#line 83 "RelLexer.l"
          {
            BEGIN(COMMENT);
            ComBeg = yylineno;
          }
          YY_BREAK
        case 27:
          YY_RULE_SETUP
#line 88 "RelLexer.l"
          BEGIN(INITIAL);
          YY_BREAK
        case 28:
          /* rule 28 can match eol */
          YY_RULE_SETUP
#line 89 "RelLexer.l"
              ;
          YY_BREAK
        case YY_STATE_EOF(COMMENT):
#line 90 "RelLexer.l"
        {
          Log(Crit) << "Comment not closed. (/* in line " << ComBeg << LogEnd;
          { YYABORT; }
        }
          YY_BREAK
          // IPv6 address - various forms

        case 29:
          YY_RULE_SETUP
#line 97 "RelLexer.l"
          {
            if (!inet_pton6(yytext, yylval.addrval)) {
              Log(Crit) << "Invalid address format: [" << yytext << "]" << LogEnd;
              YYABORT;
            } else {
              return RelParser::IPV6ADDR_;
            }
          }
          YY_BREAK
        case 30:
          YY_RULE_SETUP
#line 106 "RelLexer.l"
          {
            if (!inet_pton6(yytext, yylval.addrval)) {
              Log(Crit) << "Invalid address format: [" << yytext << "]" << LogEnd;
              YYABORT;
            } else {
              return RelParser::IPV6ADDR_;
            }
          }
          YY_BREAK
        case 31:
          YY_RULE_SETUP
#line 115 "RelLexer.l"
          {
            if (!inet_pton6(yytext, yylval.addrval)) {
              Log(Crit) << "Invalid address format: [" << yytext << "]" << LogEnd;
              YYABORT;
            } else {
              return RelParser::IPV6ADDR_;
            }
          }
          YY_BREAK
        case 32:
          YY_RULE_SETUP
#line 124 "RelLexer.l"
          {
            if (!inet_pton6(yytext, yylval.addrval)) {
              Log(Crit) << "Invalid address format: [" << yytext << "]" << LogEnd;
              YYABORT;
            } else {
              return RelParser::IPV6ADDR_;
            }
          }
          YY_BREAK
        case 33:
          YY_RULE_SETUP
#line 133 "RelLexer.l"
          {
            if (!inet_pton6(yytext, yylval.addrval)) {
              Log(Crit) << "Invalid address format: [" << yytext << "]" << LogEnd;
              YYABORT;
            } else {
              return RelParser::IPV6ADDR_;
            }
          }
          YY_BREAK
        case 34:
          YY_RULE_SETUP
#line 142 "RelLexer.l"
          {
            if (!inet_pton6(yytext, yylval.addrval)) {
              Log(Crit) << "Invalid address format: [" << yytext << "]" << LogEnd;
              YYABORT;
            } else {
              return RelParser::IPV6ADDR_;
            }
          }
          YY_BREAK
        case 35:
          YY_RULE_SETUP
#line 151 "RelLexer.l"
          {
            if (!inet_pton6(yytext, yylval.addrval)) {
              Log(Crit) << "Invalid address format: [" << yytext << "]" << LogEnd;
              YYABORT;
            } else {
              return RelParser::IPV6ADDR_;
            }
          }
          YY_BREAK
        case 36:
          /* rule 36 can match eol */
          YY_RULE_SETUP
#line 160 "RelLexer.l"
          {
            yylval.strval = new char[strlen(yytext) - 1];
            strncpy(yylval.strval, yytext + 1, strlen(yytext) - 2);
            yylval.strval[strlen(yytext) - 2] = 0;
            return RelParser::STRING_;
          }
          YY_BREAK
        case 37:
          YY_RULE_SETUP
#line 167 "RelLexer.l"
          {
            int len = strlen(yytext);
            if (((len > 2) && !strncasecmp("yes", yytext, 3)) ||
                ((len > 3) && !strncasecmp("true", yytext, 4))) {
              yylval.ival = 1;
              return RelParser::INTNUMBER_;
            }
            if (((len > 1) && !strncasecmp("no", yytext, 2)) ||
                ((len > 4) && !strncasecmp("false", yytext, 5))) {
              yylval.ival = 0;
              return RelParser::INTNUMBER_;
            }

            yylval.strval = new char[strlen(yytext) + 1];
            strncpy(yylval.strval, yytext, strlen(yytext));
            yylval.strval[strlen(yytext)] = 0;
            return RelParser::STRING_;
          }
          YY_BREAK
        case 38:
          YY_RULE_SETUP
#line 188 "RelLexer.l"
          {
            // HEX NUMBER
            yytext[strlen(yytext) - 1] = '\n';
            if (!sscanf(yytext, "%9x", &(yylval.ival))) {
              Log(Crit) << "Hex value [" << yytext << " parsing failed." << LogEnd;
              YYABORT;
            }
            return RelParser::HEXNUMBER_;
          }
          YY_BREAK
        case 39:
          YY_RULE_SETUP
#line 198 "RelLexer.l"
          {
            if (!sscanf(yytext, "%9u", &(yylval.ival))) {
              Log(Crit) << "Decimal value [" << yytext << " parsing failed." << LogEnd;
              YYABORT;
            }
            return RelParser::INTNUMBER_;
          }
          YY_BREAK
        case 40:
          YY_RULE_SETUP
#line 206 "RelLexer.l"
          {
            // DUID in 0x010203 format
            int len;
            char *ptr;
            if (strlen(yytext) % 2) {
              yytext[1] = '0';  // if odd then no-meaning zero at the beginning
              len = strlen(yytext) - 1;
              ptr = yytext + 1;
            } else {
              len = strlen(yytext) - 2;
              ptr = yytext + 2;
            }

            // and now there is an even number of hex digits
            yylval.duidval.length = len >> 1;
            yylval.duidval.duid = new char[len >> 1];
            for (int i = 0; i < len; i++) {
              yylval.duidval.duid[i >> 1] <<= 4;
              if (!isxdigit(ptr[i])) {
                Log(Crit) << "DUID parsing failed (" << yytext << ")." << LogEnd;
                YYABORT;
              }
              if (isalpha(ptr[i])) {
                yylval.duidval.duid[i >> 1] |= toupper(ptr[i]) - 'A' + 10;
              } else {
                yylval.duidval.duid[i >> 1] |= ptr[i] - '0';
              }
            }
            return RelParser::DUID_;
          }
          YY_BREAK
        case 41:
          YY_RULE_SETUP
#line 238 "RelLexer.l"
          {
            // DUID in 00:01:02:03 format
            int len = (strlen(yytext) + 1) / 3;
            char *pos = 0;
            yylval.duidval.length = len;
            yylval.duidval.duid = new char[len];

            int i = 0;
            for (pos = yytext; pos <= yytext + strlen(yytext) - 2; pos += 3) {
              char x;
              if (isalpha(*pos))
                x = (toupper(*pos) - 'A' + 10);
              else
                x = *pos - '0';
              x *= 16;

              if (isalpha(*(pos + 1)))
                x += (toupper(*(pos + 1)) - 'A' + 10);
              else
                x += *(pos + 1) - '0';
              yylval.duidval.duid[i] = x;
              i++;
            }

            return RelParser::DUID_;
          }
          YY_BREAK
        case 42:
          YY_RULE_SETUP
#line 266 "RelLexer.l"
          {
            return yytext[0];
          }
          YY_BREAK
        case 43:
          YY_RULE_SETUP
#line 269 "RelLexer.l"
          ECHO;
          YY_BREAK
#line 1544 "RelLexer.cpp"
        case YY_STATE_EOF(INITIAL):
        case YY_STATE_EOF(ADDR):
          yyterminate();

        case YY_END_OF_BUFFER: {
          /* Amount of text matched not including the EOB char. */
          int yy_amount_of_matched_text = (int)(yy_cp - (yytext_ptr)) - 1;

          /* Undo the effects of YY_DO_BEFORE_ACTION. */
          *yy_cp = (yy_hold_char);
          YY_RESTORE_YY_MORE_OFFSET

          if (YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW) {
            /* We're scanning a new file or input source.  It's
             * possible that this happened because the user
             * just pointed yyin at a new source and called
             * yylex().  If so, then we have to assure
             * consistency between YY_CURRENT_BUFFER and our
             * globals.  Here is the right place to do so, because
             * this is the first action (other than possibly a
             * back-up) that will match for the new input source.
             */
            (yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
            YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
            YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
          }

          /* Note that here we test for yy_c_buf_p "<=" to the position
           * of the first EOB in the buffer, since yy_c_buf_p will
           * already have been incremented past the NUL character
           * (since all states make transitions on EOB to the
           * end-of-buffer state).  Contrast this with the test
           * in input().
           */
          if ((yy_c_buf_p) <=
              &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)]) { /* This was really a NUL. */
            yy_state_type yy_next_state;

            (yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;

            yy_current_state = yy_get_previous_state();

            /* Okay, we're now positioned to make the NUL
             * transition.  We couldn't have
             * yy_get_previous_state() go ahead and do it
             * for us because it doesn't know how to deal
             * with the possibility of jamming (and we don't
             * want to build jamming into it because then it
             * will run more slowly).
             */

            yy_next_state = yy_try_NUL_trans(yy_current_state);

            yy_bp = (yytext_ptr) + YY_MORE_ADJ;

            if (yy_next_state) {
              /* Consume the NUL. */
              yy_cp = ++(yy_c_buf_p);
              yy_current_state = yy_next_state;
              goto yy_match;
            }

            else {
              yy_cp = (yy_c_buf_p);
              goto yy_find_action;
            }
          }

          else
            switch (yy_get_next_buffer()) {
              case EOB_ACT_END_OF_FILE: {
                (yy_did_buffer_switch_on_eof) = 0;

                if (yywrap()) {
                  /* Note: because we've taken care in
                   * yy_get_next_buffer() to have set up
                   * yytext, we can now set up
                   * yy_c_buf_p so that if some total
                   * hoser (like flex itself) wants to
                   * call the scanner after we return the
                   * YY_NULL, it'll still work - another
                   * YY_NULL will get returned.
                   */
                  (yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;

                  yy_act = YY_STATE_EOF(YY_START);
                  goto do_action;
                }

                else {
                  if (!(yy_did_buffer_switch_on_eof)) YY_NEW_FILE;
                }
                break;
              }

              case EOB_ACT_CONTINUE_SCAN:
                (yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;

                yy_current_state = yy_get_previous_state();

                yy_cp = (yy_c_buf_p);
                yy_bp = (yytext_ptr) + YY_MORE_ADJ;
                goto yy_match;

              case EOB_ACT_LAST_MATCH:
                (yy_c_buf_p) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];

                yy_current_state = yy_get_previous_state();

                yy_cp = (yy_c_buf_p);
                yy_bp = (yytext_ptr) + YY_MORE_ADJ;
                goto yy_find_action;
            }
          break;
        }

        default:
          YY_FATAL_ERROR("fatal flex scanner internal error--no action found");
      } /* end of action switch */
    }   /* end of scanning one token */
  }     /* end of user's declarations */
} /* end of yylex */

/* The contents of this function are C++ specific, so the () macro is not used.
 */
yyFlexLexer::yyFlexLexer(std::istream *arg_yyin, std::ostream *arg_yyout) {
  yyin = arg_yyin;
  yyout = arg_yyout;
  yy_c_buf_p = 0;
  yy_init = 0;
  yy_start = 0;
  yy_flex_debug = 0;
  yylineno = 1;  // this will only get updated if %option yylineno

  yy_did_buffer_switch_on_eof = 0;

  yy_looking_for_trail_begin = 0;
  yy_more_flag = 0;
  yy_more_len = 0;
  yy_more_offset = yy_prev_more_offset = 0;

  yy_start_stack_ptr = yy_start_stack_depth = 0;
  yy_start_stack = NULL;

  yy_buffer_stack = 0;
  yy_buffer_stack_top = 0;
  yy_buffer_stack_max = 0;

  yy_state_buf = 0;
}

/* The contents of this function are C++ specific, so the () macro is not used.
 */
yyFlexLexer::~yyFlexLexer() {
  delete[] yy_state_buf;
  yyfree(yy_start_stack);
  yy_delete_buffer(YY_CURRENT_BUFFER);
  yyfree(yy_buffer_stack);
}

/* The contents of this function are C++ specific, so the () macro is not used.
 */
void yyFlexLexer::switch_streams(std::istream *new_in, std::ostream *new_out) {
  if (new_in) {
    yy_delete_buffer(YY_CURRENT_BUFFER);
    yy_switch_to_buffer(yy_create_buffer(new_in, YY_BUF_SIZE));
  }

  if (new_out) yyout = new_out;
}

#ifdef YY_INTERACTIVE
int yyFlexLexer::LexerInput(char *buf, int /* max_size */)
#else
int yyFlexLexer::LexerInput(char *buf, int max_size)
#endif
{
  if (yyin->eof() || yyin->fail()) return 0;

#ifdef YY_INTERACTIVE
  yyin->get(buf[0]);

  if (yyin->eof()) return 0;

  if (yyin->bad()) return -1;

  return 1;

#else
  (void)yyin->read(buf, max_size);

  if (yyin->bad())
    return -1;
  else
    return yyin->gcount();
#endif
}

void yyFlexLexer::LexerOutput(const char *buf, int size) { (void)yyout->write(buf, size); }

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *	EOB_ACT_LAST_MATCH -
 *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *	EOB_ACT_END_OF_FILE - end of file
 */
int yyFlexLexer::yy_get_next_buffer() {
  register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
  register char *source = (yytext_ptr);
  register int number_to_move, i;
  int ret_val;

  if ((yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1])
    YY_FATAL_ERROR("fatal flex scanner internal error--end of buffer missed");

  if (YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0) { /* Don't try to fill the buffer, so this is
                                                          an EOF. */
    if ((yy_c_buf_p) - (yytext_ptr)-YY_MORE_ADJ == 1) {
      /* We matched a single character, the EOB, so
       * treat this as a final EOF.
       */
      return EOB_ACT_END_OF_FILE;
    }

    else {
      /* We matched some text prior to the EOB, first
       * process it.
       */
      return EOB_ACT_LAST_MATCH;
    }
  }

  /* Try to read more data. */

  /* First move last chars to start of buffer. */
  number_to_move = (int)((yy_c_buf_p) - (yytext_ptr)) - 1;

  for (i = 0; i < number_to_move; ++i) *(dest++) = *(source++);

  if (YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING)
    /* don't do the read, it's not guaranteed to return an EOF,
     * just force an EOF
     */
    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;

  else {
    yy_size_t num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

    while (num_to_read <= 0) { /* Not enough room in the buffer - grow it. */

      /* just a shorter name for the current buffer */
      YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;

      int yy_c_buf_p_offset = (int)((yy_c_buf_p)-b->yy_ch_buf);

      if (b->yy_is_our_buffer) {
        yy_size_t new_size = b->yy_buf_size * 2;

        if (new_size <= 0)
          b->yy_buf_size += b->yy_buf_size / 8;
        else
          b->yy_buf_size *= 2;

        b->yy_ch_buf = (char *)
            /* Include room in for 2 EOB chars. */
            yyrealloc((void *)b->yy_ch_buf, b->yy_buf_size + 2);
      } else
        /* Can't grow it, we don't own it. */
        b->yy_ch_buf = 0;

      if (!b->yy_ch_buf) YY_FATAL_ERROR("fatal error - scanner input buffer overflow");

      (yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];

      num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
    }

    if (num_to_read > YY_READ_BUF_SIZE) num_to_read = YY_READ_BUF_SIZE;

    /* Read in more data. */
    YY_INPUT((&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]), (yy_n_chars), num_to_read);

    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
  }

  if ((yy_n_chars) == 0) {
    if (number_to_move == YY_MORE_ADJ) {
      ret_val = EOB_ACT_END_OF_FILE;
      yyrestart(yyin);
    }

    else {
      ret_val = EOB_ACT_LAST_MATCH;
      YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_EOF_PENDING;
    }
  }

  else
    ret_val = EOB_ACT_CONTINUE_SCAN;

  if ((yy_size_t)((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
    /* Extend the array by 50%, plus the number we really need. */
    yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
    YY_CURRENT_BUFFER_LVALUE->yy_ch_buf =
        (char *)yyrealloc((void *)YY_CURRENT_BUFFER_LVALUE->yy_ch_buf, new_size);
    if (!YY_CURRENT_BUFFER_LVALUE->yy_ch_buf)
      YY_FATAL_ERROR("out of dynamic memory in yy_get_next_buffer()");
  }

  (yy_n_chars) += number_to_move;
  YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
  YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;

  (yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

  return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

yy_state_type yyFlexLexer::yy_get_previous_state() {
  register yy_state_type yy_current_state;
  register char *yy_cp;

  yy_current_state = (yy_start);

  for (yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp) {
    register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
    if (yy_accept[yy_current_state]) {
      (yy_last_accepting_state) = yy_current_state;
      (yy_last_accepting_cpos) = yy_cp;
    }
    while (yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state) {
      yy_current_state = (int)yy_def[yy_current_state];
      if (yy_current_state >= 433) yy_c = yy_meta[(unsigned int)yy_c];
    }
    yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int)yy_c];
  }

  return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *	next_state = yy_try_NUL_trans( current_state );
 */
yy_state_type yyFlexLexer::yy_try_NUL_trans(yy_state_type yy_current_state) {
  register int yy_is_jam;
  register char *yy_cp = (yy_c_buf_p);

  register YY_CHAR yy_c = 1;
  if (yy_accept[yy_current_state]) {
    (yy_last_accepting_state) = yy_current_state;
    (yy_last_accepting_cpos) = yy_cp;
  }
  while (yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state) {
    yy_current_state = (int)yy_def[yy_current_state];
    if (yy_current_state >= 433) yy_c = yy_meta[(unsigned int)yy_c];
  }
  yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int)yy_c];
  yy_is_jam = (yy_current_state == 432);

  return yy_is_jam ? 0 : yy_current_state;
}

void yyFlexLexer::yyunput(int c, register char *yy_bp) {
  register char *yy_cp;

  yy_cp = (yy_c_buf_p);

  /* undo effects of setting up yytext */
  *yy_cp = (yy_hold_char);

  if (yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2) { /* need to shift things up to make room */
    /* +2 for EOB chars. */
    register yy_size_t number_to_move = (yy_n_chars) + 2;
    register char *dest =
        &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
    register char *source = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];

    while (source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf) *--dest = *--source;

    yy_cp += (int)(dest - source);
    yy_bp += (int)(dest - source);
    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;

    if (yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2)
      YY_FATAL_ERROR("flex scanner push-back overflow");
  }

  *--yy_cp = (char)c;

  if (c == '\n') {
    --yylineno;
  }

  (yytext_ptr) = yy_bp;
  (yy_hold_char) = *yy_cp;
  (yy_c_buf_p) = yy_cp;
}

int yyFlexLexer::yyinput() {
  int c;

  *(yy_c_buf_p) = (yy_hold_char);

  if (*(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR) {
    /* yy_c_buf_p now points to the character we want to return.
     * If this occurs *before* the EOB characters, then it's a
     * valid NUL; if not, then we've hit the end of the buffer.
     */
    if ((yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)])
      /* This was really a NUL. */
      *(yy_c_buf_p) = '\0';

    else { /* need more input */
      yy_size_t offset = (yy_c_buf_p) - (yytext_ptr);
      ++(yy_c_buf_p);

      switch (yy_get_next_buffer()) {
        case EOB_ACT_LAST_MATCH:
          /* This happens because yy_g_n_b()
           * sees that we've accumulated a
           * token and flags that we need to
           * try matching the token before
           * proceeding.  But for input(),
           * there's no matching to consider.
           * So convert the EOB_ACT_LAST_MATCH
           * to EOB_ACT_END_OF_FILE.
           */

          /* Reset buffer status. */
          yyrestart(yyin);

          /*FALLTHROUGH*/

        case EOB_ACT_END_OF_FILE: {
          if (yywrap()) return EOF;

          if (!(yy_did_buffer_switch_on_eof)) YY_NEW_FILE;
#ifdef __cplusplus
          return yyinput();
#else
          return input();
#endif
        }

        case EOB_ACT_CONTINUE_SCAN:
          (yy_c_buf_p) = (yytext_ptr) + offset;
          break;
      }
    }
  }

  c = *(unsigned char *)(yy_c_buf_p); /* cast for 8-bit char's */
  *(yy_c_buf_p) = '\0';               /* preserve yytext */
  (yy_hold_char) = *++(yy_c_buf_p);

  if (c == '\n') yylineno++;
  ;

  return c;
}

/** Immediately switch to a different input stream.
 * @param input_file A readable stream.
 *
 * @note This function does not reset the start condition to @c INITIAL .
 */
void yyFlexLexer::yyrestart(std::istream *input_file) {

  if (!YY_CURRENT_BUFFER) {
    yyensure_buffer_stack();
    YY_CURRENT_BUFFER_LVALUE = yy_create_buffer(yyin, YY_BUF_SIZE);
  }

  yy_init_buffer(YY_CURRENT_BUFFER, input_file);
  yy_load_buffer_state();
}

/** Switch to a different input buffer.
 * @param new_buffer The new input buffer.
 *
 */
void yyFlexLexer::yy_switch_to_buffer(YY_BUFFER_STATE new_buffer) {

  /* TODO. We should be able to replace this entire function body
   * with
   *		yypop_buffer_state();
   *		yypush_buffer_state(new_buffer);
   */
  yyensure_buffer_stack();
  if (YY_CURRENT_BUFFER == new_buffer) return;

  if (YY_CURRENT_BUFFER) {
    /* Flush out information for old buffer. */
    *(yy_c_buf_p) = (yy_hold_char);
    YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
  }

  YY_CURRENT_BUFFER_LVALUE = new_buffer;
  yy_load_buffer_state();

  /* We don't actually know whether we did this switch during
   * EOF (yywrap()) processing, but the only time this flag
   * is looked at is after yywrap() is called, so it's safe
   * to go ahead and always set it.
   */
  (yy_did_buffer_switch_on_eof) = 1;
}

void yyFlexLexer::yy_load_buffer_state() {
  (yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
  (yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
  yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
  (yy_hold_char) = *(yy_c_buf_p);
}

/** Allocate and initialize an input buffer state.
 * @param file A readable stream.
 * @param size The character buffer size in bytes. When in doubt, use @c
 * YY_BUF_SIZE.
 *
 * @return the allocated buffer state.
 */
YY_BUFFER_STATE yyFlexLexer::yy_create_buffer(std::istream *file, int size) {
  YY_BUFFER_STATE b;

  b = (YY_BUFFER_STATE)yyalloc(sizeof(struct yy_buffer_state));
  if (!b) YY_FATAL_ERROR("out of dynamic memory in yy_create_buffer()");

  b->yy_buf_size = size;

  /* yy_ch_buf has to be 2 characters longer than the size given because
   * we need to put in 2 end-of-buffer characters.
   */
  b->yy_ch_buf = (char *)yyalloc(b->yy_buf_size + 2);
  if (!b->yy_ch_buf) YY_FATAL_ERROR("out of dynamic memory in yy_create_buffer()");

  b->yy_is_our_buffer = 1;

  yy_init_buffer(b, file);

  return b;
}

/** Destroy the buffer.
 * @param b a buffer created with yy_create_buffer()
 *
 */
void yyFlexLexer::yy_delete_buffer(YY_BUFFER_STATE b) {

  if (!b) return;

  if (b == YY_CURRENT_BUFFER) /* Not sure if we should pop here. */
    YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE)0;

  if (b->yy_is_our_buffer) yyfree((void *)b->yy_ch_buf);

  yyfree((void *)b);
}

/* Initializes or reinitializes a buffer.
 * This function is sometimes called more than once on the same buffer,
 * such as during a yyrestart() or at EOF.
 */
void yyFlexLexer::yy_init_buffer(YY_BUFFER_STATE b, std::istream *file)

{
  int oerrno = errno;

  yy_flush_buffer(b);

  b->yy_input_file = file;
  b->yy_fill_buffer = 1;

  /* If b is the current buffer, then yy_init_buffer was _probably_
   * called from yyrestart() or through yy_get_next_buffer.
   * In that case, we don't want to reset the lineno or column.
   */
  if (b != YY_CURRENT_BUFFER) {
    b->yy_bs_lineno = 1;
    b->yy_bs_column = 0;
  }

  b->yy_is_interactive = 0;
  errno = oerrno;
}

/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
 * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
 *
 */
void yyFlexLexer::yy_flush_buffer(YY_BUFFER_STATE b) {
  if (!b) return;

  b->yy_n_chars = 0;

  /* We always need two end-of-buffer characters.  The first causes
   * a transition to the end-of-buffer state.  The second causes
   * a jam in that state.
   */
  b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
  b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;

  b->yy_buf_pos = &b->yy_ch_buf[0];

  b->yy_at_bol = 1;
  b->yy_buffer_status = YY_BUFFER_NEW;

  if (b == YY_CURRENT_BUFFER) yy_load_buffer_state();
}

/** Pushes the new state onto the stack. The new state becomes
 *  the current state. This function will allocate the stack
 *  if necessary.
 *  @param new_buffer The new state.
 *
 */
void yyFlexLexer::yypush_buffer_state(YY_BUFFER_STATE new_buffer) {
  if (new_buffer == NULL) return;

  yyensure_buffer_stack();

  /* This block is copied from yy_switch_to_buffer. */
  if (YY_CURRENT_BUFFER) {
    /* Flush out information for old buffer. */
    *(yy_c_buf_p) = (yy_hold_char);
    YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
  }

  /* Only push if top exists. Otherwise, replace top. */
  if (YY_CURRENT_BUFFER) (yy_buffer_stack_top)++;
  YY_CURRENT_BUFFER_LVALUE = new_buffer;

  /* copied from yy_switch_to_buffer. */
  yy_load_buffer_state();
  (yy_did_buffer_switch_on_eof) = 1;
}

/** Removes and deletes the top of the stack, if present.
 *  The next element becomes the new top.
 *
 */
void yyFlexLexer::yypop_buffer_state(void) {
  if (!YY_CURRENT_BUFFER) return;

  yy_delete_buffer(YY_CURRENT_BUFFER);
  YY_CURRENT_BUFFER_LVALUE = NULL;
  if ((yy_buffer_stack_top) > 0) --(yy_buffer_stack_top);

  if (YY_CURRENT_BUFFER) {
    yy_load_buffer_state();
    (yy_did_buffer_switch_on_eof) = 1;
  }
}

/* Allocates the stack if it does not exist.
 *  Guarantees space for at least one push.
 */
void yyFlexLexer::yyensure_buffer_stack(void) {
  yy_size_t num_to_alloc;

  if (!(yy_buffer_stack)) {

    /* First allocation is just for 2 elements, since we don't know if this
     * scanner will even need a stack. We use 2 instead of 1 to avoid an
     * immediate realloc on the next call.
     */
    num_to_alloc = 1;
    (yy_buffer_stack) =
        (struct yy_buffer_state **)yyalloc(num_to_alloc * sizeof(struct yy_buffer_state *));
    if (!(yy_buffer_stack)) YY_FATAL_ERROR("out of dynamic memory in yyensure_buffer_stack()");

    memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state *));

    (yy_buffer_stack_max) = num_to_alloc;
    (yy_buffer_stack_top) = 0;
    return;
  }

  if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1) {

    /* Increase the buffer to prepare for a possible push. */
    int grow_size = 8 /* arbitrary grow size */;

    num_to_alloc = (yy_buffer_stack_max) + grow_size;
    (yy_buffer_stack) = (struct yy_buffer_state **)yyrealloc(
        (yy_buffer_stack), num_to_alloc * sizeof(struct yy_buffer_state *));
    if (!(yy_buffer_stack)) YY_FATAL_ERROR("out of dynamic memory in yyensure_buffer_stack()");

    /* zero only the new slots.*/
    memset((yy_buffer_stack) + (yy_buffer_stack_max), 0,
           grow_size * sizeof(struct yy_buffer_state *));
    (yy_buffer_stack_max) = num_to_alloc;
  }
}

void yyFlexLexer::yy_push_state(int new_state) {
  if ((yy_start_stack_ptr) >= (yy_start_stack_depth)) {
    yy_size_t new_size;

    (yy_start_stack_depth) += YY_START_STACK_INCR;
    new_size = (yy_start_stack_depth) * sizeof(int);

    if (!(yy_start_stack))
      (yy_start_stack) = (int *)yyalloc(new_size);

    else
      (yy_start_stack) = (int *)yyrealloc((void *)(yy_start_stack), new_size);

    if (!(yy_start_stack)) YY_FATAL_ERROR("out of memory expanding start-condition stack");
  }

  (yy_start_stack)[(yy_start_stack_ptr)++] = YY_START;

  BEGIN(new_state);
}

void yyFlexLexer::yy_pop_state() {
  if (--(yy_start_stack_ptr) < 0) YY_FATAL_ERROR("start-condition stack underflow");

  BEGIN((yy_start_stack)[(yy_start_stack_ptr)]);
}

int yyFlexLexer::yy_top_state() { return (yy_start_stack)[(yy_start_stack_ptr)-1]; }

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

void yyFlexLexer::LexerError(yyconst char msg[]) {
  std::cerr << msg << std::endl;
  exit(YY_EXIT_FAILURE);
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n)                             \
  do {                                        \
    /* Undo effects of setting up yytext. */  \
    int yyless_macro_arg = (n);               \
    YY_LESS_LINENO(yyless_macro_arg);         \
    yytext[yyleng] = (yy_hold_char);          \
    (yy_c_buf_p) = yytext + yyless_macro_arg; \
    (yy_hold_char) = *(yy_c_buf_p);           \
    *(yy_c_buf_p) = '\0';                     \
    yyleng = yyless_macro_arg;                \
  } while (0)

/* Accessor  methods (get/set functions) to struct members. */

/*
 * Internal utility routines.
 */

#ifndef yytext_ptr
static void yy_flex_strncpy(char *s1, yyconst char *s2, int n) {
  register int i;
  for (i = 0; i < n; ++i) s1[i] = s2[i];
}
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen(yyconst char *s) {
  register int n;
  for (n = 0; s[n]; ++n)
    ;

  return n;
}
#endif

void *yyalloc(yy_size_t size) { return (void *)malloc(size); }

void *yyrealloc(void *ptr, yy_size_t size) {
  /* The cast to (char *) in the following accommodates both
   * implementations that use char* generic pointers, and those
   * that use void* generic pointers.  It works with the latter
   * because both ANSI C and C++ allow castless assignment from
   * any pointer type to void*, and deal with argument conversions
   * as though doing an assignment.
   */
  return (void *)realloc((char *)ptr, size);
}

void yyfree(void *ptr) { free((char *)ptr); /* see yyrealloc() for (char *) cast */ }

#define YYTABLES_NAME "yytables"

#line 268 "RelLexer.l"
