#define YY_SrvParser_h_included
#define YY_USE_CLASS

/*  A Bison++ parser, made from SrvParser.y  */

/* with Bison++ version bison++ Version 1.21.9-1, adapted from GNU bison by
coetmeur@icdc.fr Maintained by Magnus Ekdahl <magnus@debian.org>
 */

#define YY_USE_CLASS

#line 1 "../bison++/bison.cc"
/* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
/* Skeleton output parser for bison,
   Copyright (C) 1984, 1989, 1990 Bob Corbett and Richard Stallman

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 1, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

   As a special exception, when this file is copied by Bison++ into a
   Bison++ output file, you may use that output file without restriction.
   This special exception was added by the Free Software Foundation
   in version 1.24 of Bison, and has been in Bison++ since 1.21.9.

*/

/* HEADER SECTION */
#if defined(_MSDOS) || defined(MSDOS) || defined(__MSDOS__)
#define __MSDOS_AND_ALIKE
#endif

#if defined(_WINDOWS) && defined(_MSC_VER)
#define __HAVE_NO_ALLOCA
#define __MSDOS_AND_ALIKE
#endif

#ifndef alloca
#if defined(__GNUC__)
#define alloca __builtin_alloca

#elif (!defined(__STDC__) && defined(sparc)) || defined(__sparc__) || defined(__sparc) || \
    defined(__sgi)
#include <alloca.h>

#elif defined(__MSDOS_AND_ALIKE)
#include <malloc.h>
#ifndef __TURBOC__
/* MS C runtime lib */
#define alloca _alloca
#endif

#elif defined(_AIX)
/* pragma must be put before any C/C++ instruction !! */
#pragma alloca
#include <malloc.h>

#elif defined(__hpux)
#ifdef __cplusplus
extern "C" {
void *alloca(unsigned int);
};
#else  /* not __cplusplus */
void *alloca();
#endif /* not __cplusplus */

#endif /* not _AIX  not MSDOS, or __TURBOC__ or _AIX, not sparc.  */
#endif /* alloca not defined.  */

#ifdef c_plusplus
#ifndef __cplusplus
#define __cplusplus
#endif
#endif

#ifdef __cplusplus
#ifndef YY_USE_CLASS
/*#warning "For C++ its recomended to use bison++, otherwise classes won't be
 * generated"*/
#endif
#else
#ifndef __STDC__
#define const
#endif
#ifdef YY_USE_CLASS
#error "This is a C++ header generated by bison++, please use a C++ compiler!"
#endif
#endif

#include <stdio.h>
#define YYBISON 1

#line 88 "../bison++/bison.cc"
#line 3 "SrvParser.y"

#include "Container.h"
#include "DHCPConst.h"
#include "DUID.h"
#include "FQDN.h"
#include "Key.h"
#include "Logger.h"
#include "Node.h"
#include "NodeClientSpecific.h"
#include "NodeConstant.h"
#include "NodeOperator.h"
#include "OptAddr.h"
#include "OptAddrLst.h"
#include "OptDomainLst.h"
#include "OptRtPrefix.h"
#include "OptString.h"
#include "OptVendorSpecInfo.h"
#include "Portable.h"
#include "SmartPtr.h"
#include "SrvCfgAddrClass.h"
#include "SrvCfgClientClass.h"
#include "SrvCfgIface.h"
#include "SrvCfgMgr.h"
#include "SrvCfgOptions.h"
#include "SrvCfgPD.h"
#include "SrvCfgTA.h"
#include "SrvOptAddrParams.h"
#include "SrvParsClassOpt.h"
#include "SrvParsGlobalOpt.h"
#include "SrvParsIfaceOpt.h"
#include "SrvParser.h"
#include <iostream>
#include <sstream>
#include <stdint.h>
#include <string>

using namespace std;

#define YY_USE_CLASS
#line 44 "SrvParser.y"

#include "FlexLexer.h"
#define YY_SrvParser_MEMBERS                                                               \
  FlexLexer *lex;                                                                          \
  List(TSrvParsGlobalOpt) ParserOptStack;        /* list of parsed interfaces/IAs/addrs */ \
  List(TSrvCfgIface) SrvCfgIfaceLst;             /* list of SrvCfg interfaces */           \
  List(TSrvCfgAddrClass) SrvCfgAddrClassLst;     /* list of SrvCfg address classes */      \
  List(TSrvCfgTA) SrvCfgTALst;                   /* list of SrvCfg TA objects */           \
  List(TSrvCfgPD) SrvCfgPDLst;                   /* list of SrvCfg PD objects */           \
  List(TSrvCfgClientClass) SrvCfgClientClassLst; /* list of SrvCfgClientClass objs */      \
  List(TIPv6Addr) PresentAddrLst;                /* address list (used for DNS,NTP,etc.)*/ \
  List(std::string) PresentStringLst;            /* string list */                         \
  List(Node) NodeClientClassLst;                 /* Node list */                           \
  List(TFQDN) PresentFQDNLst;                                                              \
  SPtr<TIPv6Addr> addr;                                                                    \
  SPtr<TSIGKey> CurrentKey;                                                                \
  DigestTypesLst DigestLst;                                                                \
  List(THostRange) PresentRangeLst;                                                        \
  List(THostRange) PDLst;                                                                  \
  List(TSrvCfgOptions) ClientLst;                                                          \
  int PDPrefix;                                                                            \
  bool IfaceDefined(int ifaceNr);                                                          \
  bool IfaceDefined(string ifaceName);                                                     \
  bool StartIfaceDeclaration(string iface);                                                \
  bool StartIfaceDeclaration(int ifindex);                                                 \
  bool EndIfaceDeclaration();                                                              \
  void StartClassDeclaration();                                                            \
  bool EndClassDeclaration();                                                              \
  SPtr<TIPv6Addr> getRangeMin(char *addrPacked, int prefix);                               \
  SPtr<TIPv6Addr> getRangeMax(char *addrPacked, int prefix);                               \
  void StartTAClassDeclaration();                                                          \
  bool EndTAClassDeclaration();                                                            \
  void StartPDDeclaration();                                                               \
  bool EndPDDeclaration();                                                                 \
  TSrvCfgMgr *CfgMgr;                                                                      \
  SPtr<TOpt> nextHop;                                                                      \
  virtual ~SrvParser();
#define YY_SrvParser_CONSTRUCTOR_PARAM yyFlexLexer *lex
#define YY_SrvParser_CONSTRUCTOR_CODE             \
  ParserOptStack.append(new TSrvParsGlobalOpt()); \
  this->lex = lex;                                \
  CfgMgr = 0;                                     \
  nextHop.reset();                                \
  yynerrs = 0;                                    \
  yychar = 0;                                     \
  PDPrefix = 0;

#line 95 "SrvParser.y"
typedef union {
  unsigned int ival;
  char *strval;
  struct SDuid {
    int length;
    char *duid;
  } duidval;
  char addrval[16];
} yy_SrvParser_stype;
#define YY_SrvParser_STYPE yy_SrvParser_stype

#line 88 "../bison++/bison.cc"
/* %{ and %header{ and %union, during decl */
#define YY_SrvParser_BISON 1

#ifndef YY_SrvParser_COMPATIBILITY
#ifndef YY_USE_CLASS
#define YY_SrvParser_COMPATIBILITY 1
#else
#define YY_SrvParser_COMPATIBILITY 0
#endif
#endif

#if YY_SrvParser_COMPATIBILITY != 0
/* backward compatibility */
#ifdef YYLTYPE
#ifndef YY_SrvParser_LTYPE
#define YY_SrvParser_LTYPE YYLTYPE
#endif
#endif
/* Testing alternative bison solution
   /#ifdef YYSTYPE*/
#ifndef YY_SrvParser_STYPE
#define YY_SrvParser_STYPE YYSTYPE
#endif
/*#endif*/
#ifdef YYDEBUG
#ifndef YY_SrvParser_DEBUG
#define YY_SrvParser_DEBUG YYDEBUG
#endif
#endif

/* use goto to be compatible */
#ifndef YY_SrvParser_USE_GOTO
#define YY_SrvParser_USE_GOTO 1
#endif
#endif

/* use no goto to be clean in C++ */
#ifndef YY_SrvParser_USE_GOTO
#define YY_SrvParser_USE_GOTO 0
#endif

#ifndef YY_SrvParser_PURE

#line 130 "../bison++/bison.cc"

#line 130 "../bison++/bison.cc"
/*  YY_SrvParser_PURE */
#endif

/* section apres lecture def, avant lecture grammaire S2 */

#line 134 "../bison++/bison.cc"

#line 134 "../bison++/bison.cc"
/* prefix */
#ifndef YY_SrvParser_DEBUG

#line 136 "../bison++/bison.cc"
#define YY_SrvParser_DEBUG 1

#line 136 "../bison++/bison.cc"
/* YY_SrvParser_DEBUG */
#endif

#ifndef YY_SrvParser_LSP_NEEDED

#line 141 "../bison++/bison.cc"

#line 141 "../bison++/bison.cc"
/* YY_SrvParser_LSP_NEEDED*/
#endif

/* DEFAULT LTYPE*/
#ifdef YY_SrvParser_LSP_NEEDED
#ifndef YY_SrvParser_LTYPE
#ifndef BISON_YYLTYPE_ISDECLARED
#define BISON_YYLTYPE_ISDECLARED
typedef struct yyltype {
  int timestamp;
  int first_line;
  int first_column;
  int last_line;
  int last_column;
  char *text;
} yyltype;

#endif
#define YY_SrvParser_LTYPE yyltype
#endif
#endif
/* DEFAULT STYPE*/
/* We used to use `unsigned long' as YY_SrvParser_STYPE on MSDOS,
   but it seems better to be consistent.
   Most programs should declare their own type anyway.  */

#ifndef YY_SrvParser_STYPE
#define YY_SrvParser_STYPE int
#endif
/* DEFAULT MISCELANEOUS */
#ifndef YY_SrvParser_PARSE
#define YY_SrvParser_PARSE yyparse
#endif
#ifndef YY_SrvParser_LEX
#define YY_SrvParser_LEX yylex
#endif
#ifndef YY_SrvParser_LVAL
#define YY_SrvParser_LVAL yylval
#endif
#ifndef YY_SrvParser_LLOC
#define YY_SrvParser_LLOC yylloc
#endif
#ifndef YY_SrvParser_CHAR
#define YY_SrvParser_CHAR yychar
#endif
#ifndef YY_SrvParser_NERRS
#define YY_SrvParser_NERRS yynerrs
#endif
#ifndef YY_SrvParser_DEBUG_FLAG
#define YY_SrvParser_DEBUG_FLAG yydebug
#endif
#ifndef YY_SrvParser_ERROR
#define YY_SrvParser_ERROR yyerror
#endif

#ifndef YY_SrvParser_PARSE_PARAM
#ifndef YY_USE_CLASS
#ifdef YYPARSE_PARAM
#define YY_SrvParser_PARSE_PARAM void *YYPARSE_PARAM
#else
#ifndef __STDC__
#ifndef __cplusplus
#define YY_SrvParser_PARSE_PARAM
#endif
#endif
#endif
#endif
#ifndef YY_SrvParser_PARSE_PARAM
#define YY_SrvParser_PARSE_PARAM void
#endif
#endif

#if YY_SrvParser_COMPATIBILITY != 0
/* backward compatibility */
#ifdef YY_SrvParser_LTYPE
#ifndef YYLTYPE
#define YYLTYPE YY_SrvParser_LTYPE
#else
/* WARNING obsolete !!! user defined YYLTYPE not reported into generated header
 */
#endif
#endif

/* Removed due to bison compabilityproblems
/#ifndef YYSTYPE
/#define YYSTYPE YY_SrvParser_STYPE
/#else*/
/* WARNING obsolete !!! user defined YYSTYPE not reported into generated header
 */
/*#endif*/

#ifdef YY_SrvParser_PURE
#ifndef YYPURE
#define YYPURE YY_SrvParser_PURE
#endif
#endif

#ifdef YY_SrvParser_DEBUG
#ifndef YYDEBUG
#define YYDEBUG YY_SrvParser_DEBUG
#endif
#endif

#ifndef YY_SrvParser_ERROR_VERBOSE
#ifdef YYERROR_VERBOSE
#define YY_SrvParser_ERROR_VERBOSE YYERROR_VERBOSE
#endif
#endif

#ifndef YY_SrvParser_LSP_NEEDED
#ifdef YYLSP_NEEDED
#define YY_SrvParser_LSP_NEEDED YYLSP_NEEDED
#endif
#endif

#endif

#ifndef YY_USE_CLASS
/* TOKEN C */

#line 263 "../bison++/bison.cc"
#define IFACE_ 258
#define RELAY_ 259
#define IFACE_ID_ 260
#define IFACE_ID_ORDER_ 261
#define CLASS_ 262
#define TACLASS_ 263
#define LOGNAME_ 264
#define LOGLEVEL_ 265
#define LOGMODE_ 266
#define LOGCOLORS_ 267
#define WORKDIR_ 268
#define OPTION_ 269
#define DNS_SERVER_ 270
#define DOMAIN_ 271
#define NTP_SERVER_ 272
#define TIME_ZONE_ 273
#define SIP_SERVER_ 274
#define SIP_DOMAIN_ 275
#define NIS_SERVER_ 276
#define NIS_DOMAIN_ 277
#define NISP_SERVER_ 278
#define NISP_DOMAIN_ 279
#define LIFETIME_ 280
#define FQDN_ 281
#define ACCEPT_UNKNOWN_FQDN_ 282
#define FQDN_DDNS_ADDRESS_ 283
#define DDNS_PROTOCOL_ 284
#define DDNS_TIMEOUT_ 285
#define ACCEPT_ONLY_ 286
#define REJECT_CLIENTS_ 287
#define POOL_ 288
#define SHARE_ 289
#define T1_ 290
#define T2_ 291
#define PREF_TIME_ 292
#define VALID_TIME_ 293
#define UNICAST_ 294
#define DROP_UNICAST_ 295
#define PREFERENCE_ 296
#define RAPID_COMMIT_ 297
#define IFACE_MAX_LEASE_ 298
#define CLASS_MAX_LEASE_ 299
#define CLNT_MAX_LEASE_ 300
#define STATELESS_ 301
#define CACHE_SIZE_ 302
#define PDCLASS_ 303
#define PD_LENGTH_ 304
#define PD_POOL_ 305
#define SCRIPT_ 306
#define VENDOR_SPEC_ 307
#define CLIENT_ 308
#define DUID_KEYWORD_ 309
#define REMOTE_ID_ 310
#define LINK_LOCAL_ 311
#define ADDRESS_ 312
#define PREFIX_ 313
#define GUESS_MODE_ 314
#define INACTIVE_MODE_ 315
#define EXPERIMENTAL_ 316
#define ADDR_PARAMS_ 317
#define REMOTE_AUTOCONF_NEIGHBORS_ 318
#define AFTR_ 319
#define PERFORMANCE_MODE_ 320
#define AUTH_PROTOCOL_ 321
#define AUTH_ALGORITHM_ 322
#define AUTH_REPLAY_ 323
#define AUTH_METHODS_ 324
#define AUTH_DROP_UNAUTH_ 325
#define AUTH_REALM_ 326
#define KEY_ 327
#define SECRET_ 328
#define ALGORITHM_ 329
#define FUDGE_ 330
#define DIGEST_NONE_ 331
#define DIGEST_PLAIN_ 332
#define DIGEST_HMAC_MD5_ 333
#define DIGEST_HMAC_SHA1_ 334
#define DIGEST_HMAC_SHA224_ 335
#define DIGEST_HMAC_SHA256_ 336
#define DIGEST_HMAC_SHA384_ 337
#define DIGEST_HMAC_SHA512_ 338
#define ACCEPT_LEASEQUERY_ 339
#define BULKLQ_ACCEPT_ 340
#define BULKLQ_TCPPORT_ 341
#define BULKLQ_MAX_CONNS_ 342
#define BULKLQ_TIMEOUT_ 343
#define CLIENT_CLASS_ 344
#define MATCH_IF_ 345
#define EQ_ 346
#define AND_ 347
#define OR_ 348
#define CLIENT_VENDOR_SPEC_ENTERPRISE_NUM_ 349
#define CLIENT_VENDOR_SPEC_DATA_ 350
#define CLIENT_VENDOR_CLASS_EN_ 351
#define CLIENT_VENDOR_CLASS_DATA_ 352
#define RECONFIGURE_ENABLED_ 353
#define ALLOW_ 354
#define DENY_ 355
#define SUBSTRING_ 356
#define STRING_KEYWORD_ 357
#define ADDRESS_LIST_ 358
#define CONTAIN_ 359
#define NEXT_HOP_ 360
#define ROUTE_ 361
#define INFINITE_ 362
#define SUBNET_ 363
#define STRING_ 364
#define HEXNUMBER_ 365
#define INTNUMBER_ 366
#define IPV6ADDR_ 367
#define DUID_ 368

#line 263 "../bison++/bison.cc"
/* #defines tokens */
#else
/* CLASS */
#ifndef YY_SrvParser_CLASS
#define YY_SrvParser_CLASS SrvParser
#endif
#ifndef YY_SrvParser_INHERIT
#define YY_SrvParser_INHERIT
#endif
#ifndef YY_SrvParser_MEMBERS
#define YY_SrvParser_MEMBERS
#endif
#ifndef YY_SrvParser_LEX_BODY
#define YY_SrvParser_LEX_BODY
#endif
#ifndef YY_SrvParser_ERROR_BODY
#define YY_SrvParser_ERROR_BODY
#endif
#ifndef YY_SrvParser_CONSTRUCTOR_PARAM
#define YY_SrvParser_CONSTRUCTOR_PARAM
#endif
#ifndef YY_SrvParser_CONSTRUCTOR_CODE
#define YY_SrvParser_CONSTRUCTOR_CODE
#endif
#ifndef YY_SrvParser_CONSTRUCTOR_INIT
#define YY_SrvParser_CONSTRUCTOR_INIT
#endif
/* choose between enum and const */
#ifndef YY_SrvParser_USE_CONST_TOKEN
#define YY_SrvParser_USE_CONST_TOKEN 0
/* yes enum is more compatible with flex,  */
/* so by default we use it */
#endif
#if YY_SrvParser_USE_CONST_TOKEN != 0
#ifndef YY_SrvParser_ENUM_TOKEN
#define YY_SrvParser_ENUM_TOKEN yy_SrvParser_enum_token
#endif
#endif

class YY_SrvParser_CLASS YY_SrvParser_INHERIT {
 public:
#if YY_SrvParser_USE_CONST_TOKEN != 0
  /* static const int token ... */

#line 307 "../bison++/bison.cc"
  static const int IFACE_;
  static const int RELAY_;
  static const int IFACE_ID_;
  static const int IFACE_ID_ORDER_;
  static const int CLASS_;
  static const int TACLASS_;
  static const int LOGNAME_;
  static const int LOGLEVEL_;
  static const int LOGMODE_;
  static const int LOGCOLORS_;
  static const int WORKDIR_;
  static const int OPTION_;
  static const int DNS_SERVER_;
  static const int DOMAIN_;
  static const int NTP_SERVER_;
  static const int TIME_ZONE_;
  static const int SIP_SERVER_;
  static const int SIP_DOMAIN_;
  static const int NIS_SERVER_;
  static const int NIS_DOMAIN_;
  static const int NISP_SERVER_;
  static const int NISP_DOMAIN_;
  static const int LIFETIME_;
  static const int FQDN_;
  static const int ACCEPT_UNKNOWN_FQDN_;
  static const int FQDN_DDNS_ADDRESS_;
  static const int DDNS_PROTOCOL_;
  static const int DDNS_TIMEOUT_;
  static const int ACCEPT_ONLY_;
  static const int REJECT_CLIENTS_;
  static const int POOL_;
  static const int SHARE_;
  static const int T1_;
  static const int T2_;
  static const int PREF_TIME_;
  static const int VALID_TIME_;
  static const int UNICAST_;
  static const int DROP_UNICAST_;
  static const int PREFERENCE_;
  static const int RAPID_COMMIT_;
  static const int IFACE_MAX_LEASE_;
  static const int CLASS_MAX_LEASE_;
  static const int CLNT_MAX_LEASE_;
  static const int STATELESS_;
  static const int CACHE_SIZE_;
  static const int PDCLASS_;
  static const int PD_LENGTH_;
  static const int PD_POOL_;
  static const int SCRIPT_;
  static const int VENDOR_SPEC_;
  static const int CLIENT_;
  static const int DUID_KEYWORD_;
  static const int REMOTE_ID_;
  static const int LINK_LOCAL_;
  static const int ADDRESS_;
  static const int PREFIX_;
  static const int GUESS_MODE_;
  static const int INACTIVE_MODE_;
  static const int EXPERIMENTAL_;
  static const int ADDR_PARAMS_;
  static const int REMOTE_AUTOCONF_NEIGHBORS_;
  static const int AFTR_;
  static const int PERFORMANCE_MODE_;
  static const int AUTH_PROTOCOL_;
  static const int AUTH_ALGORITHM_;
  static const int AUTH_REPLAY_;
  static const int AUTH_METHODS_;
  static const int AUTH_DROP_UNAUTH_;
  static const int AUTH_REALM_;
  static const int KEY_;
  static const int SECRET_;
  static const int ALGORITHM_;
  static const int FUDGE_;
  static const int DIGEST_NONE_;
  static const int DIGEST_PLAIN_;
  static const int DIGEST_HMAC_MD5_;
  static const int DIGEST_HMAC_SHA1_;
  static const int DIGEST_HMAC_SHA224_;
  static const int DIGEST_HMAC_SHA256_;
  static const int DIGEST_HMAC_SHA384_;
  static const int DIGEST_HMAC_SHA512_;
  static const int ACCEPT_LEASEQUERY_;
  static const int BULKLQ_ACCEPT_;
  static const int BULKLQ_TCPPORT_;
  static const int BULKLQ_MAX_CONNS_;
  static const int BULKLQ_TIMEOUT_;
  static const int CLIENT_CLASS_;
  static const int MATCH_IF_;
  static const int EQ_;
  static const int AND_;
  static const int OR_;
  static const int CLIENT_VENDOR_SPEC_ENTERPRISE_NUM_;
  static const int CLIENT_VENDOR_SPEC_DATA_;
  static const int CLIENT_VENDOR_CLASS_EN_;
  static const int CLIENT_VENDOR_CLASS_DATA_;
  static const int RECONFIGURE_ENABLED_;
  static const int ALLOW_;
  static const int DENY_;
  static const int SUBSTRING_;
  static const int STRING_KEYWORD_;
  static const int ADDRESS_LIST_;
  static const int CONTAIN_;
  static const int NEXT_HOP_;
  static const int ROUTE_;
  static const int INFINITE_;
  static const int SUBNET_;
  static const int STRING_;
  static const int HEXNUMBER_;
  static const int INTNUMBER_;
  static const int IPV6ADDR_;
  static const int DUID_;

#line 307 "../bison++/bison.cc"
  /* decl const */
#else
  enum YY_SrvParser_ENUM_TOKEN {
    YY_SrvParser_NULL_TOKEN = 0

#line 310 "../bison++/bison.cc"
    ,
    IFACE_ = 258,
    RELAY_ = 259,
    IFACE_ID_ = 260,
    IFACE_ID_ORDER_ = 261,
    CLASS_ = 262,
    TACLASS_ = 263,
    LOGNAME_ = 264,
    LOGLEVEL_ = 265,
    LOGMODE_ = 266,
    LOGCOLORS_ = 267,
    WORKDIR_ = 268,
    OPTION_ = 269,
    DNS_SERVER_ = 270,
    DOMAIN_ = 271,
    NTP_SERVER_ = 272,
    TIME_ZONE_ = 273,
    SIP_SERVER_ = 274,
    SIP_DOMAIN_ = 275,
    NIS_SERVER_ = 276,
    NIS_DOMAIN_ = 277,
    NISP_SERVER_ = 278,
    NISP_DOMAIN_ = 279,
    LIFETIME_ = 280,
    FQDN_ = 281,
    ACCEPT_UNKNOWN_FQDN_ = 282,
    FQDN_DDNS_ADDRESS_ = 283,
    DDNS_PROTOCOL_ = 284,
    DDNS_TIMEOUT_ = 285,
    ACCEPT_ONLY_ = 286,
    REJECT_CLIENTS_ = 287,
    POOL_ = 288,
    SHARE_ = 289,
    T1_ = 290,
    T2_ = 291,
    PREF_TIME_ = 292,
    VALID_TIME_ = 293,
    UNICAST_ = 294,
    DROP_UNICAST_ = 295,
    PREFERENCE_ = 296,
    RAPID_COMMIT_ = 297,
    IFACE_MAX_LEASE_ = 298,
    CLASS_MAX_LEASE_ = 299,
    CLNT_MAX_LEASE_ = 300,
    STATELESS_ = 301,
    CACHE_SIZE_ = 302,
    PDCLASS_ = 303,
    PD_LENGTH_ = 304,
    PD_POOL_ = 305,
    SCRIPT_ = 306,
    VENDOR_SPEC_ = 307,
    CLIENT_ = 308,
    DUID_KEYWORD_ = 309,
    REMOTE_ID_ = 310,
    LINK_LOCAL_ = 311,
    ADDRESS_ = 312,
    PREFIX_ = 313,
    GUESS_MODE_ = 314,
    INACTIVE_MODE_ = 315,
    EXPERIMENTAL_ = 316,
    ADDR_PARAMS_ = 317,
    REMOTE_AUTOCONF_NEIGHBORS_ = 318,
    AFTR_ = 319,
    PERFORMANCE_MODE_ = 320,
    AUTH_PROTOCOL_ = 321,
    AUTH_ALGORITHM_ = 322,
    AUTH_REPLAY_ = 323,
    AUTH_METHODS_ = 324,
    AUTH_DROP_UNAUTH_ = 325,
    AUTH_REALM_ = 326,
    KEY_ = 327,
    SECRET_ = 328,
    ALGORITHM_ = 329,
    FUDGE_ = 330,
    DIGEST_NONE_ = 331,
    DIGEST_PLAIN_ = 332,
    DIGEST_HMAC_MD5_ = 333,
    DIGEST_HMAC_SHA1_ = 334,
    DIGEST_HMAC_SHA224_ = 335,
    DIGEST_HMAC_SHA256_ = 336,
    DIGEST_HMAC_SHA384_ = 337,
    DIGEST_HMAC_SHA512_ = 338,
    ACCEPT_LEASEQUERY_ = 339,
    BULKLQ_ACCEPT_ = 340,
    BULKLQ_TCPPORT_ = 341,
    BULKLQ_MAX_CONNS_ = 342,
    BULKLQ_TIMEOUT_ = 343,
    CLIENT_CLASS_ = 344,
    MATCH_IF_ = 345,
    EQ_ = 346,
    AND_ = 347,
    OR_ = 348,
    CLIENT_VENDOR_SPEC_ENTERPRISE_NUM_ = 349,
    CLIENT_VENDOR_SPEC_DATA_ = 350,
    CLIENT_VENDOR_CLASS_EN_ = 351,
    CLIENT_VENDOR_CLASS_DATA_ = 352,
    RECONFIGURE_ENABLED_ = 353,
    ALLOW_ = 354,
    DENY_ = 355,
    SUBSTRING_ = 356,
    STRING_KEYWORD_ = 357,
    ADDRESS_LIST_ = 358,
    CONTAIN_ = 359,
    NEXT_HOP_ = 360,
    ROUTE_ = 361,
    INFINITE_ = 362,
    SUBNET_ = 363,
    STRING_ = 364,
    HEXNUMBER_ = 365,
    INTNUMBER_ = 366,
    IPV6ADDR_ = 367,
    DUID_ = 368

#line 310 "../bison++/bison.cc"
    /* enum token */
  }; /* end of enum declaration */
#endif
 public:
  int YY_SrvParser_PARSE(YY_SrvParser_PARSE_PARAM);
  virtual void YY_SrvParser_ERROR(char *msg) YY_SrvParser_ERROR_BODY;
#ifdef YY_SrvParser_PURE
#ifdef YY_SrvParser_LSP_NEEDED
  virtual int YY_SrvParser_LEX(YY_SrvParser_STYPE *YY_SrvParser_LVAL,
                               YY_SrvParser_LTYPE *YY_SrvParser_LLOC) YY_SrvParser_LEX_BODY;
#else
  virtual int YY_SrvParser_LEX(YY_SrvParser_STYPE *YY_SrvParser_LVAL) YY_SrvParser_LEX_BODY;
#endif
#else
  virtual int YY_SrvParser_LEX() YY_SrvParser_LEX_BODY;
  YY_SrvParser_STYPE YY_SrvParser_LVAL;
#ifdef YY_SrvParser_LSP_NEEDED
  YY_SrvParser_LTYPE YY_SrvParser_LLOC;
#endif
  int YY_SrvParser_NERRS;
  int YY_SrvParser_CHAR;
#endif
#if YY_SrvParser_DEBUG != 0
  int YY_SrvParser_DEBUG_FLAG; /*  nonzero means print parse trace     */
#endif
 public:
  YY_SrvParser_CLASS(YY_SrvParser_CONSTRUCTOR_PARAM);

 public:
  YY_SrvParser_MEMBERS
};
/* other declare folow */
#if YY_SrvParser_USE_CONST_TOKEN != 0

#line 341 "../bison++/bison.cc"
const int YY_SrvParser_CLASS::IFACE_ = 258;
const int YY_SrvParser_CLASS::RELAY_ = 259;
const int YY_SrvParser_CLASS::IFACE_ID_ = 260;
const int YY_SrvParser_CLASS::IFACE_ID_ORDER_ = 261;
const int YY_SrvParser_CLASS::CLASS_ = 262;
const int YY_SrvParser_CLASS::TACLASS_ = 263;
const int YY_SrvParser_CLASS::LOGNAME_ = 264;
const int YY_SrvParser_CLASS::LOGLEVEL_ = 265;
const int YY_SrvParser_CLASS::LOGMODE_ = 266;
const int YY_SrvParser_CLASS::LOGCOLORS_ = 267;
const int YY_SrvParser_CLASS::WORKDIR_ = 268;
const int YY_SrvParser_CLASS::OPTION_ = 269;
const int YY_SrvParser_CLASS::DNS_SERVER_ = 270;
const int YY_SrvParser_CLASS::DOMAIN_ = 271;
const int YY_SrvParser_CLASS::NTP_SERVER_ = 272;
const int YY_SrvParser_CLASS::TIME_ZONE_ = 273;
const int YY_SrvParser_CLASS::SIP_SERVER_ = 274;
const int YY_SrvParser_CLASS::SIP_DOMAIN_ = 275;
const int YY_SrvParser_CLASS::NIS_SERVER_ = 276;
const int YY_SrvParser_CLASS::NIS_DOMAIN_ = 277;
const int YY_SrvParser_CLASS::NISP_SERVER_ = 278;
const int YY_SrvParser_CLASS::NISP_DOMAIN_ = 279;
const int YY_SrvParser_CLASS::LIFETIME_ = 280;
const int YY_SrvParser_CLASS::FQDN_ = 281;
const int YY_SrvParser_CLASS::ACCEPT_UNKNOWN_FQDN_ = 282;
const int YY_SrvParser_CLASS::FQDN_DDNS_ADDRESS_ = 283;
const int YY_SrvParser_CLASS::DDNS_PROTOCOL_ = 284;
const int YY_SrvParser_CLASS::DDNS_TIMEOUT_ = 285;
const int YY_SrvParser_CLASS::ACCEPT_ONLY_ = 286;
const int YY_SrvParser_CLASS::REJECT_CLIENTS_ = 287;
const int YY_SrvParser_CLASS::POOL_ = 288;
const int YY_SrvParser_CLASS::SHARE_ = 289;
const int YY_SrvParser_CLASS::T1_ = 290;
const int YY_SrvParser_CLASS::T2_ = 291;
const int YY_SrvParser_CLASS::PREF_TIME_ = 292;
const int YY_SrvParser_CLASS::VALID_TIME_ = 293;
const int YY_SrvParser_CLASS::UNICAST_ = 294;
const int YY_SrvParser_CLASS::DROP_UNICAST_ = 295;
const int YY_SrvParser_CLASS::PREFERENCE_ = 296;
const int YY_SrvParser_CLASS::RAPID_COMMIT_ = 297;
const int YY_SrvParser_CLASS::IFACE_MAX_LEASE_ = 298;
const int YY_SrvParser_CLASS::CLASS_MAX_LEASE_ = 299;
const int YY_SrvParser_CLASS::CLNT_MAX_LEASE_ = 300;
const int YY_SrvParser_CLASS::STATELESS_ = 301;
const int YY_SrvParser_CLASS::CACHE_SIZE_ = 302;
const int YY_SrvParser_CLASS::PDCLASS_ = 303;
const int YY_SrvParser_CLASS::PD_LENGTH_ = 304;
const int YY_SrvParser_CLASS::PD_POOL_ = 305;
const int YY_SrvParser_CLASS::SCRIPT_ = 306;
const int YY_SrvParser_CLASS::VENDOR_SPEC_ = 307;
const int YY_SrvParser_CLASS::CLIENT_ = 308;
const int YY_SrvParser_CLASS::DUID_KEYWORD_ = 309;
const int YY_SrvParser_CLASS::REMOTE_ID_ = 310;
const int YY_SrvParser_CLASS::LINK_LOCAL_ = 311;
const int YY_SrvParser_CLASS::ADDRESS_ = 312;
const int YY_SrvParser_CLASS::PREFIX_ = 313;
const int YY_SrvParser_CLASS::GUESS_MODE_ = 314;
const int YY_SrvParser_CLASS::INACTIVE_MODE_ = 315;
const int YY_SrvParser_CLASS::EXPERIMENTAL_ = 316;
const int YY_SrvParser_CLASS::ADDR_PARAMS_ = 317;
const int YY_SrvParser_CLASS::REMOTE_AUTOCONF_NEIGHBORS_ = 318;
const int YY_SrvParser_CLASS::AFTR_ = 319;
const int YY_SrvParser_CLASS::PERFORMANCE_MODE_ = 320;
const int YY_SrvParser_CLASS::AUTH_PROTOCOL_ = 321;
const int YY_SrvParser_CLASS::AUTH_ALGORITHM_ = 322;
const int YY_SrvParser_CLASS::AUTH_REPLAY_ = 323;
const int YY_SrvParser_CLASS::AUTH_METHODS_ = 324;
const int YY_SrvParser_CLASS::AUTH_DROP_UNAUTH_ = 325;
const int YY_SrvParser_CLASS::AUTH_REALM_ = 326;
const int YY_SrvParser_CLASS::KEY_ = 327;
const int YY_SrvParser_CLASS::SECRET_ = 328;
const int YY_SrvParser_CLASS::ALGORITHM_ = 329;
const int YY_SrvParser_CLASS::FUDGE_ = 330;
const int YY_SrvParser_CLASS::DIGEST_NONE_ = 331;
const int YY_SrvParser_CLASS::DIGEST_PLAIN_ = 332;
const int YY_SrvParser_CLASS::DIGEST_HMAC_MD5_ = 333;
const int YY_SrvParser_CLASS::DIGEST_HMAC_SHA1_ = 334;
const int YY_SrvParser_CLASS::DIGEST_HMAC_SHA224_ = 335;
const int YY_SrvParser_CLASS::DIGEST_HMAC_SHA256_ = 336;
const int YY_SrvParser_CLASS::DIGEST_HMAC_SHA384_ = 337;
const int YY_SrvParser_CLASS::DIGEST_HMAC_SHA512_ = 338;
const int YY_SrvParser_CLASS::ACCEPT_LEASEQUERY_ = 339;
const int YY_SrvParser_CLASS::BULKLQ_ACCEPT_ = 340;
const int YY_SrvParser_CLASS::BULKLQ_TCPPORT_ = 341;
const int YY_SrvParser_CLASS::BULKLQ_MAX_CONNS_ = 342;
const int YY_SrvParser_CLASS::BULKLQ_TIMEOUT_ = 343;
const int YY_SrvParser_CLASS::CLIENT_CLASS_ = 344;
const int YY_SrvParser_CLASS::MATCH_IF_ = 345;
const int YY_SrvParser_CLASS::EQ_ = 346;
const int YY_SrvParser_CLASS::AND_ = 347;
const int YY_SrvParser_CLASS::OR_ = 348;
const int YY_SrvParser_CLASS::CLIENT_VENDOR_SPEC_ENTERPRISE_NUM_ = 349;
const int YY_SrvParser_CLASS::CLIENT_VENDOR_SPEC_DATA_ = 350;
const int YY_SrvParser_CLASS::CLIENT_VENDOR_CLASS_EN_ = 351;
const int YY_SrvParser_CLASS::CLIENT_VENDOR_CLASS_DATA_ = 352;
const int YY_SrvParser_CLASS::RECONFIGURE_ENABLED_ = 353;
const int YY_SrvParser_CLASS::ALLOW_ = 354;
const int YY_SrvParser_CLASS::DENY_ = 355;
const int YY_SrvParser_CLASS::SUBSTRING_ = 356;
const int YY_SrvParser_CLASS::STRING_KEYWORD_ = 357;
const int YY_SrvParser_CLASS::ADDRESS_LIST_ = 358;
const int YY_SrvParser_CLASS::CONTAIN_ = 359;
const int YY_SrvParser_CLASS::NEXT_HOP_ = 360;
const int YY_SrvParser_CLASS::ROUTE_ = 361;
const int YY_SrvParser_CLASS::INFINITE_ = 362;
const int YY_SrvParser_CLASS::SUBNET_ = 363;
const int YY_SrvParser_CLASS::STRING_ = 364;
const int YY_SrvParser_CLASS::HEXNUMBER_ = 365;
const int YY_SrvParser_CLASS::INTNUMBER_ = 366;
const int YY_SrvParser_CLASS::IPV6ADDR_ = 367;
const int YY_SrvParser_CLASS::DUID_ = 368;

#line 341 "../bison++/bison.cc"
/* const YY_SrvParser_CLASS::token */
#endif
/*apres const  */
YY_SrvParser_CLASS::YY_SrvParser_CLASS(YY_SrvParser_CONSTRUCTOR_PARAM)
    YY_SrvParser_CONSTRUCTOR_INIT {
#if YY_SrvParser_DEBUG != 0
  YY_SrvParser_DEBUG_FLAG = 0;
#endif
  YY_SrvParser_CONSTRUCTOR_CODE;
}
#endif

#line 352 "../bison++/bison.cc"

#define YYFINAL 507
#define YYFLAG -32768
#define YYNTBASE 122

#define YYTRANSLATE(x) ((unsigned)(x) <= 368 ? yytranslate[x] : 263)

static const char yytranslate[] = {
    0,   2,   2,   2,   2,   2,   2,   2,   2,  2,  2,  2,  2,  2,  2,  2,   2,   2,   2,   2,
    2,   2,   2,   2,   2,   2,   2,   2,   2,  2,  2,  2,  2,  2,  2,  2,   2,   2,   2,   2,
    120, 121, 2,   2,   119, 117, 2,   118, 2,  2,  2,  2,  2,  2,  2,  2,   2,   2,   2,   116,
    2,   2,   2,   2,   2,   2,   2,   2,   2,  2,  2,  2,  2,  2,  2,  2,   2,   2,   2,   2,
    2,   2,   2,   2,   2,   2,   2,   2,   2,  2,  2,  2,  2,  2,  2,  2,   2,   2,   2,   2,
    2,   2,   2,   2,   2,   2,   2,   2,   2,  2,  2,  2,  2,  2,  2,  2,   2,   2,   2,   2,
    2,   2,   2,   114, 2,   115, 2,   2,   2,  2,  2,  2,  2,  2,  2,  2,   2,   2,   2,   2,
    2,   2,   2,   2,   2,   2,   2,   2,   2,  2,  2,  2,  2,  2,  2,  2,   2,   2,   2,   2,
    2,   2,   2,   2,   2,   2,   2,   2,   2,  2,  2,  2,  2,  2,  2,  2,   2,   2,   2,   2,
    2,   2,   2,   2,   2,   2,   2,   2,   2,  2,  2,  2,  2,  2,  2,  2,   2,   2,   2,   2,
    2,   2,   2,   2,   2,   2,   2,   2,   2,  2,  2,  2,  2,  2,  2,  2,   2,   2,   2,   2,
    2,   2,   2,   2,   2,   2,   2,   2,   2,  2,  2,  2,  2,  2,  2,  2,   2,   2,   2,   2,
    2,   2,   2,   2,   2,   2,   2,   2,   2,  2,  2,  2,  2,  2,  2,  2,   1,   2,   3,   4,
    5,   6,   7,   8,   9,   10,  11,  12,  13, 14, 15, 16, 17, 18, 19, 20,  21,  22,  23,  24,
    25,  26,  27,  28,  29,  30,  31,  32,  33, 34, 35, 36, 37, 38, 39, 40,  41,  42,  43,  44,
    45,  46,  47,  48,  49,  50,  51,  52,  53, 54, 55, 56, 57, 58, 59, 60,  61,  62,  63,  64,
    65,  66,  67,  68,  69,  70,  71,  72,  73, 74, 75, 76, 77, 78, 79, 80,  81,  82,  83,  84,
    85,  86,  87,  88,  89,  90,  91,  92,  93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104,
    105, 106, 107, 108, 109, 110, 111, 112, 113};

#if YY_SrvParser_DEBUG != 0
static const short yyprhs[] = {
    0,   0,   2,   3,   5,   7,   10,  13,  15,  17,  19,  21,  23,  25,  27,  29,  31,  33,  35,
    37,  39,  41,  43,  45,  47,  49,  51,  53,  55,  57,  59,  61,  63,  65,  67,  69,  71,  73,
    75,  77,  79,  81,  83,  85,  87,  89,  91,  93,  95,  97,  99,  101, 103, 105, 107, 109, 111,
    113, 115, 117, 119, 121, 123, 125, 127, 129, 131, 133, 134, 141, 142, 149, 151, 154, 156, 158,
    160, 162, 165, 168, 171, 174, 175, 176, 185, 187, 190, 192, 194, 196, 200, 204, 208, 212, 216,
    217, 225, 226, 236, 237, 245, 247, 250, 252, 254, 256, 258, 260, 262, 264, 266, 268, 270, 272,
    274, 276, 278, 280, 282, 285, 290, 291, 297, 299, 302, 303, 309, 311, 314, 316, 318, 320, 322,
    324, 326, 328, 330, 331, 337, 339, 342, 344, 346, 348, 350, 352, 354, 356, 358, 359, 366, 369,
    371, 374, 381, 386, 393, 396, 399, 402, 405, 406, 410, 412, 416, 418, 420, 422, 424, 426, 428,
    430, 432, 435, 437, 441, 445, 449, 455, 461, 463, 465, 467, 471, 477, 483, 489, 497, 505, 513,
    515, 519, 521, 525, 529, 533, 539, 543, 545, 549, 553, 559, 561, 565, 569, 575, 576, 580, 581,
    585, 586, 590, 591, 595, 598, 601, 606, 609, 614, 617, 620, 625, 628, 633, 636, 639, 642, 646,
    651, 656, 657, 663, 668, 669, 674, 677, 680, 682, 685, 688, 691, 694, 697, 700, 703, 705, 707,
    710, 713, 716, 718, 720, 723, 726, 728, 731, 734, 737, 740, 743, 746, 749, 752, 755, 758, 763,
    768, 770, 772, 774, 776, 778, 780, 782, 784, 786, 788, 790, 792, 795, 798, 799, 804, 805, 810,
    811, 816, 820, 821, 826, 827, 832, 833, 838, 839, 845, 846, 853, 857, 860, 863, 866, 869, 870,
    875, 876, 881, 885, 889, 893, 894, 899, 900, 907, 910, 911, 917, 923, 929, 935, 937, 939, 941,
    943, 945, 947};

static const short yyrhs[] = {
    123, 0,   0,   124, 0,   126, 0,   123, 124, 0,   123, 126, 0,   125, 0,   206, 0,   205, 0,
    207, 0,   208, 0,   209, 0,   210, 0,   218, 0,   161, 0,   162, 0,   163, 0,   164, 0,   165,
    0,   169, 0,   216, 0,   217, 0,   246, 0,   247, 0,   248, 0,   211, 0,   258, 0,   130, 0,
    212, 0,   213, 0,   214, 0,   202, 0,   227, 0,   224, 0,   225, 0,   219, 0,   220, 0,   221,
    0,   222, 0,   223, 0,   201, 0,   204, 0,   203, 0,   200, 0,   192, 0,   230, 0,   232, 0,
    234, 0,   236, 0,   237, 0,   239, 0,   241, 0,   245, 0,   249, 0,   253, 0,   251, 0,   254,
    0,   195, 0,   255, 0,   196, 0,   198, 0,   153, 0,   256, 0,   138, 0,   215, 0,   226, 0,
    0,   3,   109, 114, 127, 129, 115, 0,   0,   3,   171, 114, 128, 129, 115, 0,   125, 0,   129,
    125, 0,   146, 0,   149, 0,   157, 0,   160, 0,   129, 149, 0,   129, 146, 0,   129, 157, 0,
    129, 160, 0,   0,   0,   72,  109, 114, 131, 133, 115, 132, 116, 0,   134, 0,   133, 134, 0,
    137, 0,   135, 0,   136, 0,   73,  109, 116, 0,   75,  171, 116, 0,   74,  81,  116, 0,   74,
    79,  116, 0,   74,  78,  116, 0,   0,   53,  54,  113, 114, 139, 142, 115, 0,   0,   53,  55,
    171, 117, 113, 114, 140, 142, 115, 0,   0,   53,  56,  112, 114, 141, 142, 115, 0,   143, 0,
    142, 143, 0,   230, 0,   232, 0,   234, 0,   236, 0,   237, 0,   239, 0,   249, 0,   253, 0,
    251, 0,   254, 0,   255, 0,   256, 0,   196, 0,   195, 0,   144, 0,   145, 0,   57,  112, 0,
    58,  112, 118, 171, 0,   0,   7,   114, 147, 148, 115, 0,   227, 0,   148, 227, 0,   0,   8,
    114, 150, 151, 115, 0,   152, 0,   151, 152, 0,   187, 0,   188, 0,   182, 0,   193, 0,   178,
    0,   180, 0,   228, 0,   229, 0,   0,   48,  114, 154, 155, 115, 0,   156, 0,   156, 155, 0,
    186, 0,   184, 0,   188, 0,   187, 0,   190, 0,   191, 0,   228, 0,   229, 0,   0,   105, 112,
    114, 158, 159, 115, 0,   105, 112, 0,   160, 0,   159, 160, 0,   106, 112, 118, 111, 25,  111,
    0,   106, 112, 118, 111, 0,   106, 112, 118, 111, 25,  107, 0,   66,  109, 0,   67,  109, 0,
    68,  109, 0,   71,  109, 0,   0,   69,  166, 167, 0,   168, 0,   167, 119, 168, 0,   76,  0,
    77,  0,   78,  0,   79,  0,   80,  0,   81,  0,   82,  0,   83,  0,   70,  171, 0,   109, 0,
    109, 117, 113, 0,   109, 117, 112, 0,   170, 119, 109, 0,   170, 119, 109, 117, 113, 0,   170,
    119, 109, 117, 112, 0,   110, 0,   111, 0,   112, 0,   172, 119, 112, 0,   171, 117, 171, 117,
    113, 0,   171, 117, 171, 117, 112, 0,   171, 117, 171, 117, 109, 0,   173, 119, 171, 117, 171,
    117, 113, 0,   173, 119, 171, 117, 171, 117, 112, 0,   173, 119, 171, 117, 171, 117, 109, 0,
    109, 0,   174, 119, 109, 0,   112, 0,   112, 117, 112, 0,   112, 118, 111, 0,   175, 119, 112,
    0,   175, 119, 112, 117, 112, 0,   112, 118, 111, 0,   112, 0,   112, 117, 112, 0,   177, 119,
    112, 0,   177, 119, 112, 117, 112, 0,   113, 0,   113, 117, 113, 0,   177, 119, 113, 0,   177,
    119, 113, 117, 113, 0,   0,   32,  179, 177, 0,   0,   31,  181, 177, 0,   0,   33,  183, 175,
    0,   0,   50,  185, 176, 0,   49,  171, 0,   37,  171, 0,   37,  171, 117, 171, 0,   38,  171,
    0,   38,  171, 117, 171, 0,   34,  171, 0,   35,  171, 0,   35,  171, 117, 171, 0,   36,  171,
    0,   36,  171, 117, 171, 0,   45,  171, 0,   44,  171, 0,   62,  171, 0,   14,  64,  109, 0,
    14,  171, 54,  113, 0,   14,  171, 57,  112, 0,   0,   14,  171, 103, 197, 172, 0,   14,  171,
    102, 109, 0,   0,   14,  63,  199, 172, 0,   43,  171, 0,   39,  112, 0,   40,  0,   42,  171,
    0,   41,  171, 0,   10,  171, 0,   11,  109, 0,   9,   109, 0,   12,  171, 0,   13,  109, 0,
    46,  0,   59,  0,   51,  109, 0,   65,  171, 0,   98,  171, 0,   60,  0,   61,  0,   6,   109,
    0,   47,  171, 0,   84,  0,   84,  171, 0,   85,  171, 0,   86,  171, 0,   87,  171, 0,   88,
    171, 0,   4,   109, 0,   4,   171, 0,   5,   171, 0,   5,   113, 0,   5,   109, 0,   108, 112,
    118, 171, 0,   108, 112, 117, 112, 0,   187, 0,   188, 0,   182, 0,   189, 0,   190, 0,   191,
    0,   178, 0,   180, 0,   193, 0,   194, 0,   228, 0,   229, 0,   99,  109, 0,   100, 109, 0,
    0,   14,  15,  231, 172, 0,   0,   14,  16,  233, 174, 0,   0,   14,  17,  235, 172, 0,   14,
    18,  109, 0,   0,   14,  19,  238, 172, 0,   0,   14,  20,  240, 174, 0,   0,   14,  26,  242,
    170, 0,   0,   14,  26,  111, 243, 170, 0,   0,   14,  26,  111, 111, 244, 170, 0,   27,  171,
    109, 0,   27,  171, 0,   28,  112, 0,   29,  109, 0,   30,  171, 0,   0,   14,  21,  250, 172,
    0,   0,   14,  23,  252, 172, 0,   14,  22,  109, 0,   14,  24,  109, 0,   14,  25,  171, 0,
    0,   14,  52,  257, 173, 0,   0,   89,  109, 114, 259, 260, 115, 0,   90,  261, 0,   0,   120,
    262, 104, 262, 121, 0,   120, 262, 91,  262, 121, 0,   120, 261, 92,  261, 121, 0,   120, 261,
    93,  261, 121, 0,   94,  0,   95,  0,   96,  0,   97,  0,   109, 0,   171, 0,   101, 120, 262,
    119, 171, 119, 171, 121, 0};

#endif

#if (YY_SrvParser_DEBUG != 0) || defined(YY_SrvParser_ERROR_VERBOSE)
static const short yyrline[] = {
    0,    162,  163,  167,  168,  169,  170,  174,  175,  176,  177,  178,  179,  180,  181,  182,
    183,  184,  185,  186,  187,  188,  189,  190,  191,  192,  193,  194,  195,  196,  197,  198,
    199,  203,  204,  205,  206,  207,  208,  209,  210,  211,  212,  213,  214,  215,  216,  217,
    218,  219,  220,  221,  222,  223,  224,  225,  226,  227,  228,  229,  230,  231,  232,  233,
    234,  235,  236,  241,  246,  254,  259,  265,  266,  267,  268,  269,  270,  271,  272,  273,
    274,  278,  283,  308,  311,  312,  316,  317,  318,  322,  329,  335,  336,  337,  342,  348,
    356,  362,  370,  376,  385,  386,  390,  391,  392,  393,  394,  395,  396,  397,  398,  399,
    400,  401,  402,  403,  404,  405,  408,  416,  425,  430,  438,  439,  444,  447,  455,  456,
    460,  461,  462,  463,  464,  465,  466,  467,  471,  474,  482,  483,  486,  487,  488,  489,
    490,  491,  492,  493,  500,  507,  512,  521,  522,  525,  535,  544,  555,  578,  584,  602,
    611,  614,  625,  626,  630,  631,  632,  633,  634,  635,  636,  637,  642,  659,  664,  671,
    677,  682,  688,  697,  698,  702,  706,  713,  721,  729,  737,  744,  752,  762,  763,  767,
    771,  780,  796,  800,  812,  835,  839,  848,  852,  861,  867,  879,  885,  899,  903,  909,
    913,  919,  923,  929,  932,  937,  949,  954,  962,  967,  975,  987,  992,  1000, 1005, 1013,
    1020, 1027, 1042, 1050, 1057, 1065, 1069, 1075, 1083, 1094, 1103, 1110, 1117, 1123, 1138, 1150,
    1156, 1161, 1168, 1174, 1181, 1188, 1196, 1202, 1215, 1231, 1237, 1244, 1266, 1277, 1282, 1299,
    1310, 1316, 1322, 1331, 1335, 1342, 1347, 1352, 1360, 1373, 1383, 1384, 1385, 1386, 1387, 1388,
    1389, 1390, 1391, 1392, 1393, 1394, 1398, 1427, 1460, 1464, 1474, 1477, 1487, 1491, 1502, 1514,
    1517, 1528, 1531, 1543, 1553, 1556, 1579, 1583, 1612, 1619, 1625, 1634, 1642, 1659, 1669, 1672,
    1683, 1686, 1697, 1709, 1720, 1731, 1733, 1740, 1743, 1753, 1759, 1759, 1767, 1776, 1785, 1796,
    1800, 1804, 1808, 1812, 1817, 1826};

static const char *const yytname[] = {"$",
                                      "error",
                                      "$illegal.",
                                      "IFACE_",
                                      "RELAY_",
                                      "IFACE_ID_",
                                      "IFACE_ID_ORDER_",
                                      "CLASS_",
                                      "TACLASS_",
                                      "LOGNAME_",
                                      "LOGLEVEL_",
                                      "LOGMODE_",
                                      "LOGCOLORS_",
                                      "WORKDIR_",
                                      "OPTION_",
                                      "DNS_SERVER_",
                                      "DOMAIN_",
                                      "NTP_SERVER_",
                                      "TIME_ZONE_",
                                      "SIP_SERVER_",
                                      "SIP_DOMAIN_",
                                      "NIS_SERVER_",
                                      "NIS_DOMAIN_",
                                      "NISP_SERVER_",
                                      "NISP_DOMAIN_",
                                      "LIFETIME_",
                                      "FQDN_",
                                      "ACCEPT_UNKNOWN_FQDN_",
                                      "FQDN_DDNS_ADDRESS_",
                                      "DDNS_PROTOCOL_",
                                      "DDNS_TIMEOUT_",
                                      "ACCEPT_ONLY_",
                                      "REJECT_CLIENTS_",
                                      "POOL_",
                                      "SHARE_",
                                      "T1_",
                                      "T2_",
                                      "PREF_TIME_",
                                      "VALID_TIME_",
                                      "UNICAST_",
                                      "DROP_UNICAST_",
                                      "PREFERENCE_",
                                      "RAPID_COMMIT_",
                                      "IFACE_MAX_LEASE_",
                                      "CLASS_MAX_LEASE_",
                                      "CLNT_MAX_LEASE_",
                                      "STATELESS_",
                                      "CACHE_SIZE_",
                                      "PDCLASS_",
                                      "PD_LENGTH_",
                                      "PD_POOL_",
                                      "SCRIPT_",
                                      "VENDOR_SPEC_",
                                      "CLIENT_",
                                      "DUID_KEYWORD_",
                                      "REMOTE_ID_",
                                      "LINK_LOCAL_",
                                      "ADDRESS_",
                                      "PREFIX_",
                                      "GUESS_MODE_",
                                      "INACTIVE_MODE_",
                                      "EXPERIMENTAL_",
                                      "ADDR_PARAMS_",
                                      "REMOTE_AUTOCONF_NEIGHBORS_",
                                      "AFTR_",
                                      "PERFORMANCE_MODE_",
                                      "AUTH_PROTOCOL_",
                                      "AUTH_ALGORITHM_",
                                      "AUTH_REPLAY_",
                                      "AUTH_METHODS_",
                                      "AUTH_DROP_UNAUTH_",
                                      "AUTH_REALM_",
                                      "KEY_",
                                      "SECRET_",
                                      "ALGORITHM_",
                                      "FUDGE_",
                                      "DIGEST_NONE_",
                                      "DIGEST_PLAIN_",
                                      "DIGEST_HMAC_MD5_",
                                      "DIGEST_HMAC_SHA1_",
                                      "DIGEST_HMAC_SHA224_",
                                      "DIGEST_HMAC_SHA256_",
                                      "DIGEST_HMAC_SHA384_",
                                      "DIGEST_HMAC_SHA512_",
                                      "ACCEPT_LEASEQUERY_",
                                      "BULKLQ_ACCEPT_",
                                      "BULKLQ_TCPPORT_",
                                      "BULKLQ_MAX_CONNS_",
                                      "BULKLQ_TIMEOUT_",
                                      "CLIENT_CLASS_",
                                      "MATCH_IF_",
                                      "EQ_",
                                      "AND_",
                                      "OR_",
                                      "CLIENT_VENDOR_SPEC_ENTERPRISE_NUM_",
                                      "CLIENT_VENDOR_SPEC_DATA_",
                                      "CLIENT_VENDOR_CLASS_EN_",
                                      "CLIENT_VENDOR_CLASS_DATA_",
                                      "RECONFIGURE_ENABLED_",
                                      "ALLOW_",
                                      "DENY_",
                                      "SUBSTRING_",
                                      "STRING_KEYWORD_",
                                      "ADDRESS_LIST_",
                                      "CONTAIN_",
                                      "NEXT_HOP_",
                                      "ROUTE_",
                                      "INFINITE_",
                                      "SUBNET_",
                                      "STRING_",
                                      "HEXNUMBER_",
                                      "INTNUMBER_",
                                      "IPV6ADDR_",
                                      "DUID_",
                                      "'{'",
                                      "'}'",
                                      "';'",
                                      "'-'",
                                      "'/'",
                                      "','",
                                      "'('",
                                      "')'",
                                      "Grammar",
                                      "GlobalDeclarationList",
                                      "GlobalOption",
                                      "InterfaceOptionDeclaration",
                                      "InterfaceDeclaration",
                                      "@1",
                                      "@2",
                                      "InterfaceDeclarationsList",
                                      "Key",
                                      "@3",
                                      "@4",
                                      "KeyOptions",
                                      "KeyOption",
                                      "KeySecret",
                                      "KeyFudge",
                                      "KeyAlgorithm",
                                      "Client",
                                      "@5",
                                      "@6",
                                      "@7",
                                      "ClientOptions",
                                      "ClientOption",
                                      "AddressReservation",
                                      "PrefixReservation",
                                      "ClassDeclaration",
                                      "@8",
                                      "ClassOptionDeclarationsList",
                                      "TAClassDeclaration",
                                      "@9",
                                      "TAClassOptionsList",
                                      "TAClassOption",
                                      "PDDeclaration",
                                      "@10",
                                      "PDOptionsList",
                                      "PDOptions",
                                      "NextHopDeclaration",
                                      "@11",
                                      "RouteList",
                                      "Route",
                                      "AuthProtocol",
                                      "AuthAlgorithm",
                                      "AuthReplay",
                                      "AuthRealm",
                                      "AuthMethods",
                                      "@12",
                                      "DigestList",
                                      "Digest",
                                      "AuthDropUnauthenticated",
                                      "FQDNList",
                                      "Number",
                                      "ADDRESSList",
                                      "VendorSpecList",
                                      "StringList",
                                      "ADDRESSRangeList",
                                      "PDRangeList",
                                      "ADDRESSDUIDRangeList",
                                      "RejectClientsOption",
                                      "@13",
                                      "AcceptOnlyOption",
                                      "@14",
                                      "PoolOption",
                                      "@15",
                                      "PDPoolOption",
                                      "@16",
                                      "PDLength",
                                      "PreferredTimeOption",
                                      "ValidTimeOption",
                                      "ShareOption",
                                      "T1Option",
                                      "T2Option",
                                      "ClntMaxLeaseOption",
                                      "ClassMaxLeaseOption",
                                      "AddrParams",
                                      "DsLiteAftrName",
                                      "ExtraOption",
                                      "@17",
                                      "RemoteAutoconfNeighborsOption",
                                      "@18",
                                      "IfaceMaxLeaseOption",
                                      "UnicastAddressOption",
                                      "DropUnicast",
                                      "RapidCommitOption",
                                      "PreferenceOption",
                                      "LogLevelOption",
                                      "LogModeOption",
                                      "LogNameOption",
                                      "LogColors",
                                      "WorkDirOption",
                                      "StatelessOption",
                                      "GuessMode",
                                      "ScriptName",
                                      "PerformanceMode",
                                      "ReconfigureEnabled",
                                      "InactiveMode",
                                      "Experimental",
                                      "IfaceIDOrder",
                                      "CacheSizeOption",
                                      "AcceptLeaseQuery",
                                      "BulkLeaseQueryAccept",
                                      "BulkLeaseQueryTcpPort",
                                      "BulkLeaseQueryMaxConns",
                                      "BulkLeaseQueryTimeout",
                                      "RelayOption",
                                      "InterfaceIDOption",
                                      "Subnet",
                                      "ClassOptionDeclaration",
                                      "AllowClientClassDeclaration",
                                      "DenyClientClassDeclaration",
                                      "DNSServerOption",
                                      "@19",
                                      "DomainOption",
                                      "@20",
                                      "NTPServerOption",
                                      "@21",
                                      "TimeZoneOption",
                                      "SIPServerOption",
                                      "@22",
                                      "SIPDomainOption",
                                      "@23",
                                      "FQDNOption",
                                      "@24",
                                      "@25",
                                      "@26",
                                      "AcceptUnknownFQDN",
                                      "FqdnDdnsAddress",
                                      "DdnsProtocol",
                                      "DdnsTimeout",
                                      "NISServerOption",
                                      "@27",
                                      "NISPServerOption",
                                      "@28",
                                      "NISDomainOption",
                                      "NISPDomainOption",
                                      "LifetimeOption",
                                      "VendorSpecOption",
                                      "@29",
                                      "ClientClass",
                                      "@30",
                                      "ClientClassDecleration",
                                      "Condition",
                                      "Expr",
                                      ""};
#endif

static const short yyr1[] = {
    0,   122, 122, 123, 123, 123, 123, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124,
    124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 125, 125, 125, 125, 125,
    125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,
    125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 127, 126, 128, 126, 129, 129, 129, 129, 129,
    129, 129, 129, 129, 129, 131, 132, 130, 133, 133, 134, 134, 134, 135, 136, 137, 137, 137, 139,
    138, 140, 138, 141, 138, 142, 142, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143,
    143, 143, 143, 143, 144, 145, 147, 146, 148, 148, 150, 149, 151, 151, 152, 152, 152, 152, 152,
    152, 152, 152, 154, 153, 155, 155, 156, 156, 156, 156, 156, 156, 156, 156, 158, 157, 157, 159,
    159, 160, 160, 160, 161, 162, 163, 164, 166, 165, 167, 167, 168, 168, 168, 168, 168, 168, 168,
    168, 169, 170, 170, 170, 170, 170, 170, 171, 171, 172, 172, 173, 173, 173, 173, 173, 173, 174,
    174, 175, 175, 175, 175, 175, 176, 177, 177, 177, 177, 177, 177, 177, 177, 179, 178, 181, 180,
    183, 182, 185, 184, 186, 187, 187, 188, 188, 189, 190, 190, 191, 191, 192, 193, 194, 195, 196,
    196, 197, 196, 196, 199, 198, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212,
    213, 214, 215, 216, 217, 218, 219, 219, 220, 221, 222, 223, 224, 224, 225, 225, 225, 226, 226,
    227, 227, 227, 227, 227, 227, 227, 227, 227, 227, 227, 227, 228, 229, 231, 230, 233, 232, 235,
    234, 236, 238, 237, 240, 239, 242, 241, 243, 241, 244, 241, 245, 245, 246, 247, 248, 250, 249,
    252, 251, 253, 254, 255, 257, 256, 259, 258, 260, 261, 261, 261, 261, 261, 262, 262, 262, 262,
    262, 262, 262};

static const short yyr2[] = {
    0, 1, 0, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 0, 6, 0, 6, 1, 2, 1, 1, 1, 1, 2, 2, 2, 2, 0, 0, 8, 1, 2, 1, 1, 1, 3,
    3, 3, 3, 3, 0, 7, 0, 9, 0, 7, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 4,
    0, 5, 1, 2, 0, 5, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 0, 5, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 0, 6,
    2, 1, 2, 6, 4, 6, 2, 2, 2, 2, 0, 3, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 3, 3, 3, 5, 5, 1,
    1, 1, 3, 5, 5, 5, 7, 7, 7, 1, 3, 1, 3, 3, 3, 5, 3, 1, 3, 3, 5, 1, 3, 3, 5, 0, 3, 0, 3, 0,
    3, 0, 3, 2, 2, 4, 2, 4, 2, 2, 4, 2, 4, 2, 2, 2, 3, 4, 4, 0, 5, 4, 0, 4, 2, 2, 1, 2, 2, 2,
    2, 2, 2, 2, 1, 1, 2, 2, 2, 1, 1, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 4, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 0, 4, 0, 4, 0, 4, 3, 0, 4, 0, 4, 0, 4, 0, 5, 0, 6, 3, 2, 2,
    2, 2, 0, 4, 0, 4, 3, 3, 3, 0, 4, 0, 6, 2, 0, 5, 5, 5, 5, 1, 1, 1, 1, 1, 1, 8};

static const short yydefact[] = {
    2,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   207, 205, 209, 0,
    0,   0,   0,   0,   0,   236, 0,   0,   0,   0,   0,   244, 0,   0,   0,   0,   245, 249, 250,
    0,   0,   0,   0,   0,   160, 0,   0,   0,   253, 0,   0,   0,   0,   0,   0,   0,   0,   0,
    1,   3,   7,   4,   28,  64,  62,  15,  16,  17,  18,  19,  20,  272, 273, 268, 266, 267, 269,
    270, 271, 45,  274, 275, 58,  60,  61,  44,  41,  32,  43,  42,  9,   8,   10,  11,  12,  13,
    26,  29,  30,  31,  65,  21,  22,  14,  36,  37,  38,  39,  40,  34,  35,  66,  33,  276, 277,
    46,  47,  48,  49,  50,  51,  52,  53,  23,  24,  25,  54,  56,  55,  57,  59,  63,  27,  0,
    179, 180, 0,   259, 260, 263, 262, 261, 251, 241, 239, 240, 242, 243, 280, 282, 284, 0,   287,
    289, 302, 0,   304, 0,   0,   291, 309, 232, 0,   0,   298, 299, 300, 301, 0,   0,   0,   218,
    219, 221, 214, 216, 235, 238, 237, 234, 224, 223, 252, 136, 246, 0,   0,   0,   225, 247, 156,
    157, 158, 0,   172, 159, 0,   254, 255, 256, 257, 258, 0,   248, 278, 279, 0,   5,   6,   67,
    69,  0,   0,   0,   286, 0,   0,   0,   306, 0,   307, 308, 293, 0,   0,   0,   226, 0,   0,
    0,   229, 297, 197, 201, 208, 206, 191, 210, 0,   0,   0,   0,   0,   0,   0,   0,   164, 165,
    166, 167, 168, 169, 170, 171, 161, 162, 81,  311, 0,   0,   0,   0,   181, 281, 189, 283, 285,
    288, 290, 303, 305, 295, 0,   173, 292, 0,   310, 233, 227, 228, 231, 0,   0,   0,   0,   0,
    0,   0,   220, 222, 215, 217, 0,   211, 0,   138, 141, 140, 143, 142, 144, 145, 146, 147, 94,
    0,   98,  0,   0,   0,   265, 264, 0,   0,   0,   0,   71,  0,   73,  74,  75,  76,  0,   0,
    0,   0,   294, 0,   0,   0,   0,   230, 198, 202, 199, 203, 192, 193, 194, 213, 0,   137, 139,
    0,   0,   0,   163, 0,   0,   0,   0,   84,  87,  88,  86,  314, 0,   120, 124, 150, 0,   68,
    72,  78,  77,  79,  80,  70,  182, 190, 296, 175, 174, 176, 0,   0,   0,   0,   0,   0,   212,
    0,   0,   0,   0,   100, 116, 117, 115, 114, 102, 103, 104, 105, 106, 107, 108, 110, 109, 111,
    112, 113, 96,  0,   0,   0,   0,   0,   0,   82,  85,  314, 313, 312, 0,   0,   148, 0,   0,
    0,   0,   200, 204, 195, 0,   118, 0,   95,  101, 0,   99,  89,  93,  92,  91,  90,  0,   319,
    320, 321, 322, 0,   323, 324, 0,   0,   0,   122, 0,   126, 132, 133, 130, 128, 129, 131, 134,
    135, 0,   154, 178, 177, 185, 184, 183, 0,   196, 0,   0,   83,  0,   314, 314, 0,   0,   121,
    123, 125, 127, 0,   151, 0,   0,   119, 97,  0,   0,   0,   0,   0,   149, 152, 155, 153, 188,
    187, 186, 0,   317, 318, 316, 315, 0,   0,   0,   325, 0,   0,   0};

static const short yydefgoto[] = {
    505, 57,  58,  59,  60,  259, 260, 316, 61,  307, 435, 349, 350, 351, 352, 353, 62,  342,
    428, 344, 383, 384, 385, 386, 317, 413, 445, 318, 414, 447, 448, 63,  241, 293, 294, 319,
    457, 478, 320, 64,  65,  66,  67,  68,  192, 253, 254, 69,  273, 442, 262, 275, 264, 236,
    379, 233, 70,  168, 71,  167, 72,  169, 295, 339, 296, 73,  74,  75,  76,  77,  78,  79,
    80,  81,  82,  280, 83,  224, 84,  85,  86,  87,  88,  89,  90,  91,  92,  93,  94,  95,
    96,  97,  98,  99,  100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113,
    114, 210, 115, 211, 116, 212, 117, 118, 214, 119, 215, 120, 222, 271, 324, 121, 122, 123,
    124, 125, 216, 126, 218, 127, 128, 129, 130, 223, 131, 308, 355, 411, 444};

static const short yypact[] = {
    443,    -24,    116,    145,    -30,    -6,     96,     25,     96,     29,     285,    96,
    43,     32,     96,     -32768, -32768, -32768, 96,     96,     96,     96,     96,     68,
    -32768, 96,     96,     96,     96,     96,     -32768, 96,     72,     102,    258,    -32768,
    -32768, -32768, 96,     96,     137,    143,    151,    -32768, 96,     153,    157,    96,
    96,     96,     96,     96,     167,    96,     178,    184,    187,    443,    -32768, -32768,
    -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
    -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
    -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
    -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
    -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
    -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
    128,    -32768, -32768, 205,    -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
    -32768, -32768, -32768, -32768, -32768, -32768, 222,    -32768, -32768, -32768, 225,    -32768,
    229,    96,     232,    -32768, -32768, 231,    57,     241,    -32768, -32768, -32768, 103,
    103,    253,    -32768, 238,    254,    255,    257,    -32768, -32768, -32768, -32768, -32768,
    -32768, -32768, -32768, -32768, 267,    96,     271,    -32768, -32768, -32768, -32768, -32768,
    440,    -32768, -32768, 270,    -32768, -32768, -32768, -32768, -32768, 272,    -32768, -32768,
    -32768, 165,    -32768, -32768, -32768, -32768, 277,    289,    277,    -32768, 277,    289,
    277,    -32768, 277,    -32768, -32768, 283,    290,    96,     277,    -32768, 287,    291,
    292,    -32768, -32768, 297,    298,    300,    300,    208,    307,    96,     96,     96,
    96,     95,     288,    311,    294,    -32768, -32768, -32768, -32768, -32768, -32768, -32768,
    -32768, 310,    -32768, -32768, -32768, 305,    96,     530,    530,    -32768, 313,    -32768,
    315,    313,    313,    315,    313,    313,    -32768, 290,    321,    320,    324,    323,
    313,    -32768, -32768, -32768, 277,    333,    337,    108,    339,    293,    346,    -32768,
    -32768, -32768, -32768, 96,     -32768, 345,    95,     -32768, -32768, -32768, -32768, -32768,
    -32768, -32768, -32768, -32768, 348,    -32768, 440,    243,    372,    -32768, -32768, 349,
    350,    354,    355,    -32768, 236,    -32768, -32768, -32768, -32768, 325,    356,    360,
    290,    320,    121,    383,    96,     96,     313,    -32768, -32768, 376,    380,    -32768,
    -32768, 381,    -32768, 387,    -32768, -32768, 37,     386,    37,     -32768, 397,    216,
    96,     130,    -32768, -32768, -32768, -32768, 404,    392,    -32768, -32768, 411,    408,
    -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, 320,    -32768, -32768,
    416,    419,    422,    428,    432,    434,    429,    -32768, 579,    436,    437,    82,
    -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
    -32768, -32768, -32768, -32768, -32768, -32768, 114,    438,    439,    442,    444,    454,
    -32768, -32768, 296,    -32768, -32768, 620,    186,    -32768, 441,    233,    119,    96,
    -32768, -32768, -32768, 445,    -32768, 435,    -32768, -32768, 37,     -32768, -32768, -32768,
    -32768, -32768, -32768, 460,    -32768, -32768, -32768, -32768, 430,    -32768, -32768, 261,
    -20,    588,    -32768, 344,    -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
    -32768, 453,    552,    -32768, -32768, -32768, -32768, -32768, 462,    -32768, 96,     133,
    -32768, 326,    404,    404,    326,    326,    -32768, -32768, -32768, -32768, -70,    -32768,
    2,      152,    -32768, -32768, 461,    463,    464,    465,    466,    -32768, -32768, -32768,
    -32768, -32768, -32768, -32768, 96,     -32768, -32768, -32768, -32768, 469,    96,     468,
    -32768, 581,    582,    -32768};

static const short yypgoto[] = {
    -32768, -32768, 534,    -138,   536,    -32768, -32768, 347,    -32768, -32768, -32768, -32768,
    256,    -32768, -32768, -32768, -32768, -32768, -32768, -32768, -322,   -300,   -32768, -32768,
    -153,   -32768, -32768, -134,   -32768, -32768, 159,    -32768, -32768, 314,    -32768, -123,
    -32768, -32768, -305,   -32768, -32768, -32768, -32768, -32768, -32768, -32768, 303,    -32768,
    -256,   -1,     35,     -32768, 395,    -32768, -32768, 459,    -356,   -32768, -248,   -32768,
    -245,   -32768, -32768, -32768, -32768, -238,   -237,   -32768, -197,   -187,   -32768, -239,
    -32768, -330,   -313,   -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
    -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
    -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -390,   -235,   -233,
    -310,   -32768, -309,   -32768, -303,   -32768, -302,   -282,   -32768, -279,   -32768, -32768,
    -32768, -32768, -32768, -32768, -32768, -32768, -32768, -278,   -32768, -275,   -32768, -267,
    -266,   -254,   -232,   -32768, -32768, -32768, -32768, -328,   -181};

#define YYLAST 720

static const short yytable[] = {
    135, 137, 140, 297, 298, 143, 301, 145, 302, 162, 163, 365, 387, 166, 387, 325, 365, 170, 171,
    172, 173, 174, 402, 446, 176, 177, 178, 179, 180, 388, 181, 388, 389, 390, 389, 390, 314, 187,
    188, 391, 392, 391, 392, 193, 299, 489, 196, 197, 198, 199, 200, 380, 202, 387, 300, 475, 297,
    298, 449, 301, 393, 302, 393, 394, 395, 394, 395, 396, 369, 396, 388, 472, 387, 389, 390, 397,
    398, 397, 398, 141, 391, 392, 443, 427, 473, 132, 133, 134, 399, 388, 399, 449, 389, 390, 381,
    382, 380, 299, 387, 391, 392, 393, 427, 142, 394, 395, 467, 300, 396, 491, 400, 226, 400, 492,
    227, 388, 397, 398, 389, 390, 393, 315, 315, 394, 395, 391, 392, 396, 380, 399, 19,  20,  21,
    22,  144, 397, 398, 387, 146, 381, 382, 165, 485, 486, 291, 292, 393, 380, 399, 394, 395, 400,
    479, 396, 388, 164, 220, 389, 390, 228, 229, 397, 398, 362, 391, 392, 450, 427, 362, 451, 400,
    381, 382, 490, 399, 454, 452, 453, 361, 455, 175, 456, 363, 361, 243, 393, 182, 363, 394, 395,
    381, 382, 396, 364, 54,  55,  400, 426, 364, 450, 397, 398, 451, 346, 347, 348, 133, 134, 454,
    452, 453, 183, 455, 399, 456, 231, 232, 15,  16,  17,  333, 334, 274, 21,  22,  136, 133, 134,
    461, 429, 28,  462, 463, 370, 371, 400, 287, 288, 289, 290, 2,   3,   208, 311, 312, 408, 189,
    265, 483, 266, 10,  268, 190, 269, 138, 133, 134, 310, 139, 276, 191, 493, 194, 11,  494, 495,
    195, 15,  16,  17,  18,  19,  20,  21,  22,  23,  201, 25,  26,  27,  28,  29,  257, 258, 32,
    54,  55,  203, 484, 34,  338, 487, 488, 204, 404, 405, 36,  406, 38,  205, 147, 148, 149, 150,
    151, 152, 153, 154, 155, 156, 157, 158, 184, 185, 186, 330, 346, 347, 348, 209, 47,  48,  49,
    50,  51,  284, 285, 373, 374, 2,   3,   213, 311, 312, 217, 54,  55,  159, 219, 10,  225, 313,
    314, 221, 56,  459, 460, 407, 160, 161, 230, 360, 11,  470, 471, 237, 15,  16,  17,  18,  19,
    20,  21,  22,  23,  235, 25,  26,  27,  28,  29,  238, 239, 32,  240, 15,  16,  17,  34,  162,
    242, 21,  22,  244, 255, 36,  256, 38,  28,  261, 436, 437, 438, 439, 270, 133, 134, 440, 263,
    272, 277, 279, 303, 278, 336, 441, 133, 134, 305, 47,  48,  49,  50,  51,  281, 282, 410, 309,
    464, 283, 436, 437, 438, 439, 54,  55,  286, 440, 304, 306, 313, 314, 322, 56,  323, 441, 133,
    134, 326, 327, 366, 328, 329, 54,  55,  331, 1,   2,   3,   4,   332, 335, 5,   6,   7,   8,
    9,   10,  337, 476, 340, 343, 354, 356, 357, 482, 358, 359, 367, 368, 11,  12,  13,  14,  15,
    16,  17,  18,  19,  20,  21,  22,  23,  24,  25,  26,  27,  28,  29,  30,  31,  32,  372, 375,
    33,  501, 34,  376, 377, 378, 401, 503, 35,  36,  37,  38,  403, 412, 39,  40,  41,  42,  43,
    44,  45,  46,  245, 246, 247, 248, 249, 250, 251, 252, 410, 415, 416, 47,  48,  49,  50,  51,
    52,  417, 2,   3,   418, 311, 312, 419, 420, 53,  54,  55,  10,  421, 422, 423, 424, 425, 469,
    56,  458, 466, 430, 431, 465, 11,  432, 314, 433, 15,  16,  17,  18,  19,  20,  21,  22,  23,
    434, 25,  26,  27,  28,  29,  468, 480, 32,  481, 496, 506, 507, 34,  497, 498, 499, 500, 502,
    504, 36,  206, 38,  207, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 409, 477, 321,
    341, 345, 267, 0,   0,   0,   47,  48,  49,  50,  51,  15,  16,  17,  18,  19,  20,  21,  22,
    234, 0,   54,  55,  159, 28,  0,   0,   313, 314, 0,   56,  0,   0,   0,   0,   161, 0,   0,
    0,   0,   0,   0,   38,  15,  16,  17,  18,  19,  20,  21,  22,  0,   0,   0,   0,   0,   28,
    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   38,  0,
    0,   0,   0,   54,  55,  133, 134, 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
    474, 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   54,  55};

static const short yycheck[] = {
    1,   2,   3,   241, 241, 6,   241, 8,   241, 10,  11,  316, 342, 14,  344, 271, 321, 18,  19,
    20,  21,  22,  344, 413, 25,  26,  27,  28,  29,  342, 31,  344, 342, 342, 344, 344, 106, 38,
    39,  342, 342, 344, 344, 44,  241, 115, 47,  48,  49,  50,  51,  14,  53,  383, 241, 445, 294,
    294, 414, 294, 342, 294, 344, 342, 342, 344, 344, 342, 324, 344, 383, 91,  402, 383, 383, 342,
    342, 344, 344, 109, 383, 383, 410, 383, 104, 109, 110, 111, 342, 402, 344, 447, 402, 402, 57,
    58,  14,  294, 428, 402, 402, 383, 402, 109, 383, 383, 428, 294, 383, 107, 342, 54,  344, 111,
    57,  428, 383, 383, 428, 428, 402, 259, 260, 402, 402, 428, 428, 402, 14,  383, 35,  36,  37,
    38,  109, 402, 402, 467, 109, 57,  58,  109, 470, 471, 49,  50,  428, 14,  402, 428, 428, 383,
    457, 428, 467, 112, 157, 467, 467, 102, 103, 428, 428, 316, 467, 467, 414, 467, 321, 414, 402,
    57,  58,  478, 428, 414, 414, 414, 316, 414, 112, 414, 316, 321, 185, 467, 114, 321, 467, 467,
    57,  58,  467, 316, 99,  100, 428, 115, 321, 447, 467, 467, 447, 73,  74,  75,  110, 111, 447,
    447, 447, 109, 447, 467, 447, 112, 113, 31,  32,  33,  112, 113, 223, 37,  38,  109, 110, 111,
    109, 115, 44,  112, 113, 112, 113, 467, 237, 238, 239, 240, 4,   5,   114, 7,   8,   115, 109,
    212, 115, 214, 14,  216, 109, 218, 109, 110, 111, 258, 113, 224, 109, 109, 109, 27,  112, 113,
    109, 31,  32,  33,  34,  35,  36,  37,  38,  39,  109, 41,  42,  43,  44,  45,  117, 118, 48,
    99,  100, 109, 469, 53,  291, 472, 473, 109, 78,  79,  60,  81,  62,  112, 15,  16,  17,  18,
    19,  20,  21,  22,  23,  24,  25,  26,  54,  55,  56,  280, 73,  74,  75,  114, 84,  85,  86,
    87,  88,  117, 118, 328, 329, 4,   5,   109, 7,   8,   109, 99,  100, 52,  109, 14,  109, 105,
    106, 111, 108, 112, 113, 348, 63,  64,  109, 115, 27,  92,  93,  117, 31,  32,  33,  34,  35,
    36,  37,  38,  39,  112, 41,  42,  43,  44,  45,  117, 117, 48,  117, 31,  32,  33,  53,  380,
    113, 37,  38,  112, 114, 60,  114, 62,  44,  112, 94,  95,  96,  97,  111, 110, 111, 101, 109,
    109, 113, 109, 114, 112, 111, 109, 110, 111, 114, 84,  85,  86,  87,  88,  117, 117, 120, 112,
    419, 119, 94,  95,  96,  97,  99,  100, 119, 101, 117, 119, 105, 106, 119, 108, 119, 109, 110,
    111, 117, 119, 115, 117, 119, 99,  100, 112, 3,   4,   5,   6,   113, 112, 9,   10,  11,  12,
    13,  14,  112, 115, 115, 113, 90,  114, 114, 466, 112, 112, 112, 109, 27,  28,  29,  30,  31,
    32,  33,  34,  35,  36,  37,  38,  39,  40,  41,  42,  43,  44,  45,  46,  47,  48,  109, 117,
    51,  496, 53,  117, 117, 112, 114, 502, 59,  60,  61,  62,  109, 115, 65,  66,  67,  68,  69,
    70,  71,  72,  76,  77,  78,  79,  80,  81,  82,  83,  120, 114, 118, 84,  85,  86,  87,  88,
    89,  117, 4,   5,   117, 7,   8,   117, 112, 98,  99,  100, 14,  113, 112, 118, 112, 112, 120,
    108, 111, 118, 116, 116, 111, 27,  116, 106, 116, 31,  32,  33,  34,  35,  36,  37,  38,  39,
    116, 41,  42,  43,  44,  45,  116, 25,  48,  117, 119, 0,   0,   53,  121, 121, 121, 121, 119,
    121, 60,  57,  62,  57,  15,  16,  17,  18,  19,  20,  21,  22,  23,  24,  25,  349, 447, 260,
    294, 306, 215, -1,  -1,  -1,  84,  85,  86,  87,  88,  31,  32,  33,  34,  35,  36,  37,  38,
    168, -1,  99,  100, 52,  44,  -1,  -1,  105, 106, -1,  108, -1,  -1,  -1,  -1,  64,  -1,  -1,
    -1,  -1,  -1,  -1,  62,  31,  32,  33,  34,  35,  36,  37,  38,  -1,  -1,  -1,  -1,  -1,  44,
    -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  62,  -1,
    -1,  -1,  -1,  99,  100, 110, 111, -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
    115, -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  99,  100};

#line 352 "../bison++/bison.cc"
/* fattrs + tables */

/* parser code folow  */

/* This is the parser code that is written into each bison parser
  when the %semantic_parser declaration is not specified in the grammar.
  It was written by Richard Stallman by simplifying the hairy parser
  used when %semantic_parser is specified.  */

/* Note: dollar marks section change
   the next  is replaced by the list of actions, each action
   as one case of the switch.  */

#if YY_SrvParser_USE_GOTO != 0
/*
 SUPRESSION OF GOTO : on some C++ compiler (sun c++)
  the goto is strictly forbidden if any constructor/destructor
  is used in the whole function (very stupid isn't it ?)
 so goto are to be replaced with a 'while/switch/case construct'
 here are the macro to keep some apparent compatibility
*/
#define YYGOTO(lb)     \
  {                    \
    yy_gotostate = lb; \
    continue;          \
  }
#define YYBEGINGOTO                          \
  enum yy_labels yy_gotostate = yygotostart; \
  for (;;) switch (yy_gotostate) {           \
      case yygotostart: {
#define YYLABEL(lb) \
  }                 \
  case lb: {
#define YYENDGOTO \
  }               \
  }
#define YYBEGINDECLARELABEL enum yy_labels { yygotostart
#define YYDECLARELABEL(lb) , lb
#define YYENDDECLARELABEL }
#else
/* macro to keep goto */
#define YYGOTO(lb) goto lb
#define YYBEGINGOTO
#define YYLABEL(lb) \
  lb:
#define YYENDGOTO
#define YYBEGINDECLARELABEL
#define YYDECLARELABEL(lb)
#define YYENDDECLARELABEL
#endif
/* LABEL DECLARATION */
YYBEGINDECLARELABEL
YYDECLARELABEL(yynewstate)
YYDECLARELABEL(yybackup)
/* YYDECLARELABEL(yyresume) */
YYDECLARELABEL(yydefault)
YYDECLARELABEL(yyreduce)
YYDECLARELABEL(yyerrlab)     /* here on detecting error */
YYDECLARELABEL(yyerrlab1)    /* here on error raised explicitly by an action */
YYDECLARELABEL(yyerrdefault) /* current state does not do anything special for
                                the error token. */
YYDECLARELABEL(yyerrpop)     /* pop the current state because it cannot handle the
                                error token */
YYDECLARELABEL(yyerrhandle)
YYENDDECLARELABEL
/* ALLOCA SIMULATION */
/* __HAVE_NO_ALLOCA */
#ifdef __HAVE_NO_ALLOCA
int __alloca_free_ptr(char *ptr, char *ref) {
  if (ptr != ref) free(ptr);
  return 0;
}

#define __ALLOCA_alloca(size) malloc(size)
#define __ALLOCA_free(ptr, ref) __alloca_free_ptr((char *)ptr, (char *)ref)

#ifdef YY_SrvParser_LSP_NEEDED
#define __ALLOCA_return(num)                                                                       \
  do {                                                                                             \
    return (__ALLOCA_free(yyss, yyssa) + __ALLOCA_free(yyvs, yyvsa) + __ALLOCA_free(yyls, yylsa) + \
            (num));                                                                                \
  } while (0)
#else
#define __ALLOCA_return(num)                                                  \
  do {                                                                        \
    return (__ALLOCA_free(yyss, yyssa) + __ALLOCA_free(yyvs, yyvsa) + (num)); \
  } while (0)
#endif
#else
#define __ALLOCA_return(num) \
  do {                       \
    return (num);            \
  } while (0)
#define __ALLOCA_alloca(size) alloca(size)
#define __ALLOCA_free(ptr, ref)
#endif

/* ENDALLOCA SIMULATION */

#define yyerrok (yyerrstatus = 0)
#define yyclearin (YY_SrvParser_CHAR = YYEMPTY)
#define YYEMPTY -2
#define YYEOF 0
#define YYACCEPT __ALLOCA_return(0)
#define YYABORT __ALLOCA_return(1)
#define YYERROR YYGOTO(yyerrlab1)
/* Like YYERROR except do call yyerror.
   This remains here temporarily to ease the
   transition to the new meaning of YYERROR, for GCC.
   Once GCC version 2 has supplanted version 1, this can go.  */
#define YYFAIL YYGOTO(yyerrlab)
#define YYRECOVERING() (!!yyerrstatus)
#define YYBACKUP(token, value)                                  \
  do                                                            \
    if (YY_SrvParser_CHAR == YYEMPTY && yylen == 1) {           \
      YY_SrvParser_CHAR = (token), YY_SrvParser_LVAL = (value); \
      yychar1 = YYTRANSLATE(YY_SrvParser_CHAR);                 \
      YYPOPSTACK;                                               \
      YYGOTO(yybackup);                                         \
    } else {                                                    \
      YY_SrvParser_ERROR("syntax error: cannot back up");       \
      YYERROR;                                                  \
    }                                                           \
  while (0)

#define YYTERROR 1
#define YYERRCODE 256

#ifndef YY_SrvParser_PURE
/* UNPURE */
#define YYLEX YY_SrvParser_LEX()
#ifndef YY_USE_CLASS
/* If nonreentrant, and not class , generate the variables here */
int YY_SrvParser_CHAR;                /*  the lookahead symbol        */
YY_SrvParser_STYPE YY_SrvParser_LVAL; /*  the semantic value of the */
                                      /*  lookahead symbol    */
int YY_SrvParser_NERRS;               /*  number of parse errors so far */
#ifdef YY_SrvParser_LSP_NEEDED
YY_SrvParser_LTYPE YY_SrvParser_LLOC; /*  location data for the lookahead     */
                                      /*  symbol                              */
#endif
#endif

#else
/* PURE */
#ifdef YY_SrvParser_LSP_NEEDED
#define YYLEX YY_SrvParser_LEX(&YY_SrvParser_LVAL, &YY_SrvParser_LLOC)
#else
#define YYLEX YY_SrvParser_LEX(&YY_SrvParser_LVAL)
#endif
#endif
#ifndef YY_USE_CLASS
#if YY_SrvParser_DEBUG != 0
int YY_SrvParser_DEBUG_FLAG; /*  nonzero means print parse trace     */
/* Since this is uninitialized, it does not stop multiple parsers
   from coexisting.  */
#endif
#endif

/*  YYINITDEPTH indicates the initial size of the parser's stacks       */

#ifndef YYINITDEPTH
#define YYINITDEPTH 200
#endif

/*  YYMAXDEPTH is the maximum size the stacks can grow to
    (effective only if the built-in stack extension method is used).  */

#if YYMAXDEPTH == 0
#undef YYMAXDEPTH
#endif

#ifndef YYMAXDEPTH
#define YYMAXDEPTH 10000
#endif

#if __GNUC__ > 1 /* GNU C and GNU C++ define this.  */
#define __yy_bcopy(FROM, TO, COUNT) __builtin_memcpy(TO, FROM, COUNT)
#else /* not GNU C or C++ */

/* This is the most reliable way to avoid incompatibilities
   in available built-in functions on various systems.  */

#ifdef __cplusplus
static void __yy_bcopy(char *from, char *to, int count)
#else
#ifdef __STDC__
static void __yy_bcopy(char *from, char *to, int count)
#else
static void __yy_bcopy(from, to, count) char *from;
char *to;
int count;
#endif
#endif
{
  register char *f = from;
  register char *t = to;
  register int i = count;

  while (i-- > 0) *t++ = *f++;
}
#endif

int
#ifdef YY_USE_CLASS
 YY_SrvParser_CLASS::
#endif
     YY_SrvParser_PARSE(YY_SrvParser_PARSE_PARAM)
#ifndef __STDC__
#ifndef __cplusplus
#ifndef YY_USE_CLASS
/* parameter definition without protypes */
YY_SrvParser_PARSE_PARAM_DEF
#endif
#endif
#endif
{
  register int yystate;
  register int yyn;
  register short *yyssp;
  register YY_SrvParser_STYPE *yyvsp;
  int yyerrstatus; /*  number of tokens to shift before error messages enabled
                    */
  int yychar1 = 0; /*  lookahead token as an internal (translated) token number */

  short yyssa[YYINITDEPTH];              /*  the state stack                     */
  YY_SrvParser_STYPE yyvsa[YYINITDEPTH]; /*  the semantic value stack */

  short *yyss = yyssa;              /*  refer to the stacks thru separate pointers */
  YY_SrvParser_STYPE *yyvs = yyvsa; /*  to allow yyoverflow to reallocate them elsewhere */

#ifdef YY_SrvParser_LSP_NEEDED
  YY_SrvParser_LTYPE yylsa[YYINITDEPTH]; /*  the location stack */
  YY_SrvParser_LTYPE *yyls = yylsa;
  YY_SrvParser_LTYPE *yylsp;

#define YYPOPSTACK (yyvsp--, yyssp--, yylsp--)
#else
#define YYPOPSTACK (yyvsp--, yyssp--)
#endif

  int yystacksize = YYINITDEPTH;

#ifdef YY_SrvParser_PURE
  int YY_SrvParser_CHAR;
  YY_SrvParser_STYPE YY_SrvParser_LVAL;
  int YY_SrvParser_NERRS;
#ifdef YY_SrvParser_LSP_NEEDED
  YY_SrvParser_LTYPE YY_SrvParser_LLOC;
#endif
#endif

  YY_SrvParser_STYPE yyval; /*  the variable used to return         */
  /*  semantic values from the action     */
  /*  routines                            */

  int yylen;
  /* start loop, in which YYGOTO may be used. */
  YYBEGINGOTO

#if YY_SrvParser_DEBUG != 0
  if (YY_SrvParser_DEBUG_FLAG) fprintf(stderr, "Starting parse\n");
#endif
  yystate = 0;
  yyerrstatus = 0;
  YY_SrvParser_NERRS = 0;
  YY_SrvParser_CHAR = YYEMPTY; /* Cause a token to be read.  */

  /* Initialize stack pointers.
     Waste one element of value and location stack
     so that they stay on the same level as the state stack.
     The wasted elements are never initialized.  */

  yyssp = yyss - 1;
  yyvsp = yyvs;
#ifdef YY_SrvParser_LSP_NEEDED
  yylsp = yyls;
#endif

  /* Push a new state, which is found in  yystate  .  */
  /* In all cases, when you get here, the value and location stacks
     have just been pushed. so pushing a state here evens the stacks.  */
  YYLABEL(yynewstate)

  *++yyssp = yystate;

  if (yyssp >= yyss + yystacksize - 1) {
    /* Give user a chance to reallocate the stack */
    /* Use copies of these so that the &'s don't force the real ones into
     * memory. */
    YY_SrvParser_STYPE *yyvs1 = yyvs;
    short *yyss1 = yyss;
#ifdef YY_SrvParser_LSP_NEEDED
    YY_SrvParser_LTYPE *yyls1 = yyls;
#endif

    /* Get the current used size of the three stacks, in elements.  */
    int size = yyssp - yyss + 1;

#ifdef yyoverflow
    /* Each stack pointer address is followed by the size of
       the data in use in that stack, in bytes.  */
#ifdef YY_SrvParser_LSP_NEEDED
    /* This used to be a conditional around just the two extra args,
       but that might be undefined if yyoverflow is a macro.  */
    yyoverflow("parser stack overflow", &yyss1, size * sizeof(*yyssp), &yyvs1,
               size * sizeof(*yyvsp), &yyls1, size * sizeof(*yylsp), &yystacksize);
#else
    // cppcheck-suppress constStatement
    yyoverflow("parser stack overflow", &yyss1, size * sizeof(*yyssp), &yyvs1,
               size * sizeof(*yyvsp), &yystacksize);
#endif

    yyss = yyss1;
    yyvs = yyvs1;
#ifdef YY_SrvParser_LSP_NEEDED
    yyls = yyls1;
#endif
#else /* no yyoverflow */
    /* Extend the stack our own way.  */
    if (yystacksize >= YYMAXDEPTH) {
      YY_SrvParser_ERROR(((char *)"parser stack overflow"));
      __ALLOCA_return(2);
    }
    yystacksize *= 2;
    if (yystacksize > YYMAXDEPTH) yystacksize = YYMAXDEPTH;
    yyss = (short *)__ALLOCA_alloca(yystacksize * sizeof(*yyssp));
    __yy_bcopy((char *)yyss1, (char *)yyss, size * sizeof(*yyssp));
    __ALLOCA_free(yyss1, yyssa);
    yyvs = (YY_SrvParser_STYPE *)__ALLOCA_alloca(yystacksize * sizeof(*yyvsp));
    __yy_bcopy((char *)yyvs1, (char *)yyvs, size * sizeof(*yyvsp));
    __ALLOCA_free(yyvs1, yyvsa);
#ifdef YY_SrvParser_LSP_NEEDED
    yyls = (YY_SrvParser_LTYPE *)__ALLOCA_alloca(yystacksize * sizeof(*yylsp));
    __yy_bcopy((char *)yyls1, (char *)yyls, size * sizeof(*yylsp));
    __ALLOCA_free(yyls1, yylsa);
#endif
#endif /* no yyoverflow */

    yyssp = yyss + size - 1;
    yyvsp = yyvs + size - 1;
#ifdef YY_SrvParser_LSP_NEEDED
    yylsp = yyls + size - 1;
#endif

#if YY_SrvParser_DEBUG != 0
    if (YY_SrvParser_DEBUG_FLAG) fprintf(stderr, "Stack size increased to %d\n", yystacksize);
#endif

    if (yyssp >= yyss + yystacksize - 1) YYABORT;
  }

#if YY_SrvParser_DEBUG != 0
  if (YY_SrvParser_DEBUG_FLAG) fprintf(stderr, "Entering state %d\n", yystate);
#endif

  YYGOTO(yybackup);
  YYLABEL(yybackup)

  /* Do appropriate processing given the current state.  */
  /* Read a lookahead token if we need one and don't already have one.  */
  /* YYLABEL(yyresume) */

  /* First try to decide what to do without reference to lookahead token.  */

  yyn = yypact[yystate];
  if (yyn == YYFLAG) YYGOTO(yydefault);

  /* Not known => get a lookahead token if don't already have one.  */

  /* yychar is either YYEMPTY or YYEOF
     or a valid token in external form.  */

  if (YY_SrvParser_CHAR == YYEMPTY) {
#if YY_SrvParser_DEBUG != 0
    if (YY_SrvParser_DEBUG_FLAG) fprintf(stderr, "Reading a token: ");
#endif
    YY_SrvParser_CHAR = YYLEX;
  }

  /* Convert token to internal form (in yychar1) for indexing tables with */

  if (YY_SrvParser_CHAR <= 0) /* This means end of input. */
  {
    yychar1 = 0;
    YY_SrvParser_CHAR = YYEOF; /* Don't call YYLEX any more */

#if YY_SrvParser_DEBUG != 0
    if (YY_SrvParser_DEBUG_FLAG) fprintf(stderr, "Now at end of input.\n");
#endif
  } else {
    yychar1 = YYTRANSLATE(YY_SrvParser_CHAR);

#if YY_SrvParser_DEBUG != 0
    if (YY_SrvParser_DEBUG_FLAG) {
      fprintf(stderr, "Next token is %d (%s", YY_SrvParser_CHAR, yytname[yychar1]);
      /* Give the individual parser a way to print the precise meaning
         of a token, for further debugging info.  */
#ifdef YYPRINT
      YYPRINT(stderr, YY_SrvParser_CHAR, YY_SrvParser_LVAL);
#endif
      fprintf(stderr, ")\n");
    }
#endif
  }

  yyn += yychar1;
  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != yychar1) YYGOTO(yydefault);

  yyn = yytable[yyn];

  /* yyn is what to do for this token type in this state.
     Negative => reduce, -yyn is rule number.
     Positive => shift, yyn is new state.
       New state is final state => don't bother to shift,
       just return success.
     0, or most negative number => error.  */

  if (yyn < 0) {
    if (yyn == YYFLAG) YYGOTO(yyerrlab);
    yyn = -yyn;
    YYGOTO(yyreduce);
  } else if (yyn == 0)
    YYGOTO(yyerrlab);

  if (yyn == YYFINAL) YYACCEPT;

    /* Shift the lookahead token.  */

#if YY_SrvParser_DEBUG != 0
  if (YY_SrvParser_DEBUG_FLAG)
    fprintf(stderr, "Shifting token %d (%s), ", YY_SrvParser_CHAR, yytname[yychar1]);
#endif

  /* Discard the token being shifted unless it is eof.  */
  if (YY_SrvParser_CHAR != YYEOF) YY_SrvParser_CHAR = YYEMPTY;

  *++yyvsp = YY_SrvParser_LVAL;
#ifdef YY_SrvParser_LSP_NEEDED
  *++yylsp = YY_SrvParser_LLOC;
#endif

  /* count tokens shifted since error; after three, turn off error status.  */
  if (yyerrstatus) yyerrstatus--;

  yystate = yyn;
  YYGOTO(yynewstate);

  /* Do the default action for the current state.  */
  YYLABEL(yydefault)

  yyn = yydefact[yystate];
  if (yyn == 0) YYGOTO(yyerrlab);

  /* Do a reduction.  yyn is the number of a rule to reduce with.  */
  YYLABEL(yyreduce)
  yylen = yyr2[yyn];
  if (yylen > 0) yyval = yyvsp[1 - yylen]; /* implement default value of the action */

#if YY_SrvParser_DEBUG != 0
  if (YY_SrvParser_DEBUG_FLAG) {
    int i;

    fprintf(stderr, "Reducing via rule %d (line %d), ", yyn, yyrline[yyn]);

    /* Print the symbols being reduced, and their result.  */
    for (i = yyprhs[yyn]; yyrhs[i] > 0; i++) fprintf(stderr, "%s ", yytname[yyrhs[i]]);
    fprintf(stderr, " -> %s\n", yytname[yyr1[yyn]]);
  }
#endif

#line 840 "../bison++/bison.cc"

  switch (yyn) {

    case 67:
#line 242 "SrvParser.y"
    {
      if (!StartIfaceDeclaration(yyvsp[-1].strval)) YYABORT;
      ;
      break;
    }
    case 68:
#line 247 "SrvParser.y"
    {
      // Information about new interface has been read
      // Add it to list of read interfaces
      delete[] yyvsp[-4].strval;
      EndIfaceDeclaration();
      ;
      break;
    }
    case 69:
#line 255 "SrvParser.y"
    {
      if (!StartIfaceDeclaration(yyvsp[-1].ival)) YYABORT;
      ;
      break;
    }
    case 70:
#line 260 "SrvParser.y"
    {
      EndIfaceDeclaration();
      ;
      break;
    }
    case 81:
#line 279 "SrvParser.y"
    {
      /// this is key object initialization part
      CurrentKey = new TSIGKey(string(yyvsp[-1].strval));
      ;
      break;
    }
    case 82:
#line 284 "SrvParser.y"
    {
      /// check that both secret and algorithm keywords were defined.
      Log(Debug) << "Loaded key '" << CurrentKey->Name_ << "', base64len is "
                 << CurrentKey->getBase64Data().length() << ", rawlen is "
                 << CurrentKey->getPackedData().length() << "." << LogEnd;
      if (CurrentKey->getPackedData().length() == 0) {
        Log(Crit) << "Key " << CurrentKey->Name_ << " does not have secret specified." << LogEnd;
        YYABORT;
      }

      if ((CurrentKey->Digest_ != DIGEST_HMAC_MD5) && (CurrentKey->Digest_ != DIGEST_HMAC_SHA1) &&
          (CurrentKey->Digest_ != DIGEST_HMAC_SHA256)) {
        Log(Crit) << "Invalid key type specified: only hmac-md5, hmac-sha1 and "
                  << "hmac-sha256 are supported." << LogEnd;
        YYABORT;
      }
#if !defined(MOD_SRV_DISABLE_DNSUPDATE) && !defined(MOD_CLNT_DISABLE_DNSUPDATE)
      CfgMgr->addKey(CurrentKey);
#else
      Log(Crit) << "DNS Update disabled at compilation time. Can't specify TSIG key." << LogEnd;
#endif
      ;
      break;
    }
    case 89:
#line 323 "SrvParser.y"
    {
      // store the key in base64 encoded form
      CurrentKey->setData(string(yyvsp[-1].strval));
      ;
      break;
    }
    case 90:
#line 330 "SrvParser.y"
    {
      CurrentKey->Fudge_ = yyvsp[-1].ival;
      ;
      break;
    }
    case 91:
#line 335 "SrvParser.y"
    {
      CurrentKey->Digest_ = DIGEST_HMAC_SHA256;
      ;
      break;
    }
    case 92:
#line 336 "SrvParser.y"
    {
      CurrentKey->Digest_ = DIGEST_HMAC_SHA1;
      ;
      break;
    }
    case 93:
#line 337 "SrvParser.y"
    {
      CurrentKey->Digest_ = DIGEST_HMAC_MD5;
      ;
      break;
    }
    case 94:
#line 343 "SrvParser.y"
    {
      ParserOptStack.append(new TSrvParsGlobalOpt());
      SPtr<TDUID> duid = new TDUID(yyvsp[-1].duidval.duid, yyvsp[-1].duidval.length);
      ClientLst.append(new TSrvCfgOptions(duid));
      ;
      break;
    }
    case 95:
#line 349 "SrvParser.y"
    {
      Log(Debug) << "Exception: DUID-based exception specified." << LogEnd;
      // copy all defined options
      ClientLst.getLast()->setOptions(ParserOptStack.getLast());
      ParserOptStack.delLast();
      ;
      break;
    }
    case 96:
#line 357 "SrvParser.y"
    {
      ParserOptStack.append(new TSrvParsGlobalOpt());
      SPtr<TOptVendorData> remoteid =
          new TOptVendorData(yyvsp[-3].ival, yyvsp[-1].duidval.duid, yyvsp[-1].duidval.length, 0);
      ClientLst.append(new TSrvCfgOptions(remoteid));
      ;
      break;
    }
    case 97:
#line 363 "SrvParser.y"
    {
      Log(Debug) << "Exception: RemoteID-based exception specified." << LogEnd;
      // copy all defined options
      ClientLst.getLast()->setOptions(ParserOptStack.getLast());
      ParserOptStack.delLast();
      ;
      break;
    }
    case 98:
#line 371 "SrvParser.y"
    {
      ParserOptStack.append(new TSrvParsGlobalOpt());
      SPtr<TIPv6Addr> clntaddr = new TIPv6Addr(yyvsp[-1].addrval);
      ClientLst.append(new TSrvCfgOptions(clntaddr));
      ;
      break;
    }
    case 99:
#line 377 "SrvParser.y"
    {
      Log(Debug) << "Exception: Link-local-based exception specified." << LogEnd;
      // copy all defined options
      ClientLst.getLast()->setOptions(ParserOptStack.getLast());
      ParserOptStack.delLast();
      ;
      break;
    }
    case 118:
#line 410 "SrvParser.y"
    {
      addr = new TIPv6Addr(yyvsp[0].addrval);
      Log(Info) << "Exception: Address " << addr->getPlain() << " reserved." << LogEnd;
      ClientLst.getLast()->setAddr(addr);
      ;
      break;
    }
    case 119:
#line 418 "SrvParser.y"
    {
      addr = new TIPv6Addr(yyvsp[-2].addrval);
      Log(Info) << "Exception: Prefix " << addr->getPlain() << "/" << yyvsp[0].ival << " reserved."
                << LogEnd;
      ClientLst.getLast()->setPrefix(addr, yyvsp[0].ival);
      ;
      break;
    }
    case 120:
#line 427 "SrvParser.y"
    {
      StartClassDeclaration();
      ;
      break;
    }
    case 121:
#line 431 "SrvParser.y"
    {
      if (!EndClassDeclaration()) YYABORT;
      ;
      break;
    }
    case 124:
#line 445 "SrvParser.y"
    {
      StartTAClassDeclaration();
      ;
      break;
    }
    case 125:
#line 448 "SrvParser.y"
    {
      if (!EndTAClassDeclaration()) YYABORT;
      ;
      break;
    }
    case 136:
#line 472 "SrvParser.y"
    {
      StartPDDeclaration();
      ;
      break;
    }
    case 137:
#line 475 "SrvParser.y"
    {
      if (!EndPDDeclaration()) YYABORT;
      ;
      break;
    }
    case 148:
#line 502 "SrvParser.y"
    {
      SPtr<TIPv6Addr> routerAddr = new TIPv6Addr(yyvsp[-1].addrval);
      SPtr<TOpt> myNextHop = new TOptAddr(OPTION_NEXT_HOP, routerAddr, NULL);
      nextHop = myNextHop;
      ;
      break;
    }
    case 149:
#line 508 "SrvParser.y"
    {
      ParserOptStack.getLast()->addExtraOption(nextHop, false);
      nextHop.reset();
      ;
      break;
    }
    case 150:
#line 513 "SrvParser.y"
    {
      SPtr<TIPv6Addr> routerAddr = new TIPv6Addr(yyvsp[0].addrval);
      SPtr<TOpt> myNextHop = new TOptAddr(OPTION_NEXT_HOP, routerAddr, NULL);
      ParserOptStack.getLast()->addExtraOption(myNextHop, false);
      ;
      break;
    }
    case 153:
#line 527 "SrvParser.y"
    {
      SPtr<TIPv6Addr> prefix = new TIPv6Addr(yyvsp[-4].addrval);
      SPtr<TOpt> rtPrefix = new TOptRtPrefix(yyvsp[0].ival, yyvsp[-2].ival, 42, prefix, NULL);
      if (nextHop)
        nextHop->addOption(rtPrefix);
      else
        ParserOptStack.getLast()->addExtraOption(rtPrefix, false);
      ;
      break;
    }
    case 154:
#line 536 "SrvParser.y"
    {
      SPtr<TIPv6Addr> prefix = new TIPv6Addr(yyvsp[-2].addrval);
      SPtr<TOpt> rtPrefix = new TOptRtPrefix(DHCPV6_INFINITY, yyvsp[0].ival, 42, prefix, NULL);
      if (nextHop)
        nextHop->addOption(rtPrefix);
      else
        ParserOptStack.getLast()->addExtraOption(rtPrefix, false);
      ;
      break;
    }
    case 155:
#line 545 "SrvParser.y"
    {
      SPtr<TIPv6Addr> prefix = new TIPv6Addr(yyvsp[-4].addrval);
      SPtr<TOpt> rtPrefix = new TOptRtPrefix(DHCPV6_INFINITY, yyvsp[-2].ival, 42, prefix, NULL);
      if (nextHop)
        nextHop->addOption(rtPrefix);
      else
        ParserOptStack.getLast()->addExtraOption(rtPrefix, false);
      ;
      break;
    }
    case 156:
#line 555 "SrvParser.y"
    {

#ifndef MOD_DISABLE_AUTH
      if (!strcasecmp(yyvsp[0].strval, "none")) {
        CfgMgr->setAuthProtocol(AUTH_PROTO_NONE);
        CfgMgr->setAuthAlgorithm(AUTH_ALGORITHM_NONE);
      } else if (!strcasecmp(yyvsp[0].strval, "delayed")) {
        CfgMgr->setAuthProtocol(AUTH_PROTO_DELAYED);
      } else if (!strcasecmp(yyvsp[0].strval, "reconfigure-key")) {
        CfgMgr->setAuthProtocol(AUTH_PROTO_RECONFIGURE_KEY);
        CfgMgr->setAuthAlgorithm(AUTH_ALGORITHM_RECONFIGURE_KEY);
      } else if (!strcasecmp(yyvsp[0].strval, "dibbler")) {
        CfgMgr->setAuthProtocol(AUTH_PROTO_DIBBLER);
      } else {
        Log(Crit) << "Invalid auth-protocol parameter: " << string(yyvsp[0].strval) << LogEnd;
        YYABORT;
      }
#else
      Log(Crit) << "Auth support disabled at compilation time." << LogEnd;
#endif
      ;
      break;
    }
    case 157:
#line 578 "SrvParser.y"
    {
      Log(Crit) << "auth-algorithm secification is not supported yet." << LogEnd;
      YYABORT;
      ;
      break;
    }
    case 158:
#line 584 "SrvParser.y"
    {

#ifndef MOD_DISABLE_AUTH
      if (strcasecmp(yyvsp[0].strval, "none")) {
        CfgMgr->setAuthReplay(AUTH_REPLAY_NONE);
      } else if (strcasecmp(yyvsp[0].strval, "monotonic")) {
        CfgMgr->setAuthReplay(AUTH_REPLAY_MONOTONIC);
      } else {
        Log(Crit) << "Invalid auth-replay parameter: " << string(yyvsp[0].strval) << LogEnd;
        YYABORT;
      }
#else
      Log(Crit) << "Auth support disabled at compilation time." << LogEnd;
#endif

      ;
      break;
    }
    case 159:
#line 602 "SrvParser.y"
    {
#ifndef MOD_DISABLE_AUTH
      CfgMgr->setAuthRealm(std::string(yyvsp[0].strval));
#else
      Log(Crit) << "Auth support disabled at compilation time." << LogEnd;
#endif
      ;
      break;
    }
    case 160:
#line 612 "SrvParser.y"
    {
      DigestLst.clear();
      ;
      break;
    }
    case 161:
#line 614 "SrvParser.y"
    {
#ifndef MOD_DISABLE_AUTH
      CfgMgr->setAuthDigests(DigestLst);
      CfgMgr->setAuthDropUnauthenticated(true);
      DigestLst.clear();
#else
      Log(Crit) << "Auth support disabled at compilation time." << LogEnd;
#endif
      ;
      break;
    }
    case 164:
#line 630 "SrvParser.y"
    {
      DigestLst.push_back(DIGEST_NONE);
      ;
      break;
    }
    case 165:
#line 631 "SrvParser.y"
    {
      DigestLst.push_back(DIGEST_PLAIN);
      ;
      break;
    }
    case 166:
#line 632 "SrvParser.y"
    {
      DigestLst.push_back(DIGEST_HMAC_MD5);
      ;
      break;
    }
    case 167:
#line 633 "SrvParser.y"
    {
      DigestLst.push_back(DIGEST_HMAC_SHA1);
      ;
      break;
    }
    case 168:
#line 634 "SrvParser.y"
    {
      DigestLst.push_back(DIGEST_HMAC_SHA224);
      ;
      break;
    }
    case 169:
#line 635 "SrvParser.y"
    {
      DigestLst.push_back(DIGEST_HMAC_SHA256);
      ;
      break;
    }
    case 170:
#line 636 "SrvParser.y"
    {
      DigestLst.push_back(DIGEST_HMAC_SHA384);
      ;
      break;
    }
    case 171:
#line 637 "SrvParser.y"
    {
      DigestLst.push_back(DIGEST_HMAC_SHA512);
      ;
      break;
    }
    case 172:
#line 642 "SrvParser.y"
    {
#ifndef MOD_DISABLE_AUTH
      CfgMgr->setAuthDropUnauthenticated(yyvsp[0].ival);
#else
      Log(Crit) << "Auth support disabled at compilation time." << LogEnd;
#endif
      ;
      break;
    }
    case 173:
#line 660 "SrvParser.y"
    {
      Log(Notice) << "FQDN: The client " << yyvsp[0].strval << " has no address nor DUID" << LogEnd;
      PresentFQDNLst.append(new TFQDN(yyvsp[0].strval, false));
      ;
      break;
    }
    case 174:
#line 665 "SrvParser.y"
    {
      /// @todo: Use SPtr()
      TDUID *duidNew = new TDUID(yyvsp[0].duidval.duid, yyvsp[0].duidval.length);
      Log(Debug) << "FQDN:" << yyvsp[-2].strval << " reserved for DUID " << duidNew->getPlain()
                 << LogEnd;
      PresentFQDNLst.append(new TFQDN(duidNew, yyvsp[-2].strval, false));
      ;
      break;
    }
    case 175:
#line 672 "SrvParser.y"
    {
      addr = new TIPv6Addr(yyvsp[0].addrval);
      Log(Debug) << "FQDN:" << yyvsp[-2].strval << " reserved for address " << *addr << LogEnd;
      PresentFQDNLst.append(new TFQDN(new TIPv6Addr(yyvsp[0].addrval), yyvsp[-2].strval, false));
      ;
      break;
    }
    case 176:
#line 678 "SrvParser.y"
    {
      Log(Debug) << "FQDN:" << yyvsp[0].strval << " has no reservations (is available to everyone)."
                 << LogEnd;
      PresentFQDNLst.append(new TFQDN(yyvsp[0].strval, false));
      ;
      break;
    }
    case 177:
#line 683 "SrvParser.y"
    {
      TDUID *duidNew = new TDUID(yyvsp[0].duidval.duid, yyvsp[0].duidval.length);
      Log(Debug) << "FQDN:" << yyvsp[-2].strval << " reserved for DUID " << duidNew->getPlain()
                 << LogEnd;
      PresentFQDNLst.append(new TFQDN(duidNew, yyvsp[-2].strval, false));
      ;
      break;
    }
    case 178:
#line 689 "SrvParser.y"
    {
      addr = new TIPv6Addr(yyvsp[0].addrval);
      Log(Debug) << "FQDN:" << yyvsp[-2].strval << " reserved for address " << addr->getPlain()
                 << LogEnd;
      PresentFQDNLst.append(new TFQDN(new TIPv6Addr(yyvsp[0].addrval), yyvsp[-2].strval, false));
      ;
      break;
    }
    case 179:
#line 697 "SrvParser.y"
    {
      yyval.ival = yyvsp[0].ival;
      ;
      break;
    }
    case 180:
#line 698 "SrvParser.y"
    {
      yyval.ival = yyvsp[0].ival;
      ;
      break;
    }
    case 181:
#line 703 "SrvParser.y"
    {
      PresentAddrLst.append(new TIPv6Addr(yyvsp[0].addrval));
      ;
      break;
    }
    case 182:
#line 707 "SrvParser.y"
    {
      PresentAddrLst.append(new TIPv6Addr(yyvsp[0].addrval));
      ;
      break;
    }
    case 183:
#line 714 "SrvParser.y"
    {
      Log(Debug) << "Vendor-spec defined: Enterprise: " << yyvsp[-4].ival
                 << ", optionCode: " << yyvsp[-2].ival << ", valuelen=" << yyvsp[0].duidval.length
                 << LogEnd;

      ParserOptStack.getLast()->addExtraOption(
          new TOptVendorSpecInfo(OPTION_VENDOR_OPTS, yyvsp[-4].ival, yyvsp[-2].ival,
                                 yyvsp[0].duidval.duid, yyvsp[0].duidval.length, 0),
          false);
      ;
      break;
    }
    case 184:
#line 722 "SrvParser.y"
    {
      SPtr<TIPv6Addr> addr(new TIPv6Addr(yyvsp[0].addrval));
      Log(Debug) << "Vendor-spec defined: Enterprise: " << yyvsp[-4].ival
                 << ", optionCode: " << yyvsp[-2].ival << ", value=" << addr->getPlain() << LogEnd;
      ParserOptStack.getLast()->addExtraOption(
          new TOptVendorSpecInfo(OPTION_VENDOR_OPTS, yyvsp[-4].ival, yyvsp[-2].ival,
                                 new TIPv6Addr(yyvsp[0].addrval), 0),
          false);
      ;
      break;
    }
    case 185:
#line 730 "SrvParser.y"
    {
      Log(Debug) << "Vendor-spec defined: Enterprise: " << yyvsp[-4].ival
                 << ", optionCode: " << yyvsp[-2].ival << ", valuelen=" << strlen(yyvsp[0].strval)
                 << LogEnd;

      ParserOptStack.getLast()->addExtraOption(
          new TOptVendorSpecInfo(OPTION_VENDOR_OPTS, yyvsp[-4].ival, yyvsp[-2].ival,
                                 yyvsp[0].strval, 0),
          false);
      ;
      break;
    }
    case 186:
#line 738 "SrvParser.y"
    {
      Log(Debug) << "Vendor-spec defined: Enterprise: " << yyvsp[-4].ival
                 << ", optionCode: " << yyvsp[-2].ival << ", valuelen=" << yyvsp[0].duidval.length
                 << LogEnd;
      ParserOptStack.getLast()->addExtraOption(
          new TOptVendorSpecInfo(OPTION_VENDOR_OPTS, yyvsp[-4].ival, yyvsp[-2].ival,
                                 yyvsp[0].duidval.duid, yyvsp[0].duidval.length, 0),
          false);
      ;
      break;
    }
    case 187:
#line 745 "SrvParser.y"
    {
      SPtr<TIPv6Addr> addr(new TIPv6Addr(yyvsp[0].addrval));
      Log(Debug) << "Vendor-spec defined: Enterprise: " << yyvsp[-4].ival
                 << ", optionCode: " << yyvsp[-2].ival << ", value=" << addr->getPlain() << LogEnd;
      ParserOptStack.getLast()->addExtraOption(
          new TOptVendorSpecInfo(OPTION_VENDOR_OPTS, yyvsp[-4].ival, yyvsp[-2].ival, addr, 0),
          false);
      ;
      break;
    }
    case 188:
#line 753 "SrvParser.y"
    {
      Log(Debug) << "Vendor-spec defined: Enterprise: " << yyvsp[-4].ival
                 << ", optionCode: " << yyvsp[-2].ival << ", valuelen=" << strlen(yyvsp[0].strval)
                 << LogEnd;
      ParserOptStack.getLast()->addExtraOption(
          new TOptVendorSpecInfo(OPTION_VENDOR_OPTS, yyvsp[-4].ival, yyvsp[-2].ival,
                                 yyvsp[0].strval, 0),
          false);
      ;
      break;
    }
    case 189:
#line 762 "SrvParser.y"
    {
      PresentStringLst.append(SPtr<string>(new string(yyvsp[0].strval)));
      ;
      break;
    }
    case 190:
#line 763 "SrvParser.y"
    {
      PresentStringLst.append(SPtr<string>(new string(yyvsp[0].strval)));
      ;
      break;
    }
    case 191:
#line 768 "SrvParser.y"
    {
      PresentRangeLst.append(
          new THostRange(new TIPv6Addr(yyvsp[0].addrval), new TIPv6Addr(yyvsp[0].addrval)));
      ;
      break;
    }
    case 192:
#line 772 "SrvParser.y"
    {
      SPtr<TIPv6Addr> addr1(new TIPv6Addr(yyvsp[-2].addrval));
      SPtr<TIPv6Addr> addr2(new TIPv6Addr(yyvsp[0].addrval));
      if (*addr1 <= *addr2)
        PresentRangeLst.append(new THostRange(addr1, addr2));
      else
        PresentRangeLst.append(new THostRange(addr2, addr1));
      ;
      break;
    }
    case 193:
#line 781 "SrvParser.y"
    {
      SPtr<TIPv6Addr> addr(new TIPv6Addr(yyvsp[-2].addrval));
      int prefix = yyvsp[0].ival;
      if ((prefix < 1) || (prefix > 128)) {
        Log(Crit) << "Invalid prefix defined: " << prefix << " in line " << lex->lineno()
                  << ". Allowed range: 1..128." << LogEnd;
        YYABORT;
      }
      SPtr<TIPv6Addr> addr1 = this->getRangeMin(yyvsp[-2].addrval, prefix);
      SPtr<TIPv6Addr> addr2 = this->getRangeMax(yyvsp[-2].addrval, prefix);
      if (*addr1 <= *addr2)
        PresentRangeLst.append(new THostRange(addr1, addr2));
      else
        PresentRangeLst.append(new THostRange(addr2, addr1));
      ;
      break;
    }
    case 194:
#line 797 "SrvParser.y"
    {
      PresentRangeLst.append(
          new THostRange(new TIPv6Addr(yyvsp[0].addrval), new TIPv6Addr(yyvsp[0].addrval)));
      ;
      break;
    }
    case 195:
#line 801 "SrvParser.y"
    {
      SPtr<TIPv6Addr> addr1(new TIPv6Addr(yyvsp[-2].addrval));
      SPtr<TIPv6Addr> addr2(new TIPv6Addr(yyvsp[0].addrval));
      if (*addr1 <= *addr2)
        PresentRangeLst.append(new THostRange(addr1, addr2));
      else
        PresentRangeLst.append(new THostRange(addr2, addr1));
      ;
      break;
    }
    case 196:
#line 813 "SrvParser.y"
    {
      SPtr<TIPv6Addr> addr(new TIPv6Addr(yyvsp[-2].addrval));
      int prefix = yyvsp[0].ival;
      if ((prefix < 1) || (prefix > 128)) {
        Log(Crit) << "Invalid prefix defined: " << prefix << " in line " << lex->lineno()
                  << ". Allowed range: 1..128." << LogEnd;
        YYABORT;
      }

      SPtr<TIPv6Addr> addr1 = this->getRangeMin(yyvsp[-2].addrval, prefix);
      SPtr<TIPv6Addr> addr2 = this->getRangeMax(yyvsp[-2].addrval, prefix);
      SPtr<THostRange> range;
      if (*addr1 <= *addr2)
        range = new THostRange(addr1, addr2);
      else
        range = new THostRange(addr2, addr1);
      range->setPrefixLength(prefix);
      PDLst.append(range);
      ;
      break;
    }
    case 197:
#line 836 "SrvParser.y"
    {
      PresentRangeLst.append(
          new THostRange(new TIPv6Addr(yyvsp[0].addrval), new TIPv6Addr(yyvsp[0].addrval)));
      ;
      break;
    }
    case 198:
#line 840 "SrvParser.y"
    {
      SPtr<TIPv6Addr> addr1(new TIPv6Addr(yyvsp[-2].addrval));
      SPtr<TIPv6Addr> addr2(new TIPv6Addr(yyvsp[0].addrval));
      if (*addr1 <= *addr2)
        PresentRangeLst.append(new THostRange(addr1, addr2));
      else
        PresentRangeLst.append(new THostRange(addr2, addr1));
      ;
      break;
    }
    case 199:
#line 849 "SrvParser.y"
    {
      PresentRangeLst.append(
          new THostRange(new TIPv6Addr(yyvsp[0].addrval), new TIPv6Addr(yyvsp[0].addrval)));
      ;
      break;
    }
    case 200:
#line 853 "SrvParser.y"
    {
      SPtr<TIPv6Addr> addr1(new TIPv6Addr(yyvsp[-2].addrval));
      SPtr<TIPv6Addr> addr2(new TIPv6Addr(yyvsp[0].addrval));
      if (*addr1 <= *addr2)
        PresentRangeLst.append(new THostRange(addr1, addr2));
      else
        PresentRangeLst.append(new THostRange(addr2, addr1));
      ;
      break;
    }
    case 201:
#line 862 "SrvParser.y"
    {
      SPtr<TDUID> duid(new TDUID(yyvsp[0].duidval.duid, yyvsp[0].duidval.length));
      PresentRangeLst.append(new THostRange(duid, duid));
      delete yyvsp[0].duidval.duid;
      ;
      break;
    }
    case 202:
#line 868 "SrvParser.y"
    {
      SPtr<TDUID> duid1(new TDUID(yyvsp[-2].duidval.duid, yyvsp[-2].duidval.length));
      SPtr<TDUID> duid2(new TDUID(yyvsp[0].duidval.duid, yyvsp[0].duidval.length));

      if (*duid1 <= *duid2)
        PresentRangeLst.append(new THostRange(duid1, duid2));
      else
        PresentRangeLst.append(new THostRange(duid2, duid1));

      /// @todo: delete [] $1.duid; delete [] $3.duid?
      ;
      break;
    }
    case 203:
#line 880 "SrvParser.y"
    {
      SPtr<TDUID> duid(new TDUID(yyvsp[0].duidval.duid, yyvsp[0].duidval.length));
      PresentRangeLst.append(new THostRange(duid, duid));
      delete yyvsp[0].duidval.duid;
      ;
      break;
    }
    case 204:
#line 886 "SrvParser.y"
    {
      SPtr<TDUID> duid2(new TDUID(yyvsp[-2].duidval.duid, yyvsp[-2].duidval.length));
      SPtr<TDUID> duid1(new TDUID(yyvsp[0].duidval.duid, yyvsp[0].duidval.length));
      if (*duid1 <= *duid2)
        PresentRangeLst.append(new THostRange(duid1, duid2));
      else
        PresentRangeLst.append(new THostRange(duid2, duid1));
      delete yyvsp[-2].duidval.duid;
      delete yyvsp[0].duidval.duid;
      ;
      break;
    }
    case 205:
#line 900 "SrvParser.y"
    {
      PresentRangeLst.clear();
      ;
      break;
    }
    case 206:
#line 903 "SrvParser.y"
    {
      ParserOptStack.getLast()->setRejedClnt(&PresentRangeLst);
      ;
      break;
    }
    case 207:
#line 910 "SrvParser.y"
    {
      PresentRangeLst.clear();
      ;
      break;
    }
    case 208:
#line 913 "SrvParser.y"
    {
      ParserOptStack.getLast()->setAcceptClnt(&PresentRangeLst);
      ;
      break;
    }
    case 209:
#line 920 "SrvParser.y"
    {
      PresentRangeLst.clear();
      ;
      break;
    }
    case 210:
#line 923 "SrvParser.y"
    {
      ParserOptStack.getLast()->setPool(&PresentRangeLst);
      ;
      break;
    }
    case 211:
#line 930 "SrvParser.y"
    {
      ;
      break;
    }
    case 212:
#line 932 "SrvParser.y"
    {
      ParserOptStack.getLast()->setPool(&PresentRangeLst /*PDList*/);
      ;
      break;
    }
    case 213:
#line 938 "SrvParser.y"
    {
      if (((yyvsp[0].ival) > 128) || ((yyvsp[0].ival) < 1)) {
        Log(Crit) << "Invalid pd-length:" << yyvsp[0].ival << ", allowed range is 1..128."
                  << LogEnd;
        YYABORT;
      }
      this->PDPrefix = yyvsp[0].ival;
      ;
      break;
    }
    case 214:
#line 950 "SrvParser.y"
    {
      ParserOptStack.getLast()->setPrefBeg(yyvsp[0].ival);
      ParserOptStack.getLast()->setPrefEnd(yyvsp[0].ival);
      ;
      break;
    }
    case 215:
#line 955 "SrvParser.y"
    {
      ParserOptStack.getLast()->setPrefBeg(yyvsp[-2].ival);
      ParserOptStack.getLast()->setPrefEnd(yyvsp[0].ival);
      ;
      break;
    }
    case 216:
#line 963 "SrvParser.y"
    {
      ParserOptStack.getLast()->setValidBeg(yyvsp[0].ival);
      ParserOptStack.getLast()->setValidEnd(yyvsp[0].ival);
      ;
      break;
    }
    case 217:
#line 968 "SrvParser.y"
    {
      ParserOptStack.getLast()->setValidBeg(yyvsp[-2].ival);
      ParserOptStack.getLast()->setValidEnd(yyvsp[0].ival);
      ;
      break;
    }
    case 218:
#line 976 "SrvParser.y"
    {
      int x = yyvsp[0].ival;
      if ((x < 1) || (x > 1000)) {
        Log(Crit) << "Invalid share value: " << x << " in line " << lex->lineno()
                  << ". Allowed range: 1..1000." << LogEnd;
        YYABORT;
      }
      ParserOptStack.getLast()->setShare(x);
      ;
      break;
    }
    case 219:
#line 988 "SrvParser.y"
    {
      ParserOptStack.getLast()->setT1Beg(yyvsp[0].ival);
      ParserOptStack.getLast()->setT1End(yyvsp[0].ival);
      ;
      break;
    }
    case 220:
#line 993 "SrvParser.y"
    {
      ParserOptStack.getLast()->setT1Beg(yyvsp[-2].ival);
      ParserOptStack.getLast()->setT1End(yyvsp[0].ival);
      ;
      break;
    }
    case 221:
#line 1001 "SrvParser.y"
    {
      ParserOptStack.getLast()->setT2Beg(yyvsp[0].ival);
      ParserOptStack.getLast()->setT2End(yyvsp[0].ival);
      ;
      break;
    }
    case 222:
#line 1006 "SrvParser.y"
    {
      ParserOptStack.getLast()->setT2Beg(yyvsp[-2].ival);
      ParserOptStack.getLast()->setT2End(yyvsp[0].ival);
      ;
      break;
    }
    case 223:
#line 1014 "SrvParser.y"
    {
      ParserOptStack.getLast()->setClntMaxLease(yyvsp[0].ival);
      ;
      break;
    }
    case 224:
#line 1021 "SrvParser.y"
    {
      ParserOptStack.getLast()->setClassMaxLease(yyvsp[0].ival);
      ;
      break;
    }
    case 225:
#line 1028 "SrvParser.y"
    {
      if (!ParserOptStack.getLast()->getExperimental()) {
        Log(Crit) << "Experimental 'addr-params' defined, but experimental "
                  << "features are disabled. Add 'experimental' "
                  << "in global section of server.conf to enable it." << LogEnd;
        YYABORT;
      }
      int bitfield = ADDRPARAMS_MASK_PREFIX;
      Log(Warning) << "Experimental addr-params added (prefix=" << yyvsp[0].ival
                   << ", bitfield=" << bitfield << ")." << LogEnd;
      ParserOptStack.getLast()->setAddrParams(yyvsp[0].ival, bitfield);
      ;
      break;
    }
    case 226:
#line 1043 "SrvParser.y"
    {
      SPtr<TOpt> tunnelName = new TOptDomainLst(OPTION_AFTR_NAME, yyvsp[0].strval, 0);
      Log(Debug) << "Enabling DS-Lite tunnel option, AFTR name=" << yyvsp[0].strval << LogEnd;
      ParserOptStack.getLast()->addExtraOption(tunnelName, false);
      ;
      break;
    }
    case 227:
#line 1051 "SrvParser.y"
    {
      SPtr<TOpt> opt =
          new TOptGeneric(yyvsp[-2].ival, yyvsp[0].duidval.duid, yyvsp[0].duidval.length, 0);
      ParserOptStack.getLast()->addExtraOption(opt, false);
      Log(Debug) << "Extra option defined: code=" << yyvsp[-2].ival
                 << ", length=" << yyvsp[0].duidval.length << LogEnd;
      ;
      break;
    }
    case 228:
#line 1058 "SrvParser.y"
    {
      SPtr<TIPv6Addr> addr(new TIPv6Addr(yyvsp[0].addrval));

      SPtr<TOpt> opt = new TOptAddr(yyvsp[-2].ival, addr, 0);
      ParserOptStack.getLast()->addExtraOption(opt, false);
      Log(Debug) << "Extra option defined: code=" << yyvsp[-2].ival
                 << ", address=" << addr->getPlain() << LogEnd;
      ;
      break;
    }
    case 229:
#line 1066 "SrvParser.y"
    {
      PresentAddrLst.clear();
      ;
      break;
    }
    case 230:
#line 1069 "SrvParser.y"
    {
      SPtr<TOpt> opt = new TOptAddrLst(yyvsp[-3].ival, PresentAddrLst, 0);
      ParserOptStack.getLast()->addExtraOption(opt, false);
      Log(Debug) << "Extra option defined: code=" << yyvsp[-3].ival
                 << ", address count=" << PresentAddrLst.count() << LogEnd;
      ;
      break;
    }
    case 231:
#line 1076 "SrvParser.y"
    {
      SPtr<TOpt> opt = new TOptString(yyvsp[-2].ival, string(yyvsp[0].strval), 0);
      ParserOptStack.getLast()->addExtraOption(opt, false);
      Log(Debug) << "Extra option defined: code=" << yyvsp[-2].ival
                 << ", string=" << yyvsp[0].strval << LogEnd;
      ;
      break;
    }
    case 232:
#line 1084 "SrvParser.y"
    {
      if (!ParserOptStack.getLast()->getExperimental()) {
        Log(Crit) << "Experimental 'remote autoconf neighbors' defined, but "
                  << "experimental features are disabled. Add 'experimental' "
                  << "in global section of server.conf to enable it." << LogEnd;
        YYABORT;
      }

      PresentAddrLst.clear();
      ;
      break;
    }
    case 233:
#line 1094 "SrvParser.y"
    {
      SPtr<TOpt> opt = new TOptAddrLst(OPTION_NEIGHBORS, PresentAddrLst, 0);
      ParserOptStack.getLast()->addExtraOption(opt, false);
      Log(Debug) << "Remote autoconf neighbors enabled (" << PresentAddrLst.count()
                 << " neighbors defined.)" << LogEnd;
      ;
      break;
    }
    case 234:
#line 1104 "SrvParser.y"
    {
      ParserOptStack.getLast()->setIfaceMaxLease(yyvsp[0].ival);
      ;
      break;
    }
    case 235:
#line 1111 "SrvParser.y"
    {
      ParserOptStack.getLast()->setUnicast(new TIPv6Addr(yyvsp[0].addrval));
      ;
      break;
    }
    case 236:
#line 1118 "SrvParser.y"
    {
      CfgMgr->dropUnicast(true);
      ;
      break;
    }
    case 237:
#line 1124 "SrvParser.y"
    {
      if ((yyvsp[0].ival != 0) && (yyvsp[0].ival != 1)) {
        Log(Crit) << "RAPID-COMMIT  parameter in line " << lex->lineno()
                  << " must have 0 or 1 value." << LogEnd;
        YYABORT;
      }
      if (yyvsp[0].ival == 1)
        ParserOptStack.getLast()->setRapidCommit(true);
      else
        ParserOptStack.getLast()->setRapidCommit(false);
      ;
      break;
    }
    case 238:
#line 1139 "SrvParser.y"
    {
      if ((yyvsp[0].ival < 0) || (yyvsp[0].ival > 255)) {
        Log(Crit) << "Preference value (" << yyvsp[0].ival << ") in line " << lex->lineno()
                  << " is out of range [0..255]." << LogEnd;
        YYABORT;
      }
      ParserOptStack.getLast()->setPreference(yyvsp[0].ival);
      ;
      break;
    }
    case 239:
#line 1150 "SrvParser.y"
    {
      logger::setLogLevel(yyvsp[0].ival);
      ;
      break;
    }
    case 240:
#line 1156 "SrvParser.y"
    {
      logger::setLogMode(yyvsp[0].strval);
      ;
      break;
    }
    case 241:
#line 1162 "SrvParser.y"
    {
      logger::setLogName(yyvsp[0].strval);
      ;
      break;
    }
    case 242:
#line 1169 "SrvParser.y"
    {
      logger::setColors(yyvsp[0].ival == 1);
      ;
      break;
    }
    case 243:
#line 1175 "SrvParser.y"
    {
      ParserOptStack.getLast()->setWorkDir(yyvsp[0].strval);
      ;
      break;
    }
    case 244:
#line 1182 "SrvParser.y"
    {
      ParserOptStack.getLast()->setStateless(true);
      ;
      break;
    }
    case 245:
#line 1189 "SrvParser.y"
    {
      Log(Info) << "Guess-mode enabled: relay interfaces may be loosely "
                << "defined (matching interface-id is not mandatory)." << LogEnd;
      ParserOptStack.getLast()->setGuessMode(true);
      ;
      break;
    }
    case 246:
#line 1197 "SrvParser.y"
    {
      CfgMgr->setScriptName(yyvsp[0].strval);
      ;
      break;
    }
    case 247:
#line 1203 "SrvParser.y"
    {
      if (!ParserOptStack.getLast()->getExperimental()) {
        Log(Crit) << "Experimental 'performance-mode' defined, but experimental "
                  << "features are disabled. Add 'experimental' "
                  << "in global section of server.conf to enable it." << LogEnd;
        YYABORT;
      }

      CfgMgr->setPerformanceMode(yyvsp[0].ival);
      ;
      break;
    }
    case 248:
#line 1216 "SrvParser.y"
    {
      switch (yyvsp[0].ival) {
        case 0:
        case 1:
          CfgMgr->setReconfigureSupport(yyvsp[0].ival);
          break;
        default:
          Log(Crit) << "Invalid reconfigure-enabled value " << yyvsp[0].ival
                    << ", only 0 and 1 are supported." << LogEnd;
          YYABORT;
      };
      break;
    }
    case 249:
#line 1232 "SrvParser.y"
    {
      ParserOptStack.getLast()->setInactiveMode(true);
      ;
      break;
    }
    case 250:
#line 1238 "SrvParser.y"
    {
      Log(Crit) << "Experimental features are allowed." << LogEnd;
      ParserOptStack.getLast()->setExperimental(true);
      ;
      break;
    }
    case 251:
#line 1245 "SrvParser.y"
    {
      if (!strncasecmp(yyvsp[0].strval, "before", 6)) {
        ParserOptStack.getLast()->setInterfaceIDOrder(SRV_IFACE_ID_ORDER_BEFORE);
      } else if (!strncasecmp(yyvsp[0].strval, "after", 5)) {
        ParserOptStack.getLast()->setInterfaceIDOrder(SRV_IFACE_ID_ORDER_AFTER);
      } else if (!strncasecmp(yyvsp[0].strval, "omit", 4)) {
        ParserOptStack.getLast()->setInterfaceIDOrder(SRV_IFACE_ID_ORDER_NONE);
      } else {
        Log(Crit) << "Invalid interface-id-order specified. Allowed "
                  << "values: before, after, omit" << LogEnd;
        YYABORT;
      };
      break;
    }
    case 252:
#line 1267 "SrvParser.y"
    {
      ParserOptStack.getLast()->setCacheSize(yyvsp[0].ival);
      ;
      break;
    }
    case 253:
#line 1278 "SrvParser.y"
    {
      ParserOptStack.getLast()->setLeaseQuerySupport(true);

      ;
      break;
    }
    case 254:
#line 1283 "SrvParser.y"
    {
      switch (yyvsp[0].ival) {
        case 0:
          ParserOptStack.getLast()->setLeaseQuerySupport(false);
          break;
        case 1:
          ParserOptStack.getLast()->setLeaseQuerySupport(true);
          break;
        default:
          Log(Crit) << "Invalid value of accept-leasequery specifed. Allowed "
                    << "values: 0, 1, yes, no, true, false" << LogEnd;
          YYABORT;
      };
      break;
    }
    case 255:
#line 1300 "SrvParser.y"
    {
      if (yyvsp[0].ival != 0 && yyvsp[0].ival != 1) {
        Log(Error) << "Invalid bulk-leasequery-accept value: " << (yyvsp[0].ival)
                   << ", 0 or 1 expected." << LogEnd;
        YYABORT;
      }
      CfgMgr->bulkLQAccept((bool)yyvsp[0].ival);
      ;
      break;
    }
    case 256:
#line 1311 "SrvParser.y"
    {
      CfgMgr->bulkLQTcpPort(yyvsp[0].ival);
      ;
      break;
    }
    case 257:
#line 1317 "SrvParser.y"
    {
      CfgMgr->bulkLQMaxConns(yyvsp[0].ival);
      ;
      break;
    }
    case 258:
#line 1323 "SrvParser.y"
    {
      CfgMgr->bulkLQTimeout(yyvsp[0].ival);
      ;
      break;
    }
    case 259:
#line 1332 "SrvParser.y"
    {
      ParserOptStack.getLast()->setRelayName(yyvsp[0].strval);
      ;
      break;
    }
    case 260:
#line 1336 "SrvParser.y"
    {
      ParserOptStack.getLast()->setRelayID(yyvsp[0].ival);
      ;
      break;
    }
    case 261:
#line 1343 "SrvParser.y"
    {
      SPtr<TSrvOptInterfaceID> id = new TSrvOptInterfaceID(yyvsp[0].ival, 0);
      ParserOptStack.getLast()->setRelayInterfaceID(id);
      ;
      break;
    }
    case 262:
#line 1348 "SrvParser.y"
    {
      SPtr<TSrvOptInterfaceID> id =
          new TSrvOptInterfaceID(yyvsp[0].duidval.duid, yyvsp[0].duidval.length, 0);
      ParserOptStack.getLast()->setRelayInterfaceID(id);
      ;
      break;
    }
    case 263:
#line 1353 "SrvParser.y"
    {
      SPtr<TSrvOptInterfaceID> id =
          new TSrvOptInterfaceID(yyvsp[0].strval, strlen(yyvsp[0].strval), 0);
      ParserOptStack.getLast()->setRelayInterfaceID(id);
      ;
      break;
    }
    case 264:
#line 1361 "SrvParser.y"
    {
      int prefix = yyvsp[0].ival;
      if ((prefix < 1) || (prefix > 128)) {
        Log(Crit) << "Invalid (1..128 allowed) prefix used: " << prefix
                  << " in subnet definition in line " << lex->lineno() << LogEnd;
        YYABORT;
      }
      SPtr<TIPv6Addr> min = getRangeMin(yyvsp[-2].addrval, prefix);
      SPtr<TIPv6Addr> max = getRangeMax(yyvsp[-2].addrval, prefix);
      SrvCfgIfaceLst.getLast()->addSubnet(min, max);
      Log(Debug) << "Defined subnet " << min->getPlain() << "/" << yyvsp[0].ival << " on "
                 << SrvCfgIfaceLst.getLast()->getFullName() << LogEnd;
      ;
      break;
    }
    case 265:
#line 1374 "SrvParser.y"
    {
      SPtr<TIPv6Addr> min = new TIPv6Addr(yyvsp[-2].addrval);
      SPtr<TIPv6Addr> max = new TIPv6Addr(yyvsp[0].addrval);
      SrvCfgIfaceLst.getLast()->addSubnet(min, max);
      Log(Debug) << "Defined subnet " << min->getPlain() << "-" << max->getPlain() << "on "
                 << SrvCfgIfaceLst.getLast()->getFullName() << LogEnd;
      ;
      break;
    }
    case 278:
#line 1399 "SrvParser.y"
    {
      SPtr<TSrvCfgClientClass> clntClass;
      bool found = false;
      SrvCfgClientClassLst.first();
      while (clntClass = SrvCfgClientClassLst.get()) {
        if (clntClass->getClassName() == string(yyvsp[0].strval)) found = true;
      }
      if (!found) {
        Log(Crit) << "Line " << lex->lineno() << ": Unable to use class " << string(yyvsp[0].strval)
                  << ", no such class defined." << LogEnd;
        YYABORT;
      }
      ParserOptStack.getLast()->setAllowClientClass(string(yyvsp[0].strval));

      int deny = ParserOptStack.getLast()->getDenyClientClassString().count();

      if (deny) {
        Log(Crit) << "Line " << lex->lineno()
                  << ": Unable to define both allow and deny lists for this "
                     "client class."
                  << LogEnd;
        YYABORT;
      }

      ;
      break;
    }
    case 279:
#line 1428 "SrvParser.y"
    {
      SPtr<TSrvCfgClientClass> clntClass;
      bool found = false;
      SrvCfgClientClassLst.first();
      while (clntClass = SrvCfgClientClassLst.get()) {
        if (clntClass->getClassName() == string(yyvsp[0].strval)) found = true;
      }
      if (!found) {
        Log(Crit) << "Line " << lex->lineno() << ": Unable to use class " << string(yyvsp[0].strval)
                  << ", no such class defined." << LogEnd;
        YYABORT;
      }
      ParserOptStack.getLast()->setDenyClientClass(string(yyvsp[0].strval));

      int allow = ParserOptStack.getLast()->getAllowClientClassString().count();

      if (allow) {
        Log(Crit) << "Line " << lex->lineno()
                  << ": Unable to define both allow and deny lists for this "
                     "client class."
                  << LogEnd;
        YYABORT;
      }

      ;
      break;
    }
    case 280:
#line 1461 "SrvParser.y"
    {
      PresentAddrLst.clear();
      ;
      break;
    }
    case 281:
#line 1464 "SrvParser.y"
    {
      SPtr<TOpt> nis_servers = new TOptAddrLst(OPTION_DNS_SERVERS, PresentAddrLst, NULL);
      ParserOptStack.getLast()->addExtraOption(nis_servers, false);
      ;
      break;
    }
    case 282:
#line 1474 "SrvParser.y"
    {
      PresentStringLst.clear();
      ;
      break;
    }
    case 283:
#line 1477 "SrvParser.y"
    {
      SPtr<TOpt> domains = new TOptDomainLst(OPTION_DOMAIN_LIST, PresentStringLst, NULL);
      ParserOptStack.getLast()->addExtraOption(domains, false);
      ;
      break;
    }
    case 284:
#line 1488 "SrvParser.y"
    {
      PresentAddrLst.clear();
      ;
      break;
    }
    case 285:
#line 1491 "SrvParser.y"
    {
      SPtr<TOpt> ntp_servers = new TOptAddrLst(OPTION_SNTP_SERVERS, PresentAddrLst, NULL);
      ParserOptStack.getLast()->addExtraOption(ntp_servers, false);
      // ParserOptStack.getLast()->setNTPServerLst(&PresentAddrLst);
      ;
      break;
    }
    case 286:
#line 1503 "SrvParser.y"
    {
      SPtr<TOpt> timezone = new TOptString(OPTION_NEW_TZDB_TIMEZONE, string(yyvsp[0].strval), NULL);
      ParserOptStack.getLast()->addExtraOption(timezone, false);
      // ParserOptStack.getLast()->setTimezone($3);
      ;
      break;
    }
    case 287:
#line 1514 "SrvParser.y"
    {
      PresentAddrLst.clear();
      ;
      break;
    }
    case 288:
#line 1517 "SrvParser.y"
    {
      SPtr<TOpt> sip_servers = new TOptAddrLst(OPTION_SIP_SERVER_A, PresentAddrLst, NULL);
      ParserOptStack.getLast()->addExtraOption(sip_servers, false);
      // ParserOptStack.getLast()->setSIPServerLst(&PresentAddrLst);
      ;
      break;
    }
    case 289:
#line 1528 "SrvParser.y"
    {
      PresentStringLst.clear();
      ;
      break;
    }
    case 290:
#line 1531 "SrvParser.y"
    {
      SPtr<TOpt> sip_domains = new TOptDomainLst(OPTION_SIP_SERVER_D, PresentStringLst, NULL);
      ParserOptStack.getLast()->addExtraOption(sip_domains, false);
      // ParserOptStack.getLast()->setSIPDomainLst(&PresentStringLst);
      ;
      break;
    }
    case 291:
#line 1544 "SrvParser.y"
    {
      PresentFQDNLst.clear();
      Log(Debug) << "No FQDNMode found, setting default mode 2 (all updates "
                    "executed by server)."
                 << LogEnd;
      Log(Warning) << "revDNS zoneroot lenght not found, dynamic revDNS update "
                      "will not be possible."
                   << LogEnd;
      ParserOptStack.getLast()->setFQDNMode(2);
      ParserOptStack.getLast()->setRevDNSZoneRootLength(0);
      ;
      break;
    }
    case 292:
#line 1553 "SrvParser.y"
    {
      ParserOptStack.getLast()->setFQDNLst(&PresentFQDNLst);
      ;
      break;
    }
    case 293:
#line 1557 "SrvParser.y"
    {
      PresentFQDNLst.clear();
      Log(Debug) << "FQDN: Setting update mode to " << yyvsp[0].ival;
      switch (yyvsp[0].ival) {
        case 0:
          Log(Cont) << "(no updates)" << LogEnd;
          break;
        case 1:
          Log(Cont) << "(client will update AAAA, server will update PTR)" << LogEnd;
          break;
        case 2:
          Log(Cont) << "(server will update both AAAA and PTR)" << LogEnd;
          break;
        default:
          Log(Cont) << LogEnd;
          Log(Crit) << "FQDN: Invalid mode. Only 0-2 are supported." << LogEnd;
          YYABORT;
      }
      Log(Warning) << "FQDN: RevDNS zoneroot lenght not specified, dynamic "
                      "revDNS update will not be possible."
                   << LogEnd;
      ParserOptStack.getLast()->setFQDNMode(yyvsp[0].ival);
      ParserOptStack.getLast()->setRevDNSZoneRootLength(0);
      ;
      break;
    }
    case 294:
#line 1579 "SrvParser.y"
    {
      ParserOptStack.getLast()->setFQDNLst(&PresentFQDNLst);

      ;
      break;
    }
    case 295:
#line 1584 "SrvParser.y"
    {
      PresentFQDNLst.clear();
      Log(Debug) << "FQDN: Setting update mode to " << yyvsp[-1].ival;
      switch (yyvsp[-1].ival) {
        case 0:
          Log(Cont) << "(no updates)" << LogEnd;
          break;
        case 1:
          Log(Cont) << "(client will update AAAA, server will update PTR)" << LogEnd;
          break;
        case 2:
          Log(Cont) << "(server will update both AAAA and PTR)" << LogEnd;
          break;
        default:
          Log(Cont) << LogEnd;
          Log(Crit) << "FQDN: Invalid mode. Only 0-2 are supported." << LogEnd;
          YYABORT;
      }

      Log(Debug) << "FQDN: RevDNS zoneroot lenght set to " << yyvsp[0].ival << LogEnd;
      if ((yyvsp[0].ival < 0) || (yyvsp[0].ival > 128)) {
        Log(Crit) << "FQDN: Invalid zoneroot length specified:" << yyvsp[0].ival
                  << ". Value 0-128 expected." << LogEnd;
        YYABORT;
      }
      ParserOptStack.getLast()->setFQDNMode(yyvsp[-1].ival);
      ParserOptStack.getLast()->setRevDNSZoneRootLength(yyvsp[0].ival);
      ;
      break;
    }
    case 296:
#line 1612 "SrvParser.y"
    {
      ParserOptStack.getLast()->setFQDNLst(&PresentFQDNLst);

      ;
      break;
    }
    case 297:
#line 1620 "SrvParser.y"
    {
      ParserOptStack.getLast()->setUnknownFQDN(EUnknownFQDNMode(yyvsp[-1].ival),
                                               string(yyvsp[0].strval));
      Log(Debug) << "FQDN: Unknown fqdn names processing set to " << yyvsp[-1].ival
                 << ", domain=" << yyvsp[0].strval << "." << LogEnd;
      ;
      break;
    }
    case 298:
#line 1626 "SrvParser.y"
    {
      ParserOptStack.getLast()->setUnknownFQDN(EUnknownFQDNMode(yyvsp[0].ival), string(""));
      Log(Debug) << "FQDN: Unknown fqdn names processing set to " << yyvsp[0].ival << ", no domain."
                 << LogEnd;
      ;
      break;
    }
    case 299:
#line 1635 "SrvParser.y"
    {
      addr = new TIPv6Addr(yyvsp[0].addrval);
      CfgMgr->setDDNSAddress(addr);
      Log(Info) << "FQDN: DDNS updates will be performed to " << addr->getPlain() << "." << LogEnd;
      ;
      break;
    }
    case 300:
#line 1643 "SrvParser.y"
    {
      if (!strcasecmp(yyvsp[0].strval, "tcp"))
        CfgMgr->setDDNSProtocol(TCfgMgr::DNSUPDATE_TCP);
      else if (!strcasecmp(yyvsp[0].strval, "udp"))
        CfgMgr->setDDNSProtocol(TCfgMgr::DNSUPDATE_UDP);
      else if (!strcasecmp(yyvsp[0].strval, "any"))
        CfgMgr->setDDNSProtocol(TCfgMgr::DNSUPDATE_ANY);
      else {
        Log(Crit) << "Invalid ddns-protocol specifed:" << (yyvsp[0].strval)
                  << ", supported values are tcp, udp, any." << LogEnd;
        YYABORT;
      }
      Log(Debug) << "DDNS: Setting protocol to " << (yyvsp[0].strval) << LogEnd;
      ;
      break;
    }
    case 301:
#line 1660 "SrvParser.y"
    {
      Log(Debug) << "DDNS: Setting timeout to " << yyvsp[0].ival << "ms." << LogEnd;
      CfgMgr->setDDNSTimeout(yyvsp[0].ival);
      ;
      break;
    }
    case 302:
#line 1669 "SrvParser.y"
    {
      PresentAddrLst.clear();
      ;
      break;
    }
    case 303:
#line 1672 "SrvParser.y"
    {
      SPtr<TOpt> nis_servers = new TOptAddrLst(OPTION_NIS_SERVERS, PresentAddrLst, NULL);
      ParserOptStack.getLast()->addExtraOption(nis_servers, false);
      /// ParserOptStack.getLast()->setNISServerLst(&PresentAddrLst);
      ;
      break;
    }
    case 304:
#line 1683 "SrvParser.y"
    {
      PresentAddrLst.clear();
      ;
      break;
    }
    case 305:
#line 1686 "SrvParser.y"
    {
      SPtr<TOpt> nisp_servers = new TOptAddrLst(OPTION_NISP_SERVERS, PresentAddrLst, NULL);
      ParserOptStack.getLast()->addExtraOption(nisp_servers, false);
      // ParserOptStack.getLast()->setNISPServerLst(&PresentAddrLst);
      ;
      break;
    }
    case 306:
#line 1698 "SrvParser.y"
    {
      SPtr<TOpt> nis_domain =
          new TOptDomainLst(OPTION_NIS_DOMAIN_NAME, string(yyvsp[0].strval), NULL);
      ParserOptStack.getLast()->addExtraOption(nis_domain, false);
      // ParserOptStack.getLast()->setNISDomain($3);
      ;
      break;
    }
    case 307:
#line 1710 "SrvParser.y"
    {
      SPtr<TOpt> nispdomain =
          new TOptDomainLst(OPTION_NISP_DOMAIN_NAME, string(yyvsp[0].strval), NULL);
      ParserOptStack.getLast()->addExtraOption(nispdomain, false);
      ;
      break;
    }
    case 308:
#line 1721 "SrvParser.y"
    {
      SPtr<TOpt> lifetime =
          new TOptInteger(OPTION_INFORMATION_REFRESH_TIME, OPTION_INFORMATION_REFRESH_TIME_LEN,
                          (uint32_t)(yyvsp[0].ival), NULL);
      ParserOptStack.getLast()->addExtraOption(lifetime, false);
      // ParserOptStack.getLast()->setLifetime($3);
      ;
      break;
    }
    case 309:
#line 1731 "SrvParser.y"
    {
      ;
      break;
    }
    case 310:
#line 1733 "SrvParser.y"
    {
      // ParserOptStack.getLast()->setVendorSpec(VendorSpec);
      // Log(Debug) << "Vendor-spec parsing finished" << LogEnd;
      ;
      break;
    }
    case 311:
#line 1741 "SrvParser.y"
    {
      Log(Notice) << "ClientClass found, name: " << string(yyvsp[-1].strval) << LogEnd;
      ;
      break;
    }
    case 312:
#line 1744 "SrvParser.y"
    {
      SPtr<Node> cond = NodeClientClassLst.getLast();
      SrvCfgClientClassLst.append(new TSrvCfgClientClass(string(yyvsp[-4].strval), cond));
      NodeClientClassLst.delLast();
      ;
      break;
    }
    case 313:
#line 1754 "SrvParser.y"
    {
      ;
      break;
    }
    case 315:
#line 1760 "SrvParser.y"
    {
      SPtr<Node> r = NodeClientClassLst.getLast();
      NodeClientClassLst.delLast();
      SPtr<Node> l = NodeClientClassLst.getLast();
      NodeClientClassLst.delLast();
      NodeClientClassLst.append(new NodeOperator(NodeOperator::OPERATOR_CONTAIN, l, r));
      ;
      break;
    }
    case 316:
#line 1768 "SrvParser.y"
    {
      SPtr<Node> l = NodeClientClassLst.getLast();
      NodeClientClassLst.delLast();
      SPtr<Node> r = NodeClientClassLst.getLast();
      NodeClientClassLst.delLast();

      NodeClientClassLst.append(new NodeOperator(NodeOperator::OPERATOR_EQUAL, l, r));
      ;
      break;
    }
    case 317:
#line 1777 "SrvParser.y"
    {
      SPtr<Node> l = NodeClientClassLst.getLast();
      NodeClientClassLst.delLast();
      SPtr<Node> r = NodeClientClassLst.getLast();
      NodeClientClassLst.delLast();
      NodeClientClassLst.append(new NodeOperator(NodeOperator::OPERATOR_AND, l, r));

      ;
      break;
    }
    case 318:
#line 1786 "SrvParser.y"
    {
      SPtr<Node> l = NodeClientClassLst.getLast();
      NodeClientClassLst.delLast();
      SPtr<Node> r = NodeClientClassLst.getLast();
      NodeClientClassLst.delLast();
      NodeClientClassLst.append(new NodeOperator(NodeOperator::OPERATOR_OR, l, r));
      ;
      break;
    }
    case 319:
#line 1797 "SrvParser.y"
    {
      NodeClientClassLst.append(
          new NodeClientSpecific(NodeClientSpecific::CLIENT_VENDOR_SPEC_ENTERPRISE_NUM));
      ;
      break;
    }
    case 320:
#line 1801 "SrvParser.y"
    {
      NodeClientClassLst.append(
          new NodeClientSpecific(NodeClientSpecific::CLIENT_VENDOR_SPEC_DATA));
      ;
      break;
    }
    case 321:
#line 1805 "SrvParser.y"
    {
      NodeClientClassLst.append(
          new NodeClientSpecific(NodeClientSpecific::CLIENT_VENDOR_CLASS_ENTERPRISE_NUM));
      ;
      break;
    }
    case 322:
#line 1809 "SrvParser.y"
    {
      NodeClientClassLst.append(
          new NodeClientSpecific(NodeClientSpecific::CLIENT_VENDOR_CLASS_DATA));
      ;
      break;
    }
    case 323:
#line 1813 "SrvParser.y"
    {
      // Log(Info) << "Constant expression found:" <<string($1)<<LogEnd;
      NodeClientClassLst.append(new NodeConstant(string(yyvsp[0].strval)));
      ;
      break;
    }
    case 324:
#line 1818 "SrvParser.y"
    {
      // Log(Info) << "Constant expression found:" <<string($1)<<LogEnd;
      stringstream convert;
      string snum;
      convert << yyvsp[0].ival;
      convert >> snum;
      NodeClientClassLst.append(new NodeConstant(snum));
      ;
      break;
    }
    case 325:
#line 1827 "SrvParser.y"
    {
      SPtr<Node> l = NodeClientClassLst.getLast();
      NodeClientClassLst.delLast();
      NodeClientClassLst.append(
          new NodeOperator(NodeOperator::OPERATOR_SUBSTRING, l, yyvsp[-3].ival, yyvsp[-1].ival));
      ;
      break;
    }
  }

#line 840 "../bison++/bison.cc"
  /* the action file gets copied in in place of this dollarsign  */
  yyvsp -= yylen;
  yyssp -= yylen;
#ifdef YY_SrvParser_LSP_NEEDED
  yylsp -= yylen;
#endif

#if YY_SrvParser_DEBUG != 0
  if (YY_SrvParser_DEBUG_FLAG) {
    short *ssp1 = yyss - 1;
    fprintf(stderr, "state stack now");
    while (ssp1 != yyssp) fprintf(stderr, " %d", *++ssp1);
    fprintf(stderr, "\n");
  }
#endif

  *++yyvsp = yyval;

#ifdef YY_SrvParser_LSP_NEEDED
  yylsp++;
  if (yylen == 0) {
    yylsp->first_line = YY_SrvParser_LLOC.first_line;
    yylsp->first_column = YY_SrvParser_LLOC.first_column;
    yylsp->last_line = (yylsp - 1)->last_line;
    yylsp->last_column = (yylsp - 1)->last_column;
    yylsp->text = 0;
  } else {
    yylsp->last_line = (yylsp + yylen - 1)->last_line;
    yylsp->last_column = (yylsp + yylen - 1)->last_column;
  }
#endif

  /* Now "shift" the result of the reduction.
     Determine what state that goes to,
     based on the state we popped back to
     and the rule number reduced by.  */

  yyn = yyr1[yyn];

  yystate = yypgoto[yyn - YYNTBASE] + *yyssp;
  if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *yyssp)
    yystate = yytable[yystate];
  else
    yystate = yydefgoto[yyn - YYNTBASE];

  YYGOTO(yynewstate);

  YYLABEL(yyerrlab) /* here on detecting error */

  if (!yyerrstatus)
  /* If not already recovering from an error, report this error.  */
  {
    ++YY_SrvParser_NERRS;

#ifdef YY_SrvParser_ERROR_VERBOSE
    yyn = yypact[yystate];

    if (yyn > YYFLAG && yyn < YYLAST) {
      int size = 0;
      char *msg;
      int x, count;

      count = 0;
      /* Start X at -yyn if nec to avoid negative indexes in yycheck.  */
      for (x = (yyn < 0 ? -yyn : 0); x < (sizeof(yytname) / sizeof(char *)); x++)
        if (yycheck[x + yyn] == x) size += strlen(yytname[x]) + 15, count++;
      msg = (char *)malloc(size + 15);
      if (msg != 0) {
        strcpy(msg, "parse error");

        if (count < 5) {
          count = 0;
          for (x = (yyn < 0 ? -yyn : 0); x < (sizeof(yytname) / sizeof(char *)); x++)
            if (yycheck[x + yyn] == x) {
              strcat(msg, count == 0 ? ", expecting `" : " or `");
              strcat(msg, yytname[x]);
              strcat(msg, "'");
              count++;
            }
        }
        YY_SrvParser_ERROR(msg);
        free(msg);
      } else
        YY_SrvParser_ERROR("parse error; also virtual memory exceeded");
    } else
#endif /* YY_SrvParser_ERROR_VERBOSE */
      YY_SrvParser_ERROR((char *)"parse error");
  }

  YYGOTO(yyerrlab1);
  YYLABEL(yyerrlab1) /* here on error raised explicitly by an action */

  if (yyerrstatus == 3) {
    /* if just tried and failed to reuse lookahead token after an error, discard
     * it.  */

    /* return failure if at end of input */
    if (YY_SrvParser_CHAR == YYEOF) YYABORT;

#if YY_SrvParser_DEBUG != 0
    if (YY_SrvParser_DEBUG_FLAG)
      fprintf(stderr, "Discarding token %d (%s).\n", YY_SrvParser_CHAR, yytname[yychar1]);
#endif

    YY_SrvParser_CHAR = YYEMPTY;
  }

  /* Else will try to reuse lookahead token
     after shifting the error token.  */

  yyerrstatus = 3; /* Each real token shifted decrements this */

  YYGOTO(yyerrhandle);

  YYLABEL(yyerrdefault) /* current state does not do anything special for the
                           error token. */

#if 0
  /* This is wrong; only states that explicitly want error tokens
     should shift them.  */
  yyn = yydefact[yystate];  /* If its default is to accept any token, ok.  Otherwise pop it.*/
  if (yyn) YYGOTO(yydefault);
#endif

  YYLABEL(yyerrpop) /* pop the current state because it cannot handle the error
                       token */

  if (yyssp == yyss) YYABORT;
  yyvsp--;
  yystate = *--yyssp;
#ifdef YY_SrvParser_LSP_NEEDED
  yylsp--;
#endif

#if YY_SrvParser_DEBUG != 0
  if (YY_SrvParser_DEBUG_FLAG) {
    short *ssp1 = yyss - 1;
    fprintf(stderr, "Error: state stack now");
    while (ssp1 != yyssp) fprintf(stderr, " %d", *++ssp1);
    fprintf(stderr, "\n");
  }
#endif

  YYLABEL(yyerrhandle)

  yyn = yypact[yystate];
  if (yyn == YYFLAG) YYGOTO(yyerrdefault);

  yyn += YYTERROR;
  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != YYTERROR) YYGOTO(yyerrdefault);

  yyn = yytable[yyn];
  if (yyn < 0) {
    if (yyn == YYFLAG) YYGOTO(yyerrpop);
    yyn = -yyn;
    YYGOTO(yyreduce);
  } else if (yyn == 0)
    YYGOTO(yyerrpop);

  if (yyn == YYFINAL) YYACCEPT;

#if YY_SrvParser_DEBUG != 0
  if (YY_SrvParser_DEBUG_FLAG) fprintf(stderr, "Shifting error token, ");
#endif

  *++yyvsp = YY_SrvParser_LVAL;
#ifdef YY_SrvParser_LSP_NEEDED
  *++yylsp = YY_SrvParser_LLOC;
#endif

  yystate = yyn;
  YYGOTO(yynewstate);
  /* end loop, in which YYGOTO may be used. */
  YYENDGOTO
}

/* END */

#line 1039 "../bison++/bison.cc"
#line 1833 "SrvParser.y"

/////////////////////////////////////////////////////////////////////////////
// programs section

/**
 * method check whether interface with id=ifaceNr has been already declared
 *
 * @param ifaceNr
 *
 * @return true if interface was not declared
 */
bool SrvParser::IfaceDefined(int ifaceNr) {
  SPtr<TSrvCfgIface> ptr;
  SrvCfgIfaceLst.first();
  while (ptr = SrvCfgIfaceLst.get())
    if ((ptr->getID()) == ifaceNr) {
      Log(Crit) << "Interface with ID=" << ifaceNr << " is already defined." << LogEnd;
      return false;
    }
  return true;
}

/**
 * check whether interface with id=ifaceName has been already declared
 *
 * @param ifaceName
 *
 * @return true, if defined, false otherwise
 */
bool SrvParser::IfaceDefined(string ifaceName) {
  SPtr<TSrvCfgIface> ptr;
  SrvCfgIfaceLst.first();
  while (ptr = SrvCfgIfaceLst.get()) {
    string presName = ptr->getName();
    if (presName == ifaceName) {
      Log(Crit) << "Interface " << ifaceName << " is already defined." << LogEnd;
      return false;
    }
  }
  return true;
}

/**
 * method creates new option for just started interface scope
 * clears all lists except the list of interfaces and adds new group
 *
 */
bool SrvParser::StartIfaceDeclaration(string ifaceName) {
  if (!IfaceDefined(ifaceName)) return false;

  SrvCfgIfaceLst.append(new TSrvCfgIface(ifaceName));

  // create new option (representing this interface) on the parser stack
  ParserOptStack.append(new TSrvParsGlobalOpt(*ParserOptStack.getLast()));
  SrvCfgAddrClassLst.clear();
  ClientLst.clear();

  return true;
}

/**
 * method creates new option for just started interface scope
 * clears all lists except the list of interfaces and adds new group
 *
 */
bool SrvParser::StartIfaceDeclaration(int ifindex) {
  if (!IfaceDefined(ifindex)) return false;

  SrvCfgIfaceLst.append(new TSrvCfgIface(ifindex));

  // create new option (representing this interface) on the parser stack
  ParserOptStack.append(new TSrvParsGlobalOpt(*ParserOptStack.getLast()));
  SrvCfgAddrClassLst.clear();
  ClientLst.clear();

  return true;
}

/**
 * this method is called after inteface declaration has ended. It creates
 * new interface representation used in SrvCfgMgr. Also removes corresponding
 * element from the parser stack
 *
 * @return true if everything is ok
 */
bool SrvParser::EndIfaceDeclaration() {
  // get this interface object
  SPtr<TSrvCfgIface> iface = SrvCfgIfaceLst.getLast();

  // set its options
  SrvCfgIfaceLst.getLast()->setOptions(ParserOptStack.getLast());

  // copy all IA objects
  SPtr<TSrvCfgAddrClass> ptrAddrClass;
  SrvCfgAddrClassLst.first();
  while (ptrAddrClass = SrvCfgAddrClassLst.get()) iface->addAddrClass(ptrAddrClass);
  SrvCfgAddrClassLst.clear();

  // copy all TA objects
  SPtr<TSrvCfgTA> ta;
  SrvCfgTALst.first();
  while (ta = SrvCfgTALst.get()) iface->addTA(ta);
  SrvCfgTALst.clear();

  SPtr<TSrvCfgPD> pd;
  SrvCfgPDLst.first();
  while (pd = SrvCfgPDLst.get()) iface->addPD(pd);
  SrvCfgPDLst.clear();

  iface->addClientExceptionsLst(ClientLst);

  // remove last option (representing this interface) from the parser stack
  ParserOptStack.delLast();

  return true;
}

void SrvParser::StartClassDeclaration() {
  ParserOptStack.append(new TSrvParsGlobalOpt(*ParserOptStack.getLast()));
  SrvCfgAddrClassLst.append(new TSrvCfgAddrClass());
}

/**
 * this method is adds new object representig just parsed IA class.
 *
 * @return true if everything works ok.
 */
bool SrvParser::EndClassDeclaration() {
  if (!ParserOptStack.getLast()->countPool()) {
    Log(Crit) << "No pools defined for this class." << LogEnd;
    return false;
  }
  // setting interface options on the basis of just read information
  SrvCfgAddrClassLst.getLast()->setOptions(ParserOptStack.getLast());
  ParserOptStack.delLast();

  return true;
}

/**
 * Just add global options
 *
 */
void SrvParser::StartTAClassDeclaration() {
  ParserOptStack.append(new TSrvParsGlobalOpt(*ParserOptStack.getLast()));
}

bool SrvParser::EndTAClassDeclaration() {
  if (!ParserOptStack.getLast()->countPool()) {
    Log(Crit) << "No pools defined for this ta-class." << LogEnd;
    return false;
  }
  // create new object representing just parsed TA and add it to the list
  SPtr<TSrvCfgTA> ptrTA = new TSrvCfgTA();
  ptrTA->setOptions(ParserOptStack.getLast());
  SrvCfgTALst.append(ptrTA);

  // remove temporary parser object for this (just finished) scope
  ParserOptStack.delLast();
  return true;
}

void SrvParser::StartPDDeclaration() {
  ParserOptStack.append(new TSrvParsGlobalOpt(*ParserOptStack.getLast()));
  this->PDLst.clear();
  this->PDPrefix = 0;
}

bool SrvParser::EndPDDeclaration() {
  if (!this->PDLst.count()) {
    Log(Crit) << "No PD pools defined ." << LogEnd;
    return false;
  }
  if (!this->PDPrefix) {
    Log(Crit) << "PD prefix length not defined or set to 0." << LogEnd;
    return false;
  }

  int len = 0;
  this->PDLst.first();
  while (SPtr<THostRange> pool = PDLst.get()) {
    if (!len) len = pool->getPrefixLength();
    if (len != pool->getPrefixLength()) {
      Log(Crit) << "Prefix pools with different lengths are not supported. "
                   "Make sure that all 'pd-pool' uses the same prefix length."
                << LogEnd;
      return false;
    }
  }
  if (len > PDPrefix) {
    Log(Crit) << "Clients are supposed to get /" << this->PDPrefix << " prefixes,"
              << "but pd-pool(s) are only /" << len << " long." << LogEnd;
    return false;
  }
  if (len == PDPrefix) {
    Log(Warning) << "Prefix pool /" << PDPrefix
                 << " defined and clients are "
                    "supposed to get /"
                 << len
                 << " prefixes. Only ONE client will get "
                    "prefix"
                 << LogEnd;
  }

  SPtr<TSrvCfgPD> ptrPD = new TSrvCfgPD();
  ParserOptStack.getLast()->setPool(&this->PDLst);
  if (!ptrPD->setOptions(ParserOptStack.getLast(), this->PDPrefix)) return false;
  SrvCfgPDLst.append(ptrPD);

  // remove temporary parser object for this (just finished) scope
  ParserOptStack.delLast();
  return true;
}

namespace std {
extern yy_SrvParser_stype yylval;
}

int SrvParser::yylex() {
  memset(&std::yylval, 0, sizeof(std::yylval));
  memset(&this->yylval, 0, sizeof(this->yylval));
  int x = this->lex->yylex();
  this->yylval = std::yylval;
  return x;
}

void SrvParser::yyerror(char *m) {
  Log(Crit) << "Config parse error: line " << lex->lineno() << ", unexpected [" << lex->YYText()
            << "] token." << LogEnd;
}

SrvParser::~SrvParser() {
  ParserOptStack.clear();
  SrvCfgIfaceLst.clear();
  SrvCfgAddrClassLst.clear();
  SrvCfgTALst.clear();
  PresentAddrLst.clear();
  PresentStringLst.clear();
  PresentRangeLst.clear();
}

static char bitMask[] = {0, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe, 0xff};

SPtr<TIPv6Addr> SrvParser::getRangeMin(char *addrPacked, int prefix) {
  char packed[16];
  char mask;
  memcpy(packed, addrPacked, 16);
  if (prefix % 8 != 0) {
    mask = bitMask[prefix % 8];
    packed[prefix / 8] = packed[prefix / 8] & mask;
    prefix = (prefix / 8 + 1) * 8;
  }
  for (int i = prefix / 8; i < 16; i++) {
    packed[i] = 0;
  }
  return new TIPv6Addr(packed, false);
}

SPtr<TIPv6Addr> SrvParser::getRangeMax(char *addrPacked, int prefix) {
  char packed[16];
  char mask;
  memcpy(packed, addrPacked, 16);
  if (prefix % 8 != 0) {
    mask = bitMask[prefix % 8];
    packed[prefix / 8] = packed[prefix / 8] | ~mask;
    prefix = (prefix / 8 + 1) * 8;
  }
  for (int i = prefix / 8; i < 16; i++) {
    packed[i] = 0xff;
  }

  return new TIPv6Addr(packed, false);
}
