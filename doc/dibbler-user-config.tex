%%
%% Dibbler - a portable DHCPv6
%%
%% authors: Tomasz Mrugalski <thomson@klub.com.pl>
%%          Michal Kowalczuk <michal@kowalczuk.eu>
%%
%% released under GNU GPL v2 licence
%%

\newpage
\section{Configuration files}

This section describes Dibbler server, relay  and client
configuration. Square brackets denotes optional values: mandatory
[optional]. Alternative is marked as $\mid$. A $\mid$ B means A or
B. Parsers are case-insensitive, so Iface, IfAcE, iface and IFACE mean
the same. This does not apply to interface names. eth0 and
ETH0 are dwo diffrent interfaces.

\subsection{Data types}
Config file parsing is token-based. Token can be considered a keyword
or a specific phrase. Here's list of tokens used:
\begin{description}
\item[IPv6 address] -- IPv6 address, e.g. 2000:db81::dead:beef
\item[32-bit decimal integer] -- string containing only numbers, e.g. 12345
\item[string] -- string of arbitrary characters enclosed in single or double
  quotes, e.g. 'this is a string'. If string contains only a-z, A-Z and
  0-9 characters, quotes can be omited, e.g. beeblebrox
\item[DUID identifier] -- hex number starting with 0x,
  e.g. 0x12abcd. In Dibbler version 0.8.0RC1, another format was
  introduced: 2 hex digits separated by comma, e.g. 12:aa:bb:cc:d5. As
  this format may in some cases be confused with IPv6 address, the old
  format (starting with 0x) remains to be supported.
\item[IPv6 address list] -- IPv6 addresses separated with commas,
	   e.g. 2000::123, 2000::456
\item[DUID list] -- DUIDs separated with commas, e.g. 0x0123456,0x0789abcd
\item[string list] -- strings separated with comas, e.g. tealc,jackson,carter,oneill
\item[boolean] -- YES, NO, TRUE, FALSE, 0 or 1. Each of them can be
  used, when user must enable or disable specific option.
\end{description}

\subsection{Scopes}
There are four scopes, in which options can be specified: global,
inteface, IA and address. Every option is specific for one scope.
Each option is only applied to a scope and all subscopes in which it is
defined. For example, T1 is defined for
IA scope. However, it can be also used in more common scopes. In this
case -- in interface or global. Defining T1 in interface scope means:
,,for this interface the default T1 value is ...''. The same applies
to global scope. Options can be used multiple times. In that case
value defined later is used.

Global scope is the largest. It covers the whole config file and
applies to all intefaces, IAs, and addresses, unless some lower scope
options override it. Next comes inteface scope. Options defined there
are inteface-specific and apply to this interface, all IAs in this
interface and addresses in those IAs. Next is IA scope. Options
defined there are IA-specific and apply to this IA and to addresses it
contains. Least significant scope is address.

\subsection{Comments}

Comments are allowed in configuration files. All common comment styles are supported:
\begin{itemize}
\item C++ style one-line comments: // this is comment
\item C style multi-line comments: /* this is multiline comment */
\item bash style one-line comments: \# this is one-line comment
\end{itemize}

\subsection{Client configuration file}
\label{client-cfg-file}
Client configuration file should be named \verb+client.conf+. It should be
placed in the \verb+/etc/dibbler/+ directory (Linux system) or in the
current directory (Windows systems). After successful startup, old
version of this file is stored as \verb+client.conf-old+. One of
design requirements for client was ,,out of the box'' usage. To
achieve this, simply use empty
\verb+client.conf+ file. Client will try to get one address for each up and
running interface \footnote{Exactly: Client tries to configure each
  up, multicast-capable and running interface, which has link address
  at least 6 bytes long. So it will not configure tunnels (which
  usually have IPv4 address (4bytes long) as their link address. It
  should configure all Ethernet and 802.11 interfaces. The latter was
  not tested by author due to lack of access to 802.11 equipment.}.

\subsubsection{Interface declaration}

Each system interface, which should be configured, must be mentioned in
the configureation file. Interfaces can be declared with this syntax:
\begin{verbatim}
iface interface-name
{
  interface-options
  IA-options
  address-options
}
\end{verbatim}

or

\begin{verbatim}
iface interface-number
{
  interface-options
  IA-options
  address-options
}
\end{verbatim}

In the latter case, interface-number denotes interface number. It can be extracted
from ,,ip~l'' (Linux) or
,,ipv6~if'' (Windows). \verb+interface-name+ is an interface
name.  Name of the interface does not have to be enclosed in single or
double quotes. It is necessary only in Windows systems, where interface
names sometimes contain spaces, e.g. ''local network connection''.
Interface scoped options can be used here. IA-scoped as well as address
scoped options can also be used. They will be treated as a default
values for future definitions of the IA and address instantations.

\subsubsection{IA declaration}
IA is an acronym for Identity Association. It is a logical entity
representing address or addresses used to perform some
functions. IA-options can be defined, e.g. T1. IPv6 addresses can be
defined here. All those values will be used as hints for a server.
Almost always, each DHCPv6 client will have exactly one IA on each
interface. IA is declared using following syntax:

\begin{verbatim}
ia
{
  IA-options
  address-options
  address-declaration
}
\end{verbatim}

It is also possible to define multiple IA at once. To do so, following
syntax might be used:

\begin{verbatim}
ia number
{
  IA-options
  address-options
}
\end{verbatim}
Number is an optional number, which describes how many such IAs
should be requested. Number is optional. If it is not specified, 1 is
used. If this number is not equal 1, then address options are not
allowed. That could come in handy when someone need serveral IAs with
the same parameters. If IA contains no addresses, client assumes that
one address should be configured. IA scoped as well as address options
can be defined here. IA scoped options will be applied directly, while
address scoped options will be used as default values for all addresses
that will be defined in this IA.

\subsubsection{Address declaration}
When IA is defined, it is sometimes useful to define its address. Its
value will be used as a hint for the server. Address is declared in the
following way:

\begin{verbatim}
address number
{
  address-options
  IPv6-address
}
\end{verbatim}
where number denotes how many addresses with those values should be
requested. If it is diffrent than 1, then IPv6 address options are not
allowed. Only address scoped options can be used here.

\subsubsection{Standard options}
So called standard options are defined by the base DHCPv6
specification, a so called RFC 3315 document \cite{rfc3315}. Those options are
called standard, because all DHCPv6 implementations, should properly
handle them. Standard options are declared in the following way:

\begin{verbatim}
OptionName option-value
\end{verbatim}

Every option has a scope it can be used in, default value and
sometimes allowed range.

\begin{description}
 \item[work-dir] -- (scope: global, type: string, default: .) Defines
   working directory.
 \item[log-level] -- (scope: global, type: integer, default: 7)
   Defines verbose level of the log messages. The valid range if from
   1 (Emergency) to 8 (Debug). The higher the logging level is set,
   the more messages dibbler will print.
 \item[log-name] -- (scope: global, type: string, default:
   Client). Defines name, which should be used during logging.
 \item[log-mode] -- (scope: global, type: short, full, precise or
   syslog default value: full) Defines logging mode. In the default,
   full mode, name, date and time in the h:m:s format will be
   printed. In short mode, only minutes and seconds will be printed
   (this mode is useful on terminals with limited width). Recently
   added precise mode logs information with seconds and microsecond
   precision. It is a useful for finding bottlenecks in the DHCPv6
   autoconfiguration process. Syslog works under Linux only and allows
   default POSIX logging functions.
\item[log-colors] -- (scope: global, type: boolean, default:
  off). Defines if logs printed to console should use colors. That
  feature is used to enhance logs readability.  As it makes the log
  files messy on systems that do not support colors, it is disabled by
  default.
 \item[strict-rfc-no-routing] -- (scope: global, type: none, default:
   not defined). During normal operation, DHCPv6 client should add
   IPv6 address only, without configuring routing, because this should
   be done with other means, i.e. router advertisements
   \cite{rfc2461}. However, this behavior is confusing and lots of
   users complained about it, so since the 0.5.0-RC1 release, this has
   been changed in dibbler. Right now when dibbler client configures
   address, it also configures routing, so every host is able to
   communicate with other hosts, which have obtained address from the
   same server. If you don't like this behavior, you might want to use
   this option.
\item[scripts-dir] -- (scope: global, type: string, default: system
  dependent ). When dibbler client receives some options it normally
  sets them up in the system. However, instead of setting up all
  parameters directly, dibbler client can execute external
  scripts. Those scripts will be executed when particular option is
  received. By default, those scripts can be stored in scripts/ for
  Windows, or /var/lib/dibbler/scripts for Linux. Using scripts-dir
  directive it is possible to define other location of the
  scripts. Take note that directory should be defined in single or
  double quotes.  (" sign).
\item[anonymous-inf-request] -- (scope: global, type: present or
  absent, default: absent). When running in a stateless mode, client
  does not ask for addresses or prefixes, but rather requests some
  general options. By default, it sends its client identifier (DUID)
  to the server. However, it is possible to omit this identifier, so
  the \msg{INF-REQUEST} messages will be anonymous. This global option
  causes client to act in such anonymous way.
 \item[inactive-mode] -- (scope: global, type: present or absent,
   default: absent). Normally (with inactive-mode disable) client
   tries to bind all interfaces defined in configuration file. If such
   attempt fails, client reports an error and gives up. In some cases
   it is possible that interface is not ready yet, e.g. WLAN interface
   did not complete association. It is possible to modify client
   behavior, so it will accept downed and not running interfaces. To
   do so, inactive-mode must be enabled. In this mode, client will
   accept inactive interfaces, will add them to inactive list and will
   periodically monitor its state. When the interface finally goes
   on-line, client will try to configure it. See section
   \ref{feature-inactive-mode} for details.
 \item[insist-mode] -- (scope: global, type: present or absent,
   default: absent). Client can be instructed to obtain several
   configuration options, like DNS server configuration or domain
   name. It is possible that server will not provide all requested
   options. Older versions of the dibbler client had been very
   aggressive in such case. It tried very hard to obtain such
   options. To do so, it did send \msg{INF-REQUEST} to obtain such
   option. This behavior has changed. Right now when client does not
   receive all requested options, it will complain, but will take no
   action. To enable old behavior, so called insist-mode has been
   added. See section \ref{feature-insist-mode} for details.
 \item[duid-type] -- (scope: global, type: DUID-LLT, DUID-LL or
   DUID-EN, default: DUID-LLT). This parameter defines, what type of
   DUID should be generated if there is no DUID already present. If
   there is a file containing DUID, this directive has no
   effect. DUID-LLT means that DUID will be based on link layer
   address as well as time. DUID-LL means that only link layer address
   will be used. The last value -- DUID-EN -- Enterprise Number-based
   generation has a slightly different syntax: duid-type duid-en
   enterprise-number enterprise-id. For example: duid-type duid-en
   1234 0x6789abcd means that enterprise number is set to 1234 and
   unique number from that company's pool is 67:89:ab:cd (hexadecimal
   value of arbitrary length). See section \ref{feature-duid-types}
   for details.
\item[option fqdn-s] -- (scope: global, type: boolean, default:
  1). The S bit is used in FQDN option. It is used to negotiate, which
  side (server or client) wants to perform DNS Update procedure. See
  \cite{rfc4704} for details. In general, if you don't want that this
  option does, you don't want to modify this.
 \item[rapid-commit] -- (scope: interface, type: boolean, default:
   0). This option allows rapid commit procedure to be performed. Note
   that enabling rapid commit on the client side is not enough. server
   must be configured to allow rapid commit, too.
 \item[unicast] -- (scope: interface, type: boolean, default: 0). This
   option specifies if client should request unicast communication
   from the server. If server is configured to allow it, it will add
   unicast option to its replies. It will allow client to communicate
   with server via unicast addresses instead of usual multicast.
 \item[prefered-servers] -- (scope: interface, type: address or duid
   list, default: empty). This list defines, which servers are
   prefered. When client sends \msg{SOLICIT} message, all servers
   available in the local network will respond. When client receives
   multiple \msg{ADVERTISE} messages, it will choose those sent by
   servers mentioned on the perfered-server list.
 \item[reject-servers] -- (scope: interface, type: address or duid
   list, default: empty) This list defines which server must be
   ignored. It has negative meaning to the prefered-servers list.
 \item[vendor-spec] -- (scope: interface, type: integer-hexstring,
   default: empty). This option allow requesting for a vendor specific
   configuration option. It does not any good in itself as there are
   no dibbler-specific options to configure. It can be, however, used
   to test some other DHCPv6 server implementations. In short words:
   if you don't know what that is, you don't need it.
 \item[T1] -- (scope: IA, type: integer: default: $2^{32}-1$). This
   value defines after what time client should start renew
   process. This is only a hint for the server. Actual value will be
   provided by the server.
 \item[T2] -- (scope: IA, type: integer, default:$2^{32}-1$). This
   value defines after what time client will start emergency rebind
   procedure if renew process fails. This is only a hint for the
   server. Actual value will be provided by the server.
 \item[valid-lifetime] -- (scope:address, type: integer,
   default:$2^{32}-1$) This parameter defines valid lifetime of an
   address. It will be used as a hint for a server, when the client
   will send requests.
 \item[prefered-lifetime] -- (scope:address, type: integer,
   default:$2^{32}-1$) This parameter defines prefered lifetime of an
   address. It will be used as a hint for a server, when there client
   will send requests.
\end{description}

\subsubsection{Extension options}
\label{client-conf-extension}
Extension options are the options specified in external drafts and RFC
documents, but not in the base spec \cite{rfc3315}. To easily
distinguish if an option is part of the base standard or one of the
multiple extensions, \verb+option+ keyword was added in the extension
options declaration. Therfore extension options are declared as
follows:

\begin{verbatim}
option option-name
\end{verbatim}

or

\begin{verbatim}
option option-name option-value
\end{verbatim}

where option-name is name of the options. First approach instructs
dibbler client to just ask for this particular option. Second approach
includes requested values. When sent by the client, server will use
those values as hints during those options assignment. Since those
options are defined per interface, thus every extension option has an
interface scope, i.e. it is defined once per interface. As for the
\version release, currently supported options are:

\begin{description}
 \item[dns-server] -- (scope: interface, type: address list, default:
   none). This option conveys information about DNS servers
   available. After retriving this information, client will be able to
   resolve domain names into IP (both IPv4 and IPv6)
   addresses. Without setting up DNS servers, host's network
   capability is greatly reduced, as user can't use domain names
   (e.g. http://wp.pl/), but must use IP addresses directly
   (e.g. http://212.77.100.101/ or
   http://2001:db8:1:1234::456/). Defined in \cite{rfc3596}.
 \item[domain] -- (scope: interface, type: domain list, default:
   none). This option is used for retriving domain or domains names,
   which the client is connected in. For example, if client's hostname
   is \verb+alice.mylab.example.com+ and it wants to contact
   \verb+bob.mylab.example.com+ it can simply refer to it as
   \verb+bob+. Without domain name configured, it would have to use
   full domain name. After successful configuration, this useful
   shortcut is being used by all services available: web browsing,
   mail sending, news reading etc. Defined in \cite{rfc3596}.
 \item[ntp-server] -- (scope: interface, type: address list, default:
   none). This option defines information about available NTP
   servers. Network Time Protocol \cite{rfc2030} is a protocol used
   for time synchronisation, so all hosts in the network has the same
   proper time set. Defined in \cite{rfc4075}.
 \item[time-zone] -- (scope: interface, type: timezone, default:
   none). It is possible to retrieve timezone from the server. If
   client is interested in this information, it should ask for this
   option. Note that this option is considered obsolete as it is
   mentioned in draft version only \cite{draft-timezone}. Work on this
   draft seems to be abandoned as similar functionality is provided in
   now standard \cite{rfc4075}.
 \item[sip-server] -- (scope: interface, type: address list, default:
   none). Session Initiation Protocol \cite{rfc3263} is an control
   protocol for creating, modifying, and terminating sessions with one
   or more participants. These sessions include Internet telephone
   calls, multimedia distribution, and multimedia conferences. Its
   most common usage is VoIP. Format of this option is defined in
   \cite{rfc3319}.
 \item[sip-domain] -- (scope: interface, type: domain list, default:
   none). It is possible to define domain names for Session Initiation
   Protocol \cite{rfc3263}. Configuration of this parameter will ease
   usage of domain names in the SIP protocol. Format of this option is
   defined in \cite{rfc3319}.
 \item[nis-server] -- (scope: interface, type: address list, default:
   none). Network Information Service (NIS) is a Unix-based system
   designed to use common login and user information on multiple
   systems, e.g. universities, where students can log on to ther
   accounts from any host. To use this functionality, a host needs
   information about NIS server's address. This can be retrieved with
   this option. Its format is defined in \cite{rfc3898}.
 \item[nis-domain] -- (scope: interface, type: domain list, default:
   none). Network Information Service (NIS) can albo specify domain
   names. It can be configured with this option. It is defined in
   \cite{rfc3898}.
 \item[nis+-server] -- (scope: interface, type: address list, default:
   none). Network Information Service Plus (NIS+) is an improved
   version of the NIS protocol. This option is defined in
   \cite{rfc3898}.
 \item[nis+-domain] -- (scope: interface, type: domain list, default:
   none). Similar to nis-domain, it defines domains for NIS+. This
   option is defined in \cite{rfc3898}.
 \item[lifetime] -- (scope: interface, type: boolean, default:
   no). Base spec of the DHCPv6 protocol does offers way of refreshing
   addresses only, but not the options. Lifetime defines, how often
   client would like to renew all its options. By default client will
   not send such option, but it will accept it and act accordingly if
   the server sends it on its own. Format of this option is defined in
   \cite{draft-lifetime}.
 \item[aftr] -- (scope: interface, type: FQDN). In Dual-Stack Lite
   networks, client may want to configure DS-Lite tunnel. Client may
   want to obtain information about AFTR (a remote tunnel
   endpoint). This option conveys fully qualified domain name. It is
   defined in defined in \cite{draft-ds-lite}.
 \item[auth-enabled] -- (scope: global, type: boolean, default:
   no). This option enables authentication and authorization. When set
   to true, server support must also be enabled, otherwise all
   messages will be dropped.
 \item[auth-accept-methods] -- (scope: global, type: string, default:
   empty).  Comma separated list of authentication methods that client
   will accept from server. If this list is empty, any method will be
   accepted. Possible values are:
   \begin{itemize}
   \item \texttt{none}
   \item \texttt{digest\_plain}
   \item \texttt{digest\_hmac\_md5}
   \item \texttt{digest\_hmac\_sha1}
   \item \texttt{digest\_hmac\_sha224}
   \item \texttt{digest\_hmac\_sha256}
   \item \texttt{digest\_hmac\_sha384}
   \item \texttt{digest\_hmac\_sha512}
   \end{itemize}
\end{description}

Note that timezone format is described in file \verb+draft-ietf-dhc-dhcpv6-opt-tz-00.txt+
and domain format is described in RFC 3646. After receiving options
values from a server, client stores values of those options in separate
files in the working directory (\verb+/var/lib/dibbler+ in Linux and
current directory in Windows). File names start with the option word,
e.g. \verb+option-dns-server+. Several options are also processed and
set up in the system. Options supported in Linux and Windows
environments are presented in the table below.


\begin{center}
\begin{tabular}{|l|l|l|l|}
\hline
Option & Linux & WinXP/2003 & WinNT/2000  \\
\hline
dns-server  & system, file & system, file & system,file \\
domain      & file         & file & file \\
ntp-server  & file         & file & file \\
time-zone   & file         & file & file \\
sip-server  & file         & file & file \\
sip-domain  & file         & file & file \\
nis-server  & file         & file & file \\
nis-domain  & file         & file & file \\
nis+-server & file         & file & file \\
nis+-domain & file         & file & file \\
\hline
\end{tabular}
\end{center}

\subsubsection{Stateless configuration}

If interface does not contain \verb+IA+ or \verb+TA+ keywords, client
will ask for one address (one IA with one address request will be sent).
If client should not request any addresses on this interface,
\opt{stateless}\footnote{In the version 0.2.1-RC1 and earlier, this
  directive was called no-ia. This depreciated name is valid for now,
  but might be removed in future releases.} keyword must be used. In
such circumstances, only specified options will be requested.

\subsubsection{Relay support}
Usage of the relays is not visible from the client's point of view:
Client can't detect if it communicates via relay(s) or directly
with the server. Therefore no special directives on the client side
are required to use relays. See section \ref{features-relays} for
details related to relay deployment.

\subsection{Client configuration examples}
This subsection contains various examples of the most popular
configurations. Several additional examples are provided with the source
code. Please download it and look at \verb+*.conf+ files.

\subsubsection{Example 1: Default}
In the most simple case, client configuration file can be empty. Client will try to
assign one address for every interface present in the system, except
interfaces, which are:
\begin{itemize}
\item down (flag UP not set)
\item loopback (flag LOOPBACK set)
\item not running (flag RUNNING not set)
\item not multicast capable (flag MULTICAST not set)
\item have link-layer address less than 6 bytes long (this requirement
      should skip all tunnels and virtual interfaces)
\end{itemize}

If you must use DHCPv6 on one of such interfaces (which is not
recommended and such attempt probably will fail), you must explicitly
specify this interface in the configuration file.

\subsubsection{Example 2: DNS}
Configuration mentioned in previous subsection is a minimal one and in a
real life will be used rarely. The most common usage of the DHCPv6
protocol is to request for an address and DNS configuration. Client
configuration file achieving those goals is presented below:
\begin{lstlisting}
# client.conf
log-mode short
log-level 7
iface eth0 {
  ia
  option dns-server
}
\end{lstlisting}

\subsubsection{Example 3: Timeouts and specific address}

Automatic configuration is being driven by several timers, which define,
what action should be performed at various intervals. Since all
values are provided by the server, client can only define values, which
will be sent to a server as hints. Server might take them into
consideration, but might also ignore them
completely. Following example shows how to ask for a specific address
and provide hints for a server. Client would like to get 2000::1:2:3
address, it would like to renew addresses once in 30 minutes (T1 timer
is set to 1800 seconds). Client also would like to have address, which
is prefered for an hour and is valid for 2 hours.

\begin{lstlisting}
# client.conf
log-mode short
log-level 7
iface eth0 {
  T1 1800
  T2 2000
  prefered-lifetime 3600
  valid-lifetime 7200
  ia {
    address {
      2000::1:2:3
    }
  }
}
\end{lstlisting}

\subsubsection{Example 4: More than one address}

Another example: client would like to obtain 2 addresses on
wifi0 interface. They are necessary since this particular interface name
contains spaces. It is possible to do this in two ways. First is to
sent 2 Identity Associations (IA for short). Identity Association is a
nice name for a addresses container. This appears to be a most common
way of telling server that this client is interested in more than one
address.

\begin{lstlisting}
# client.conf
log-mode short
log-level 5
iface wifi0 {
  ia
  ia
}
\end{lstlisting}

Another way it to send one IA, but include two address hints in
it. Server may take them into consideration (dibbler server does), but
some other DHCPv6 implementations may ignore those hints.

\begin{lstlisting}
# client.conf
log-mode short
log-level 5
iface wifi0 {
  ia {
     address
     address
  }
}
\end{lstlisting}

\subsubsection{Example 5: Quick configuration using Rapid-commit}
Rapid-commit is a shortened exchange with server. It consists of only
two messages, instead of the usual four. It is worth to know that both sides (client
and server) must also support rapid-commit to use this fast
configuration.

\begin{lstlisting}
# client.conf
iface eth1 {
  rapid-commit yes
  ia
  option dns-server
}
\end{lstlisting}

\subsubsection{Example 6: Stateless mode}
Client can be configured to work in a stateless mode. It means that it
will obtain only some configuration parameters, but no
addresses. Let's assume we want all the details stored in a log file and
we want to obtain all possible configuration parameters. Here is a
configuration file:

\begin{lstlisting}
# client.conf
log-level 8
log-mode full
stateless
iface eth0
{
  option dns-server
  option domain
  option ntp-server
  option time-zone
  option sip-server
  option sip-domain
  option nis-server
  option nis-domain
  option nis+-server
  option nis+-domain
}
\end{lstlisting}

\subsubsection{Example 7: Dynamic DNS (FQDN)}
\label{example-client-fqdn}
Dibbler client is able to request fully qualified domain name,
i.e. name, which is fully resolvable using DNS. After receiving such
name, it can perform DNS Update procedure. Client can ask for any
name, without any preferrence. Here is an example how to configure
client to perform such task:
\begin{lstlisting}
# client.conf

# uncomment following line to force S bit to 0
# option fqdn-s 0
log-level 7
iface eth0 {
# ask for address
    ia

# ask for options
   option dns-server
   option domain
   option fqdn
}
\end{lstlisting}

In this case, client will mention that it is interested in FQDN by
using Option Request and empty FQDN option, as specified in
\cite{rfc4704}. Server upon receiving such request (if it is
configured to support it), will provide FQDN option containing domain
name. Depending on the server's configuration, all DNS Updates will be
performed by the server, forward will be performed by client and reverse
by the server, or only forward will be done by a client.

It is also possible for client to provide its name as a hint for
server. Server might take it into consideration when it will choose a
name for this client. Example of a configuration file for such
configuration is provided below:

\begin{lstlisting}
# client.conf
log-level 7
iface eth0 {
    # ask for address
    ia

    # ask for options
    option dns-server
    option domain
    option fqdn zoe.example.com
}
\end{lstlisting}

Note that to successfully perform DNS Update, address must be assigned
and dns server address must be known. So ,,ia'' and ,,option
dns-server'' are required for ,,option fqdn'' to work properly. Also if
DHCPv6 server provides more than one DNS server address, update will
be attempted only forthe first address on the list.

It is also possible to force S bit in the FQDN option to 0 or 1. See
\cite{rfc4704} for details regarding its meaning.

\subsubsection{Example 8: Interface indexes}
Usually, interface names are referred to by names, e.g. eth0 or Local
Area Connection. Every system also provides unique number associated
with each infterface, usually called ifindex or interface index. It is
possible to read the number using \verb+ip l+ command (Linux) or
\verb+ipv6 ifx+. Below is an example, which demonstrate how to use
interface indexes:

\begin{lstlisting}
# client.conf
log-mode short
log-level 5
iface 5 {
  ia
}
\end{lstlisting}

\subsubsection{Example 9: Vendor-specific options}
\label{example-client-vendor-spec}
It is possible to configure dibbler-client to ask for a vendor specific
options. Although there are no dibbler-specific features to configure,
it is possible to use this option to test other server
implementations. This option will rather be used by network engineers
and power network admins, rather than normal end users.

There are 3 ways to define, how dibbler-client can request
vendor-specific options. First choice: It can just ask for this option (only
\opt{option request option} will be sent). Second choice: it can ask for
vendor-spec option by adding such option with enterprise number set, but
no actual data. Third choice: send this option and include both
enterprise number and actual data. In the following configuration file
example, uncomment appropriate line to obtain desired bahavior:

\begin{lstlisting}
# client.conf
log-level 8
iface eth0 {
# ask for address
    ia

# uncomment only one of the following lines:
   option vendor-spec
#   option vendor-spec 1234
#   option vendor-spec 1234 0x0002abcd

# To ask for multiple vendor-spec options, uncomment:
#   option vendor-spec 123,456
}
\end{lstlisting}

Although that is almost never needed, it is possible to configure
client to request multiple vendor-specific options at the same
time. That feature is mainly used as a test tool for the server. To
use it, uncomment last line in the example above.

\subsubsection{Example 10: Unicast communication}

Client would like to obtain an address on ,,Local Area Connection''
interface. Note quotation marks around
interface name. They are necessary since this particular interface name
contains spaces. Client also would like to accept Unicast
communication if server supports it. User wants all information
to be logged via Linux syslog daemon. Take note that you won't be
able see to what Dibbler is doing with such low log-level. (Usually
log-level should be set to 7, which is also a default value).

\begin{lstlisting}
# client.conf
log-mode syslog
log-level 5
iface "Local Area Connection" {
  unicast yes
  ia
  ia
}
\end{lstlisting}

\subsubsection{Example 11: Prefix delegation}
\label{example-client-prefix}
From the client's point of view, configuration is quite simple. It is
required to specify that this client is interested in prefix
delegation. See section \ref{features-prefix} for background
information related to prefix delegation and sections
\ref{example-server-prefix} and \ref{example-server-prefixes} for
details about server configuration. To ask for prefix delegation,
emph{prefix-delegation} (or \emph{pd}) should be used.

\begin{lstlisting}
# client.conf
iface "eth0" {
  ia  // ask for address
  pd  // ask for prefix
}
\end{lstlisting}

It is possible to define additional parameters for a prefix:

\begin{lstlisting}
# client.conf
iface eth0 {
  pd {
    t1 1000
    t2 2000
  }
}
\end{lstlisting}

\subsubsection{Example 12: Insist mode}
\label{example-client-insistmode}
During normal operation, when client asks for an option, but does not
receive it from the server, it complain, but takes no action. To force
client to insist (i.e. ask over and over again), so called insist mode
has been introduced. See section \ref{feature-insist-mode} for
extended explanation.

\begin{lstlisting}
insist-mode
iface "eth0" {
   ia
   option dns-server
   option domain
   option ntp-server
}
\end{lstlisting}

\subsubsection{Example 13: Inactive mode}
\label{example-client-inactivemode}
Usually client starts when network interfaces are
operational. Normally downed or nonexisting interfaces mentioned in
the configuration file are considered misconfiguration and client
refuses to start. However, sometimes that is not the case, e.g. still
waiting to be associated wireless interfaces. To allow operation in
such circumstances, inactive mode has been added. See
\ref{feature-inactive-mode} for detailed explanation.
interfaces are spec

\begin{lstlisting}
inactive-mode
iface "eth0" {
  ia
}
\end{lstlisting}

\subsubsection{Example 14: Authentication}
\label{example-client-auth}
Authentication is enabled. Client will accept HMAC-SHA-512, HMAC-MD5
and HMAC-SHA-256 as an authentication method.

\begin{lstlisting}
# client.conf

log-mode short
log-level 7

auth-enabled true
auth-accept-methods digest-hmac-sha512, digest-hmac-md5, digest-hmac-sha256

iface eth0 {
}
\end{lstlisting}

\subsubsection{Example 15: Skip Confirm}
\label{example-client-confirm}
Client detects if previous client instance was not shutdown properly
(due to power outage, client crash or similar event). In such case, it
reads existing address database and checks if assigned addresses may
still be valid. If that is so, it tries to confirm those addresses by
using \msg{CONFIRM} message.

If user don't want \msg{CONFIRM} message to be send and client should
start ''from scratch'' every time, it is possible to disable confirm
support.

\begin{lstlisting}
# client.conf

log-mode short
log-level 7
skip-confirm

iface eth0 {
  ia
}
\end{lstlisting}

\subsubsection{Example 15: User-defined IAID}
\label{example-client-iaid}
Sometimes it is useful to define specific IAID  identifiers. That is
rather uncommon, but possible. This technique can be used for both
addresses (IA\_NA options) and prefixes (IA\_PD options).

\begin{lstlisting}
# client.conf

iface "eth0" {
  ia 123
  option dns-server
  option domain
}
\end{lstlisting}

\subsubsection{Example 16: DS-Lite tunnel (AFTR)}
\label{example-server-ds-lite}
Server may provide information about AFTR (a Dual Stack Lite tunnel
endpoint) to the clients, as specified in \cite{draft-ds-lite}.

\begin{lstlisting}
iface "eth0" {
  ia
  option aftr # request name of the remote DS-Lite tunnel endpoint
}
\end{lstlisting}

\subsubsection{Example 17: Custom options}
Client is able to ask for custom options, that are not supported by
default. Following config file allows client to ask for many
options. Also, see Section \ref{features-custom-options} for
extended explanation.

\begin{lstlisting}
#client.conf
iface "eth0" {
  unicast 1
  ia

  option 145 - 01:02:a3:b4:c5:dd:ea
  option 146 address 2001:db8:1::dead:beef
  option 147 address-list 2001:db8:1::aaaa,2001:db8:1::bbbb
  option 148 string "secretlair.example.org"

  option 149 string request
  option 150 address request
  option 151 address-list request
\end{lstlisting}

\subsubsection{Example 18: Remote Autoconfiguration}
Client is able to use experimental extension to ask for configuration
remotely. See Section \ref{features-remote-autoconf} for details.

\begin{lstlisting}
log-mode short
log-level 8
experimental
remote-autoconf

iface "eth0" {
  ia
  unicast 1
  option dns-server
  option domain
  option nis-server
  option nis-domain
  option nis+-server
  option nis+-domain
  option time-zone
  option lifetime
}
\end{lstlisting}

\subsection{Server configuration file}
\label{server-conf}
Server configuration is stored in \verb+server.conf+ file in the
\verb+/etc/dibbler+ (Linux systems) or in current (Windows systems)
directory.

\subsubsection{Global scope}

Every option can be declared in a global scope. Global options can be
defined here. Also options of a smaller scopes can be defined here --
they will be used as a default values. Configuration file has following syntax:

\begin{verbatim}
 global-options
 interface-options
 class-options
 interface-declaration
\end{verbatim}

\subsubsection{Interface declaration}
Each network interface, which should be serviced by the server, must be
mentioned in the configuration file. Network interface is defined like this:
\begin{verbatim}
iface interface-name
{
  interface-options
  class-options
}
\end{verbatim}

or

\begin{verbatim}
iface number
{
  interface-options
  class-options
}
\end{verbatim}

where \verb+interface-name+ denotes name of the interface and
\verb+interface-number+ denotes its number. Name no longer needs to be
enclosed in single or double quotes (except Windows systems, when
interface name contains spaces). Note that virtual interfaces, used
to setup relay support are also declared in this way.

\subsubsection{Class scope}
Class is a smallest scope used in the server configuration file. It
contains definition of the addresses, which will be provided to
clients. Only class scoped parameters can be defined here. Address class
is declared as follows:
\begin{verbatim}
class
{
  class-options
  address-pool
}
\end{verbatim}

Address pool defines range of the addresses, which can be assigned to the
clients. It can be defined in one of the following formats:
\begin{verbatim}
pool minaddress-maxaddress
pool address/prefix
\end{verbatim}

\subsubsection{Standard options}

So called standard options are defined by the base DHCPv6 specification,
a so called RFC 3315 document \cite{rfc3315}. Those options are
called standard, because all DHCPv6 implementations, should properly
handle them. Each option has a specific scope it belongs to.

Standard options are declared in the following way:

\begin{verbatim}
OptionName option-value
\end{verbatim}

\begin{description}
 \item[work-dir] -- (scope: global, type: string, default: .) Defines working
	    directory.
 \item[log-level] -- (scope: global, type: integer, default: 7) Defines
	    verbose level of the log messages. The valid range if
	    from 1 (Emergency) to 8 (Debug). The higher the logging
	    level is set, the more messages dibbler will print.
 \item[log-name] -- (scope: global, type: string, default: Server). Defines
	    name, which should be used during logging.
 \item[log-mode] -- (scope: global, type: short, full, precise or syslog
	    default value: full) Defines logging mode. In the
	    default, full mode, name, date and time in the h:m:s format
	    will be printed. In short mode, only minutes and
	    seconds will be printed (this mode is useful on
	    terminals with limited width). Recently added precise
	    mode logs information with seconds and microsecond
	    precision. It is a useful for finding bottlenecks in
	    the DHCPv6 autoconfiguration process. Syslog is a Linux
	    mode only.
 \item[cache-size] -- (scope: global, type: integer, default:
	    1048576). It defines a size of the memory (specified in
	    bytes) which can se used to store cached entries.
\item[interface-id-order] -- (scope: global, type: before, after or omit,
	default: before) This parameter defines placement of the
	interface-id option. During message relaying options can be placed in the \msg{RELAY-REPL}
	message is arbitrary order. This option has been specified to control
	that order. \opt{interface-id} option can be placed before or after
	\opt{relay-message} option. There is also possibility to instruct
	server to omit the \opt{interface-id} option altogether, but since
	this violates \cite{rfc3315}, it should not be used. In general, this
	configuration parameter is only useful when dealing with buggy relays,
	which can't handle all option orders properly. Consider this parameter
	a debugging feature. Note: similar parameter is available in the dibbler-relay.
\item[inactive-mode] -- (scope: global, type: present or missing,
  default: missing). This enables so called inactive mode. When server
  begins operation and it detects that required interfaces are not
  ready, error message is printed and server exits. However, if
  inactive mode is enabled, server sleeps instead and wait for
  required interfaces to become operational. That is a useful feature,
  when using wireless interfaces, which take some time to initialize
  as associate.
\item[guess-mode] -- (scope: global, type: present or missing,
  default: missing). When this option is enabled, server will not pay
  close attention to the interface-id option in relayed messages. If
  interface-id has a value other than specified in server.conf or even
  when there is no interface-id option at all, it will use first relay
  defined.
 \item[preference] -- (scope: interface, type: 0-255, default:
	    none). Eech server can be configured to a specific
	    preference level. When client receives several
	    \msg{ADVERTISE} messages, it should choose that server,
	    which has the highest preference level. It is also worth
	    noting that client, upon reception of the \msg{ADVERTISE}
	    message with preference set to 255 should skip wait phase
	    for possible other \msg{ADVERTISE} messages.
 \item[unicast] -- (scope: interface, type: address,
	    default:none). Normally clients sends data to a well known
	    multicast address. This is easy to achieve, but it wastes
	    network resources as all nodes in the network must process
	    such messages and also network load is increased. To prevent
	    this, server might be configured to inform clients about its
	    unicast address, so clients, which accept it, will switch to
	    a unicast communication.
 \item[rapid-commit] -- (scope: interface, type: boolean, default:
	    0). This option allows rapid commit procedure to be
	    performed. Note that enabling rapid commit on the server
	    side is not enough. Client must be configured to allow
	    rapid commit, too.
\item[iface-max-lease] -- (scope: interface, type: integer, default:
	    $2^{32}-1$). This parameter defines, how many normal
	    addresses can be granted on this interface.
\item[client-max-lease] -- (scope: interface, type: interger,
	    default:$2^{32}-1$). This parameter defines, how many
	    addresses one client can get. Main purpose of this
	    parameter is to limit number of used addresses by
	    misbehaving (malicious or restarting) clients.
\item[relay] -- (scope: interface, type: string, default: not
	    defined). Used in relay definition.
	    It specifies name of the physical (or name of
	    another relay, if cascade relaying is used) interface,
	    which is used to receive and transmit relayed data. See
	    \ref{features-relays} for details of relay deployment and
	    sections \ref{example-server-relay1} and
	    \ref{example-server-relay2} for configuration examples.
\item[interface-id] -- (scope: interface, type: integer, default: not
	    defined). Used in relay definition. Each relay interface
	    should have defined its unique identified. It will be sent
	    in the \opt{interface-id} option. Note that this value
	    must be the same as configured in the dibbler-relay. It
	    may be possible to specify this parameter by using a
	    number (option will be 4 bytes long), a string or a full
	    hex dump.  See
	    \ref{features-relays}, \ref{example-server-relay1} and
	    \ref{example-relay} for details.
 \item[vendor-spec] -- (scope: interface, type: integer-hexstring,
	    default: not defined). This parameter can be used to
	    configure some vendor-specific information option. Since
	    there are no dibbler-specific options, this implementation
	    is flexible. User can specify in the configuration file,
	    how should this option look like. See
	    \ref{example-server-vendor-spec} section for details. It
	    is uncommon, but possible to define several vendor
	    specific options for different vendors. In such case,
	    administrator must specify coma separated list. Each list
	    entry is a vendor (enterprise number), ,,--'' sign and a
	    hex dump (similar to DUID).
 \item[T1] -- (scope: class, type: integer or integer range: default:
	    $2^{32}-1$). This value
	    defines after what time client should start renew
	    process. Exact value or accepted range can be
	    specified. When exact value is defined, client's hints are
	    ignored completely.
 \item[T2] -- (scope: class, type: integer or integer range, default:$2^{32}-1$). This value
	    defines after what time client will start emergency rebind
	    procedure if renew process fails. Exact value or accepted range can be
	    specified. When exact value is defined, client's hints are
	    ignored completely.
\item[valid-lifetime] (scope: class, type: integer or integer range,
	    default:$2^{32}-1$). This parameter defines valid lifetime of
	    the granted addresses. If range is specified, client's
	    hints from that range are accepted.
\item[prefered-lifetime] (scope: class, type: integer or integer range,
	    default:$2^{32}-1$). This parameter defines prefered
	    lifetime of the granted addresses. If range is specified,
	    client's hits from that range will be accepted.
\item[class-max-lease]  -- (scope: interface, type: interger,
	    default:$2^{32}-1$). This parameter defines, how many
	    addresses can be assigned from that class.
\item[reject-clients] -- (scope: class, type: address or DUID list,
	    default: none). This parameter is sometimes called
	    black-list. It is a list of a clients, which should not be
	    supported. Clients can be identified by theirs link-local
	    addresses or DUIDs.
\item[accept-only] -- (scope: class, type: address or DUID list,
	    default: none). This parameter is sometimes called
	    white-list. It is a list of supported clients. When this
	    list is not defined, by default all clients (except
	    mentioned in reject-clients) are supported. When
	    accept-only list is defined, only client from that list
	    will be supported.
\end{description}

\subsubsection{Additional options}
Server supports additional options, not specified in \cite{rfc3315}. They have
following generic form:

\begin{verbatim}
option OptionName OptionsValue
\end{verbatim}

All supported options are specified below:

\begin{description}
 \item[dns-server] -- (scope: interface, type: address list, default:
   none). This option conveys information about DNS servers
   available. After retriving this information, clients will be able
   to resolve domain names into IP (both IPv4 and IPv6)
   addresses. Defined in \cite{rfc3596}.
 \item[domain] -- (scope: interface, type: domain list, default:
   none). This option is used for configuring one or more domain
   names, which clients are connected in. For example, if client's
   hostname is \verb+alice.mylab.example.com+ and it wants to contact
   \verb+bob.mylab.example.com+, it can simply refer to it as
   \verb+bob+. Without domain name configured, it would have to use
   full domain name. Defined in \cite{rfc3596}.
 \item[ntp-server] -- (scope: interface, type: address list, default:
   none). This option defines information about available NTP
   servers. Network Time Protocol \cite{rfc2030} is a protocol used
   for time synchronisation, so all hosts in the network has the same
   proper time set. Defined in \cite{rfc4075}.
 \item[time-zone] -- (scope: interface, type: timezone, default:
   none). It is possible to configure timezone, which is provided by
   the server. Note that this option is considered obsolete as it is
   mentioned in draft version only \cite{draft-timezone}. Work on this
   draft seems to be abandoned as similar functionality is provided by
   now standard \cite{rfc4075}.
 \item[sip-server] -- (scope: interface, type: address list, default:
   none). Session Initiation Protocol \cite{rfc3263} is an control
   protocol for creating, modifying, and terminating sessions with one
   or more participants. These sessions include Internet telephone
   calls, multimedia distribution, and multimedia conferences. Its
   most common usage is VoIP. Format of this option is defined in
   \cite{rfc3319}.
 \item[sip-domain] -- (scope: interface, type: domain list, default:
   none). It is possible to define domain names for Session Initiation
   Protocol \cite{rfc3263}. Configuration of this parameter will ease
   usage of domain names in the SIP protocol. Format of this option is
   defined in \cite{rfc3319}.
 \item[nis-server] -- (scope: interface, type: address list, default:
   none). Network Information Service (NIS) is a Unix-based system
   designed to use common login and user information on multiple
   systems, e.g. universities, where students can log on to ther
   accounts from any host. Its format is defined in \cite{rfc3898}.
 \item[nis-domain] -- (scope: interface, type: domain list, default:
   none). Network Information Service (NIS) can albo specify domain
   names. It can be configured with this option. It is defined in
   \cite{rfc3898}.
 \item[nis+-server] -- (scope: interface, type: address list, default:
   none). Network Information Service Plus (NIS+) is an improved
   version of the NIS protocol. This option is defined in
   \cite{rfc3898}.
 \item[nis+-domain] -- (scope: interface, type: domain list, default:
   none). Similar to nis-domain, it defines domains for NIS+. This
   option is defined in \cite{rfc3898}.
 \item[lifetime] -- (scope: interface, type: boolean, default:
   no). Base spec of the DHCPv6 protocol does offers way of refreshing
   addresses only, but not the options. Lifetime defines, how often
   client should renew all its options. When defined, lifetime option
   will be appended to all replies, which server sends to a client. If
   client does not support it, it should ignore this option. Format of
   this option is defined in \cite{draft-lifetime}.
 \item[aftr] -- (scope: interface, type: FQDN). In Dual-Stack Lite
   networks, client may want to configure DS-Lite tunnel. Client may
   want to obtain information about AFTR (a remote tunnel
   endpoint). This option conveys a fully qualified domain name of the
   remote tunnel. This option is defined in \cite{draft-ds-lite}.
 \item[auth-method] -- (scope: global, type: string, default:
   empty). Set it to one of the following values to enable
   authentication on ther server side, using selected method of
   generating authentication information:
   \begin{itemize}
   \item \texttt{none}
   \item \texttt{digest\_plain}
   \item \texttt{digest\_hmac\_md5}
   \item \texttt{digest\_hmac\_sha1}
   \item \texttt{digest\_hmac\_sha224}
   \item \texttt{digest\_hmac\_sha256}
   \item \texttt{digest\_hmac\_sha384}
   \item \texttt{digest\_hmac\_sha512}
   \end{itemize}
 \item[auth-lifetime] -- (scope: global, type: integer, default:
   0). Authentication lifetime. Currently not supported.
 \item[auth-key-len] -- (scope: global, type: integes, default:
   32). Key generation nonce length (see \cite{draft-aaa} for
   details).
\end{description}

Lifetime is a special case. It is not set up by client in a system
configuration. It is, however, used by the client to know how long
obtained values are correct and initiate \msg{RENEW} or
\msg{INF-REQUEST} message exchange to refresh received options.

\subsection{Server configuration examples}

This subsection contains various examples of the server
configuration. If you are interested in additional examples, download
source version and look at \verb+*.conf+ files.

\subsubsection{Example 1: Simple}

In opposite to client, server uses only interfaces described in config
file. Let's examine this common situation: server has interface named
\emph{eth0} (which is fourth interface in the system) and is supposed
to assign addresses from 2000::100/124 class. Simplest config file
looks like that:

\begin{lstlisting}
# server.conf
iface eth0
{
  class
  {
    pool 2000::100-2000::10f
  }
}
\end{lstlisting}

\subsubsection{Example 2: Timeouts}
Server should be configured to deliver specific timer values to the
clients. This example shows how to instruct client to renew (T1 timer)
addresses one in 10 minutes. In case of problems, ask other servers in
15 minutes (T2 timer), that allowe prefered lifetime range is from 30
minutes to 2 hours, and valid lifetime is from 1 hour to 1 day. DNS
server parameter is also provided. Lifetime option is used to make
clients renew all non-address related options renew once in 2 hours.

\begin{lstlisting}
# server.conf
iface eth0
{
  T1 600
  T2 900
  prefered-lifetime 1800-3600
  valid-lifetime 3600-86400
  class
  {
    pool 2000::100/80
  }

  option dns-server 2000::1234
  option lifetime 7200
}
\end{lstlisting}

\subsubsection{Example 3: Limiting amount of addresses}
Another example: Server should support 2000::0/120 class on eth0
interface. It should not allow any client to obtain more than 5
addresses and should not grant more then 50 addresses in total. From
this specific class only 20 addresses can be assigned. Server
preference should be set to 7. This means that this server is more
important than all server with preference set to 6 or less.
Config file is presented below:

\begin{lstlisting}
# server.conf
iface eth0
{
  iface-max-lease 50
  client-max-lease 5
  preference 7
  class
  {
    class-max-lease 20
    pool 2000::1-2000::100
  }
}
\end{lstlisting}

\subsubsection{Example 4: Unicast communication}
\label{example-server-unicast}

Here's modified previous example. Instead of specified limits, unicast
communication should be supported and server should listen on
2000::1234 address. Note that default multicast address is still
supported. You must have this unicast address already configured on
server's interface.

\begin{lstlisting}
# server.conf
log-level 7
iface eth0
{
  unicast 2000::1234
  class
  {
    pool 2000::1-2000::100
  }
}
\end{lstlisting}

\subsubsection{Example 5: Rapid-commit}
This configuration can be called quick. Rapid-commit is a way to shorten exchange to only two messages. It is
quite useful in networks with heavy load. In case if client does not
support rapid-commit, another trick is used. Preference is set to
maximum possible value. 255 has a special meaning: it makes client to
skip wait phase for possible advertise messages from other servers and
quickly request addresses.

\begin{lstlisting}
# server.conf
log-level 7
iface eth0
{
  rapid-commit yes
  preference 255
  class
  {
    pool 2000::1/112
  }
}
\end{lstlisting}

\subsubsection{Example 6: Access control}
Administrators can selectively allow certain client to use this
server (white-list). On the other hand, some clients could be
explicitly forbidden to use this server (black-list). Specific DUIDs,
DUID ranges, link-local addresses or the whole address ranges are
supported. Here is config file:

\begin{lstlisting}
# server.conf
iface eth0
{
  class
  {
    # duid of the rejected client
    reject-clients ``00001231200adeaaa''
    2000::2f-2000::20  // it's in reverse order, but it works.
		       // just a trick.
  }
}
iface eth1
{
  class
  {
    accept-only fe80::200:39ff:fe4b:1abc
    pool 2000::fe00-2000::feff
  }
}
\end{lstlisting}

\subsubsection{Example 7: Multiple classes}
Although this is not common, a few users have requested support for multiple classes on one interface.
Dibbler server can be configured to use several classes. When client asks for an address, one of the classes
is being choosen on a random basis. If not specified otherwise, all classes have equal probability of being chosen.
However, this behavior can be modified using \verb+share+ parameter. In the following example, server supports
3 classes with different preference level: class 1 has 100, class 2 has 200 and class 3 has 300. This means that class 1
gets $\frac{100}{100+200+300} \approx 16\% $ of all requests, class 2
gets $\frac{200}{100+200+300} \approx 33\% $ and class 3 gets the rest
($\frac{300}{100+200+300}=50\% $).

\begin{lstlisting}
# server.conf
log-level 7
log-mode short

iface eth0 {
 T1 1000
 T2 2000

 class {
   share 100
   pool 4000::1/80
 }
 class {
   share 200
   pool 2000::1-2000::ff
 }

 class {
   share 300
   pool 3000::1234:5678/112
 }
}
\end{lstlisting}

\subsubsection{Example 8: Relay support}
\label{example-server-relay1}
To get more informations about relay configuration, see section \ref{features-relays}.
Following server configuration example explains how to use
relays. There is some remote relay with will send encapsulated data over
eth1 interface. It is configured to append interface-id option set to
5020 value. Let's allow all clients using this relay some addresses
and information about DNS servers. Also see section
\ref{example-relay-1} for corresponding relay configuration.

Note that although eth1 interface is mentioned in the configuration file,
direct traffic from clients located on the eth1 interface will not be
supported. In this example, eth1 is used only to support requests
relayed from remote link identified with interface-id value 5020.
Of course it is possible to support both local and remote traffic. In
such case, normal eth1 definition should be present in the server
configuration file. Also note that real (physical) interfaces should
be specified before logical ones.

\begin{lstlisting}
# server.conf
iface relay1 {
  relay eth1
  // interface-id 5020
  // interface-id "some interface name"
  interface-id 0x427531264361332f3000001018680f980000

  class {
    pool 2000::1-2000::ff
  }
  option dns-server 2000::100,2000::101
}
\end{lstlisting}

\subsubsection{Example 9: Cascade 2 relays}
\label{example-server-relay2}
This is an advanced configuration. It assumes that client sends data to
relay1, which encapsulates it and forwards it to relay2, which
eventually sends it to the server (after additional encapsulation). It
assumes that first relay adds interface-id option set to 6011 and
second one adds similar option set to 6021. For details about relays
in general and cascade setup in particular, see section
\ref{features-relays}. Also see section \ref{example-relay-cascade}
for corresponding relays configuration.

\begin{lstlisting}
# server.conf
iface relay1
{
  relay eth0
  interface-id 6011
}

iface relay2
{
  relay relay1
  interface-id 6021
  T1 1000
  T2 2000
  class {
    pool 6020::20-6020::ff
  }
}
\end{lstlisting}

\subsubsection{Example 10: Dynamic DNS (FQDN)}
\label{example-server-fqdn}

Support for Dynamid DNS Updates was added recently. To configure it
on the server side, list of available names must be defined. Each name
can be reserved for a certain address or DUID. When no reservation is
specified, it will available to everyone, i.e. the first client asks
for FQDN will get this name. In following example, name 'zebuline.example.com' is
reserved for address 2000::1, kael.example.com is reserved for 2000::2 and
test.example.com is reserved for client using DUID
00:01:00:00:43:ce:25:b4:00:13:d4:02:4b:f5.

Also note that is required to define, which side can perform updates.
This is done using single number after ,,option fqdn'' phrase. Server
can perform two kinds of DNS Updates: AAAA (forward resolving,
i.e. name to address) and PTR (reverse resolving, i.e. address to
name). To configure server to execute both updates, specify 2. This is
a default behavior. If this value will be skipped, server will attempt
to perform both updates. When 1 will be specified, server will update
PTR record only and will leave updating AAAA record to the
client. When this value is set to 0, server will not perform any
updates.

The last parameter (64 in the following example) is a prefix length of
the reverse domain supported by the DNS server, i.e. if this is set to
64, and 2000::/64 addresses are used, DNS server must support
0.0.0.0.0.0.0.0.0.0.0.0.0.0.2.ip6.arpa. zone.

\begin{lstlisting}
# server.conf
log-level 8
log-mode precise
iface "eth1" {
 prefered-lifetime 3600
 valid-lifetime 7200
 class {
   pool 2000::1-2000::ff
 }

 option dns-server 2000::100,2000::101
 option domain example.com, test1.example.com
 option fqdn 2 64
	zebuline.example.com - 2000::1,
	kael.example.com - 2000::2,
	test.example.com - 0x0001000043ce25b40013d4024bf5,
	zoe.example.com,
	malcolm.example.com,
	kaylee.example.com,
	jayne.example.com
}
\end{lstlisting}

\subsubsection{Example 11: Vendor-specific Information option}
\label{example-server-vendor-spec}
It is possible to configure dibbler-server to provide vendor-specific
information options. Since there are no dibbler-specific parameters,
this implementation is quite flexible. Enterprise number as well as
content of the option itself can be configured.

\begin{lstlisting}
# server.conf
log-level 8
log-mode precise
iface "eth1" {
 class {
   pool 2000::1-2000::ff
 }

 option vendor-spec 1234-0x00002fedc
}
\end{lstlisting}

In some rare cases, several different options for different vendors
may be specifed. In the folloging example 2 different values are
defined, depending on which vendor client will specify in \msg{SOLICIT} or
\msg{REQUEST} message. If client will only mention that it is interested in
any vendor specific into (i.e. did not sent \opt{vendor-spec info} option, but
only mentioned in in \opt{option request} option, it will receive
first vendor option defined (in the following example, that would be a
1234 and 0002fedc).

\begin{lstlisting}
# server.conf
log-level 8
log-mode precise
iface "eth1" {
 class {
   pool 2000::1-2000::ff
 }

 option vendor-spec 1234-0x00002fedc,5678-0x0002aaaa
}
\end{lstlisting}

\subsubsection{Example 12: Per client configuration}
\label{example-server-exceptions}
Usually all clients receive the same configuration options, e.g. all
clients will use the same DNS server. However, it is possible to
specify that particular clients should receive different options than
others. Following example set DNS server to 2000::1, domain
to example.com and vendor specific information for vendor 5678.
However, if requesting client has DUID 00:01:02:03:04:05:06:07:08, it
will receive different parameters (second.client.biz domain,
1234::5678:abcd as a DNS server and finally different vendor-specific
information). Also client with DUID 0x0001000044e8ef3400085404a324
will receives normal domain and DNS server, but different (vendor=2)
vendor specific information. See section \ref{features-exceptions} for
background information. Since 0.8.0RC1, also addresses can be reserverd
in this way.

\begin{lstlisting}
# server.conf
iface "eth0" {

 class {
   pool 2000::1/64
 }

# common configuration options, provided for all clients
 option dns-server 2000::1
 option domain example.com
 option vendor-spec 5678-0x0002aaaa

  # special parameters for client with DUID 00:01:02:03:04:06
  client duid 0x000102030406
  {
	address 2001::123
	option domain second.client.biz
	option dns-server 1234::5678:abcd
	option vendor-spec 2-0x000122, 22-0x222222
  }

  # special address reserved for client with this remote-id option
  # (remote-id option may be added by relays)
  client remote-id 5-0x01020304
  {
	address 2000::0102:0304
	option domain our.special.remoteid.client.org
  }

  #  client link-local fe80::211:25ff:fe12:6688
  #  (link-local reservation is not supported yet. configure clients
  #  to use DUID-LL (link-local address based DUID) and then make
  #  DUID based reservations)
  #  {
  #      option domain link.local.detected.interop.test.com
  #  }

}
\end{lstlisting}

\subsubsection{Example 13: Prefix delegation}
\label{example-server-prefix}

Prefix delegation works quite similar to normal address granting.
Administrator defines pool and server provides prefixes from that
pool. Before using prefix delegation, please read section
\ref{features-prefix}. Client configuration example is described in section
\ref{example-client-prefix}.

\begin{lstlisting}
# server.conf
log-mode precise

iface "eth0" {

 # the following lines instruct server to grant each client
 # prefix for this pool. For example, client might get
 # 2222:2222:2222:2222:2222:993f::/96
 pd-class {
	pd-pool 2222:2222:2222:2222:2222::/80
	pd-length 96
	T1 11111
	T2 22222
    }

}
\end{lstlisting}

\subsubsection{Example 14: Multiple prefixes}
\label{example-server-prefixes}
It is possible to define more than one pool, so each client will
receive several prefixes. It is necessary to define each pool with the
same length, i.e. it is not possible to mix different pool lengths.
See section \ref{features-prefix} for prefix delegation background
information. Client configuration example is described in section
\ref{example-client-prefix}.

\begin{lstlisting}
# server.conf
log-mode precise

iface "eth0" {

 T1 1800
 T2 2700
 prefered-lifetime 3600
 valid-lifetime 7200

 # provide addresses from this pool
 class {
   pool 5000::/48
 }

 # the following lines instruct server to grant each client
 # 2 prefixes. For example, client might get
 # 2222:2222:2222:2222:2222:993f:6485::/96 and
 # 1111:1111:1111:1111:1111:993f:6485::/96
 pd-class {
	pd-pool 2222:2222:2222:2222:2222::/80
	pd-pool 1111:1111:1111:1111:1111::/80
	pd-length 96
	T1 11111
	T2 22222
    }

}
\end{lstlisting}

\subsubsection{Example 15: Inactive mode}
\label{example-server-inactivemode}
See sections \ref{example-client-inactivemode} and
\ref{feature-inactive-mode} for inactive mode explanation.
The same behavior has been added for server.

\begin{lstlisting}
#server.conf

log-level 8

inactive-mode

iface "eth0" {

 class {
   pool 2000::/64
 }
}
\end{lstlisting}

\subsubsection{Example 16: Leasequery}
A separate entity
called requestor can send queries regarding assigned addresses and
prefixes. Server can be configured to support such lease queries.
See section \ref{features-leasequery} for detailed explanation.

\begin{lstlisting}
#server.conf

log-level 8

iface "eth0" {
 accept-leasequery

 class {
   pool 2000::/64
 }
}
\end{lstlisting}


\subsubsection{Example 17: Authentication}
\label{example-server-auth}
It is possible to configure server to require authentication. In this
example, HMAC-SHA-512 will be used as an authentication method.
Key Generation Nonce will have 64 bytes.

\begin{lstlisting}
# server.conf

auth-method digest-hmac-sha512
auth-key-len 64

iface eth0
{
  class
  {
    pool 2000::100-2000::10f
  }
}
\end{lstlisting}

\subsubsection{Example 18: Relay support with unknown interface-id}
\label{example-server-relay3}
To get more informations about relay configuration, see section \ref{features-relays}.
In pervious examples (\ref{example-server-relay1},
\ref{example-server-relay2}) it was assumed that interface-id set by
relay is known. However, in some cases that is not true. If sysadmin
wants to accept relayed messages from any relay, there is a feature
called guess mode. It tries to match any relay defined in server.conf
instead of exactly checking interface-id value.

Since there is only one relay defined, it will be used, regardless of
the interface-id value (or even lack of thereof).

\begin{lstlisting}
# server.conf
guess-mode

iface relay1 {
  relay eth1
  interface-id 5020
  class {
    pool 2000::1-2000::ff
  }
  option dns-server 2000::100,2000::101
}
\end{lstlisting}


\subsubsection{Example 19: DS-Lite tunnel (AFTR)}
Server is able to provide Dual-Stack lite configuration for clients.
Both address and name based configurations are supported:

\begin{lstlisting}
iface "eth0" {
 class {
   pool 2001:db8::/64
 }

 option ds-lite 2001:db8:1::ffff
 option ds-lite sc.example.org
}
\end{lstlisting}

\subsubsection{Example 20: Custom options}
Server may be configured to also provide custom options to the
clients. See Section \ref{features-custom-options} for details.

\begin{lstlisting}
iface "eth0" {
 class {
   pool 2001:db8::/64
 }
 option 145 - 01:02:a3:b4:c5:dd:ea
 option 146 address 2001:db8:1::dead:beef
 option 147 address-list 2001:db8:1::aaaa,2001:db8:1::bbbb
 option 148 string "secretlair.example.org"
}
\end{lstlisting}


\subsubsection{Example 21: Remote Autoconfiguration}
Server does support experimental extension called remote
autoconfiguration, as defined in \cite{draft-remote-autoconf}. See
Section \ref{features-remote-autoconf} for details and configuration
examples.

\subsection{Relay configuration file}
\label{relay-conf}
Relay configuration is stored in \verb+relay.conf+ file in the
\verb+/etc/dibbler/+ directory (Linux systems) or in current directory
(Windows systems).

\subsubsection{Global scope}

Every option can be declared in global scope.
Config file consists of global options and one or more inteface
definitions. Note that reasonable minimum is 2 interfaces, as defining
only one would mean to resend messages on the same interface.

\subsubsection{Interface declaration}

Interface can be declared this way:
\begin{verbatim}
iface name_of_the_interface
{
  interface options
}
\end{verbatim}

or

\begin{verbatim}
iface number
{
  interface options
}
\end{verbatim}

where name\_of\_the\_interface denotes name of the interface and
number denotes it's number. It does not need to be enclosed in
single or double quotes (except windows cases, when interface name
contains spaces).

\subsubsection{Options}

Every option has a scope it can be used in, default value and
sometimes allowed range.

\begin{description}
 \item[log-level] -- (scope: global, type: integer, default: 7) Defines
	    verbose level of the log messages. The valid range if
	    from 1 (Emergency) to 8 (Debug). The higher the logging
	    level is set, the more messages dibbler will print.
 \item[log-name] -- (scope: global, type: string, default: Client). Defines
	    name, which should be used during logging.
 \item[log-mode] -- (scope: global, type: short, full or precise,
	    default value: full) Defines logging mode. In the
	    default, full mode, name, date and time in the h:m:s format
	    will be printed. In short mode, only minutes and
	    seconds will be printed (this mode is useful on
	    terminals with limited width). Recently added precise
	    mode logs information with seconds and microsecond
	    precision. It is a useful for finding bottlenecks in
	    the DHCPv6 autoconfiguration process.
\item[interface-id-order] -- (scope: global, type: before, after or omit,
	default: before) Defines placement of the
	interface-id option. Options can be placed in the \msg{RELAY-FORW}
	message is arbitrary order. This option has been specified to control
	that order. \opt{interface-id} option can be placed before or after
	\opt{relay-message} option. There is also possibility to instruct
	server to omit the \opt{interface-id} option altogether, but since
	this violates \cite{rfc3315}, it should not be used. In general, this
	configuration parameter is only useful when dealing with buggy relays,
	which can't handle all option orders properly. Consider this parameter
	a debugging feature. Note: similar parameter is available in the dibbler-server.

\item[client multicast] -- (scope: interface, type: boolean, default: false)
	This command instructs dibbler-relay to listen on this particular interface
	for client messages sent to multicast (ff02::1:2) address.
\item[client unicast] -- (scope: interface, type: address, default: not defined)
	This command instructs dibbler-relay to listen to messages sent to a specific
	unicast address. This feature is usually used to connect multiple relays
	together.
\item[server multicast] -- (scope: interface, type: boolean, default: false)
	This command instructs dibbler-relay to send messages (received on any interface)
	to the server multicast (ff05::1:3) address. Note that this is not the same
	multicast address as the server usually listens to (ff02::1:2). Server must be
	specifically configured to be able to receive relayed messages.
\item[server unicast] -- (scope: interface, type: address, default: none)
	This command instructs dibbler-relay to send message (received on any interface)
	to speficied unicast address. Server must be properly configured to to be able to
	receive unicast traffic. See \emph{unicast} command in the \ref{example-server-unicast}
	section.
\item[interface-id] -- (scope: interface, type: integer, default: none)
	This specifies identifier of a particular interface. It is used to generate
	\opt{interface-id} option, when relaying message to the server. This option
	is then used by the server to detect, which interface the message originates from.
	It is essential to have consistent interface-id defined on the relay side and
	server side. It is worth mentioning that interface-id should be specified on the
	interface, which is used to receive messages from the clients, not the
	one used to forward packets to server.
\item[guess-mode] -- (scope: global, type: boolean, default: no)
	Switches relay into so called guess-mode. Under normal operation, client sends
	messages, which are encapsulated and sent to the server. During this encapsulation
	relay appends \opt{interface-id} option and expects that server will use the same
	\opt{interface-id} option in its replies. Relay then uses those \opt{interface-id}
	values to detect, which the original request came from and sends reply to the same
	interface. Unfortunately, some servers does not sent \opt{interface-id} option.
	Normally in such case, dibbler-relay drops such server messages as there is no
	easy way to determine where such messages should be relayed to. However, when
	guess-mode is enabled, dibbler-relay tries to guess the destination interface.
	Luckily, it is often trivial to guess as there are usually 2 interfaces: one
	connected to server and second connected to the clients.
\end{description}

\subsection{Relay configuration examples}
\label{example-relay}

Relay configuration file is fairly simple. Relay forwards DHCPv6
messages between interfaces. Messages from client are encapsulated and
forwarded as RELAY\_FORW messages. Replies from server are received as
RELAY\_REPL message. After decapsulation, they are being sent back to
clients.

It is vital to inform server, where this relayed message was
received. DHCPv6 does this using interface-id option. This identifier
must be unique. Otherwise relays will get confused when they will
receive reply from server. Note that this id does not need to be
alligned with system interface id (ifindex). Think about it as
"ethernet segment identifier" if you are using Ethernet network or as
"bss identifier" if you are using 802.11 network.

If you are interested in additional examples, download source version
and look at \verb+*.conf+ files.

\subsubsection{Example 1: Simple}
\label{example-relay-1}
Let's assume this case: relay has 2 interfaces: eth0 and
eth1. Clients are located on the eth1 network. Relay should receive
data on that interface using well-known ALL\_DHCP\_RELAYS\_AND\_SERVER
multicast address (ff02::1:2). Note that all clients use multicast
addresses by default. Packets received on the eth1 should be
forwarded on the eth0 interface, using multicast address. See section
\ref{example-server-relay1} for corresponding server configuration.

\begin{lstlisting}
# relay.conf
log-level 8
log-mode short
iface eth0 {
  server multicast yes
}
iface eth1 {
  client multicast yes
  interface-id 5020
}
\end{lstlisting}

\subsubsection{Example 2: Unicast/multicast}
It is possible to use unicast addresses instead/besides of default
multicast addresses. Following example allows message reception from
clients on the 2000::123 address. It is also possible to instruct
relay to send encapulated messages to the server using unicast
addresess. This feature is configured in the next section
(\ref{example-relay-multiple}).

\begin{lstlisting}
# relay.conf
log-level 8
log-mode short
iface eth0 {
  server multicast yes
}
iface eth1 {
  client multicast yes
  client unicast 2000::123
  interface-id 5020
}
\end{lstlisting}

\subsubsection{Example 3: Multiple interfaces}
\label{example-relay-multiple}
Here is another example. This time messages should be forwarded from
eth1 and eth3 to the eth0 interface (using multicast) and to the eth2
interface (using server's global address 2000::546). Also clients must
use multicasts (the default approach):

\begin{lstlisting}
# relay.conf
iface eth0 {
  server multicast yes
}
iface eth2 {
  server unicast 2000::456
}
iface eth1 {
  client multicast yes
  interface-id 1000
}
iface eth3 {
  client multicast yes
  interface-id 1001
}
\end{lstlisting}

\subsubsection{Example 4: 2 relays}
\label{example-relay-cascade}
Those two configuration files correspond to the ,,2 relays'' example
provided in section \ref{example-server-relay2}. See section
\ref{features-relays} for detailed exmplanations.

\begin{lstlisting}
# relay.conf - relay 1
log-level 8
log-mode full

# messages will be forwarded on this interface using multicast
iface eth2 {
   server multicast yes    // relay messages on this interface to ff05::1:3
 # server unicast 6000::10 // relay messages on this interface to this global address
}

iface eth1 {
#  client multicast yes    // bind ff02::1:2
  client unicast 6011::1   // bind this address
  interface-id 6011
}
\end{lstlisting}

\begin{lstlisting}
# relay.conf - relay 2
iface eth0 {
#   server multicast yes  // relay messages on this interface to ff05::1:3
  server unicast 6011::1  // relay messages on this interface to this global address
}

# client can send messages to multicast
# (or specific link-local addr) on this link
iface eth1 {
  client multicast yes    // bind ff02::1:2
# client unicast 6021::1  // bind this address
  interface-id 6021
}
\end{lstlisting}

\subsubsection{Example 5: Guess-mode}
In the 0.6.0 release, a new feature called guess-mode has been
added. When client sends some data and relay forwards it to the
server, it always adds interface-id option to specify, which link
the data has been originally received on. Server, when responding to
such request, should include the same interface-id option in the
reply. However, in some poor implementations, server fails to do
that. When relay receives such poorly formed response from the server,
it can't decide which interface should be used to relay this
message.

Normally such packets are dropped. However, it is possible to switch
relay into a guess-mode. It tries to find any suitable interface,
which it can forward data on. It is not very reliable, but sometimes
it is better than dropping the message altogether.

\begin{lstlisting}
# relay.conf
log-level 8
log-mode short
guess-mode

iface eth0 {
  server multicast yes
}
iface eth1 {
  client multicast yes
  interface-id 5020
}
\end{lstlisting}

\subsubsection{Example 6: Relaying to multicast}
During normal operation, relay sends forwarded messages to a
\emph{All\_DHCP\_Servers} (FF05::1:3) multicast address.

Although author does not consider this an elegant solution, it is also
possible to instruct relay to forward message to a \emph{All\_DHCP\_Relay\_Agents\_and\_Servers}
(ff02::1:2) multicast address. That is quite convenient when there are several
relays connected in a cascade way (server -- relay1 -- relay2 -- clients).

For details regarding DHCPv6-related multicast addresses and relay operation, see \cite{rfc3315}.

To achieve this behavior, \emph{server unicast} can be used. Note that
name of such parameter is a bit misleading (``server unicast'' used to specify
multicast address). That parameter should be rather called ``destination address'',
but to maintain backward compatibility, it has its current name.

\begin{lstlisting}
# relay.conf
log-level 8
log-mode short

iface eth0 {
  server unicast ff02::1:2
}
iface eth1 {
  client multicast yes
  interface-id 5020
}
\end{lstlisting}

\subsection{Requestor configuration}
Requestor (entity used for leasequery) does not use configuration
files. All parameters are specified by command-line switches. See
section \ref{features-leasequery} for details.
