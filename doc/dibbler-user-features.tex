\section{Features HOWTO}
This section contains information about setting up various Dibbler
features. Since this section was added recently, it is not yet
comprehensive. That is expected to change.

\subsection{Stateless vs stateful and IA, TA options}
\label{features-stateless-stateful}
This section explains the difference between stateless and stateful
configurations. IA and TA options usage is also described.

Usually, normal stateful configuration based on non-temporary
addresses should be used. If you don't know, what temporary addresses
are, you don't need them.

There are two kinds of configurations in DHCPv6 (\cite{rfc3315}, \cite{rfc3736}):
\begin{description}
  \item[stateful] -- it assumes that addresses (and possibly other parameters)
    are assigned to a client. To perform this kind of configuration,
    four messages are exchanged: \msg{SOLICIT}, \msg{ADVERTISE},
    \msg{REQUEST} and \msg{REPLY}.
  \item[stateless] -- when only parameters are configured (without
    assigning addresses to a client). During execution of this type of
    configuration, only two messages are exchanged: \msg{INF-REQUEST}
    and \msg{REPLY}.
\end{description}

During normal operation, client works in a stateful mode. If not
instructed otherwise, it will request one or more normal (i.e. non-temporary)
address. It will use \opt{IA} option (Identity Association for
Non-temporary Addresses, see \cite{rfc3315} for details) to request
and retrieve addresses. Since this is a default behavior, it does not
have to be mentioned in the client configuration
file. Nevertheless, it can be provided:

\begin{lstlisting}
# client.conf
iface eth0 {
  ia
  option dns-server
}
\end{lstlisting}

In a specific circustances, client might be interested in obtaining
only temporary addresses. Although this is still a stateful mode, its
configuration is sligtly different. There is a special option called \opt{TA}
(Identity Association for Temporary Addresses, see \cite{rfc3315} for
details). This option will be used to request and receive temporary
addresses from the client. To force client to request temporary
addresses instead of permanent ones, \verb+ta+ keyword must be used in
client.conf file. If this option is defined, only temporary address
will be requested. Keep in mind that temporary addresses are not
renewed.

\begin{lstlisting}
# client.conf
iface eth0 {
  ta
  option dns-server
}
\end{lstlisting}

It is also possible to instruct client to work in a stateless mode. It
will not ask for any type of addresses, but will ask for specific
non-adress related configuration parameters, e.g. DNS Servers
information. This can be achieved by using \verb+stateless+
keyword. Since this is a global parameter, it is not defined on any
interface, but as a global option.

\begin{lstlisting}
# client.conf
stateless
iface eth0
{
  option dns-server
}
\end{lstlisting}

Some of the cases mentioned above can be used together. However,
several combinations are illegal. Here is a complete list:
\begin{description}
\item[none] -- When no option is specified, client will assume one IA
	   with one address should be requested. Client will send
	   \verb+ia+ option (stateful autoconfiguration).
\item[ia] -- Client will send \verb+ia+ option (stateful
  autoconfiguration).
\item[ia,ta] -- When both options are specified, client will request
  for both - Non-temporary as well as Temporary addresses (stateful
  autoconfiguration).
\item[stateless] -- Client will request additional configration
  parameters only and will not ask for addresses (stateless
  autoconfiguration).
\item[stateless,ia] -- This combination is not allowed.
\item[stateless,ta] -- This combination is not allowed.
\item[stateless,ia,ta] -- This combination is not allowed.
\end{description}

\subsection{DNS Update}
\label{features-fqdn}
\Note In this section, we will assume that hostnames will be used
from the example.com domain and that addresses will be provided from the
2000::/64 pool. 

\begin{figure}[ht]
\begin{center}
\includegraphics[width=0.7\textwidth]{dibbler-fqdn-srv-update}
\caption{\emph{DNS Update (performed by server)}}
\end{center}
\end{figure}

During normal operation, DHCPv6 client receives one or more IPv6 address(es)
from DHCPv6 server. If configured to do so, it can also receive
information about DNS server addresses. As an additional service, DNS
Update can be performed. This feature, sometimes known as Dynamic DNS,
keeps DNS entries up to date. When client boots, it gets its fully
qualified domain name and this name can be used to reach this
particular client by other nodes. Details of this mechanism is described
in \cite{rfc4704}.

There are two types of the DNS Updates. First is a so called forward
resolving. It allows to change a node's name into its address,
e.g. malcolm.example.com can be translated into 2000::123. Other kind
of record, which can be updated is a so called reverse resolving. It
allows to obtain full name of a node with know address, e.g. 2000::124
can be translated into zoe.example.com.

To configure this feature, following steps must be performed:

\begin{enumerate}
\item Configure DNS server. DNS server supporting IPv6 and dynamic
  updates must be configured. One example of such server is a BIND
  9.3. It is necessary to allow listening on the IPv6 sockets and
  define that specific domain can be updated. See example below.
\item Configure Dibbler server to provide DNS server informations for
  clients. DNS Updates will be sent to the first DNS server on the
  list of available servers.
\item Configure Dibbler server to work in stateful mode, i.e. that it
  can provide addresses for the clients. This is a default mode, so
  unless configuration was altered, this step is already done. Make
  sure that there is no ,,stateless'' keyword in the
  \verb+server.conf+ file.
\item Define list of the available names in the server configuration
  file. Make sure to use fully qualified domain names
  (e.g. malcolm.example.com), not the hostnames only. 
\item Configure dibbler client to request for DNS Update. Use ,,option
  fqdn'' to achieve this. 
\item Server can be configured to execute 
      \begin{itemize}
       \item both (AAAA and PTR) updates by itself
       \item execute PTR only by itself and let client execute AAAA
	     update
       \item don't perform any updates and let client perform AAAA
	     update.
      \end{itemize}
\end{enumerate}

Note that only server is allowed to execute PTR updates. After
configuration, client and/or server should log following line, which
informs that Dynamic DNS Update was completed successfully.

\begin{verbatim}
2006.07.24 01:52:51 Client Notice    FQDN Configured successfully !
\end{verbatim}

\begin{figure}[ht]
\begin{center}
\includegraphics[width=0.7\textwidth]{dibbler-fqdn-cli-update}
\caption{\emph{DNS Update (performed by client)}}
\end{center}
\end{figure}

\subsubsection{Example BIND configuration}
Below are example configuration files for the BIND 9.3. First is a
relevant part of the /etc/bind/named.conf configuration file. Generally,
support for IPv6 in BIND is enabled (listen-on-v6) and there are two
zones added: example.com (normal domain) and
0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.2.ip6.arpa (reverse
mapping). Corresponding files are stored in \verb+example.com+ and
\verb+rev-2000+ files. For details about meaning of those directives,
please consult \emph{BIND 9 Administrator Reference Manual}.

\Note Provided configuration is not safe from the security point of
view. See next subsection for details.
  
\begin{lstlisting}
// part of the /etc/bind/named.conf configuration file
options {
    listen-on-v6 { any; };
    listen-on    { any; };

    // other global options here
    // ...
};

zone "example.com" {
    type master;
    file "example.com";
    allow-update   { any; };
    allow-transfer { any; };
    allow-query    { any; };

    // other example.com domain-specific 
    // options follow
    // ...
};

zone "0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.2.ip6.arpa" {
    type master;
    file "rev-2000";
    allow-update   { any; };
    allow-transfer { any; };
    allow-query    { any; };

   // other 2000::/64 reverse domain related 
   // options follow
   // ...
};
\end{lstlisting}

% \vspace{-0.3cm}
% \begin{center}
% BIND's named.conf example
% \end{center}

Below are examples of two files: forward and reverse zone. First example
presents how to configure normal domain. As an example there is entry
provided for zoe.example.com host, which has 2000::123 address. Note
that you do not have to manually configure such entries -- dibbler will
do this automatically. It was merely provided as an example, what kind
of mapping will be done in this zone.

\begin{lstlisting}
; 
$ORIGIN .
$TTL 86400      ; 1 day
example.com             IN SOA  v13.klub.com.pl. root.v13.klub.com.pl. (
                                129        ; serial
                                7200       ; refresh (2 hours)
                                3600       ; retry (1 hour)
                                604800     ; expire (1 week)
                                86400      ; minimum (1 day)
                                )
                        NS      v13.klub.com.pl.
                        A       1.2.3.4
                        TXT     "Fake domain used for Dibbler tests."
$ORIGIN example.com.
$TTL 7200       ; 2 hours
zoe                     AAAA    2000::123
\end{lstlisting}

Second example presents zone file for reverse mapping. It contains
entries for a special zone called
0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.2.ip6.arpa. This zone represents 2000::/64
address space. As an example there is a static entry, which maps address
2000::999 to a canonical name kaylee.example.com. Note that you do not
have to manually configure such entries -- dibbler will do this
automatically. It was merely provided as an example, what kind
of mapping will be done in this zone.

\begin{lstlisting}
; rev-2000 example file
$ORIGIN .
$TTL 259200     ; 3 days

; this line below is split in two due to page with limitation
0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.2.ip6.arpa IN 
      SOA 0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.2.ip6.arpa. hostmaster.ep.net. (
; this line above is split in two due to page with limitation
                                200608268  ; serial
                                86400      ; refresh (1 day)
                                1800       ; retry (30 minutes)
                                172800     ; expire (2 days)
                                259200     ; minimum (3 days)
                                )
                        NS      klub.com.pl.
$ORIGIN 0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.2.ip6.arpa.
$TTL 86200      ; 23 hours 56 minutes 40 seconds
3.2.1                   PTR     picard.example.com.

; this line below is split in two due to page with limitation
9.9.9                   PTR     kaylee.example.com.
$ORIGIN 0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.2.ip6.arpa.

; example entry: 2000::999 -> troi.example.com.
; this line below is split in two due to page with limitation
9.9.9.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.2.ip6.arpa 
      PTR troi.example.com.
; this line above is split in two due to page with limitation
\end{lstlisting}
\Note Due to page width limitation, if the example above, two lines were
split. 
%% $

\subsubsection{Dynamic DNS Testing and tips}
Proper configuration of the DNS Update mechanism is not an easy
task. Therefore this section provides description of several methods of
testing and tuning BIND configuration. Please review following steps
before reporting issues to the author or on the mailing list.

\begin{itemize}
\item See example server and client configuration files described in a
      sections \ref{example-client-fqdn} and \ref{example-server-fqdn}. Also
      note that Dibbler distribution should be accompanied with several
      example configuration files. Some of them include FQDN usage examples.
\item Make sure that unix user, which runs BIND, is able to create and
      write file example.com.jnl. When BIND is unable to create this
      journal file, it will fail to accept updates from dibbler and will
      report failure. Check BIND log files, which are usually stored in the
      \verb+/var/log/+ directory.
\item Make sure that you have routing configured properly on a host,
      which will attempt to perform DNS Update. Use ping6 command to
      verify that DNS server is reachable from this host.
\item Make sure that your DNS server is configured properly. To do so,
      you might want to use \verb+nsupdate+ tool. It is part of the BIND
      distribution, but it is sometimes distributed separated as part of
      the dnsutils package. After executing nsupdate tool, specify
      address of the DNS server (\verb+server+ command), specify update
      parameters (\verb+update+ command) and then type \verb+send+. If
      nsupdate return a command prompt, then the update was
      successful. Otherwise nsupdate will print DNS server's response,
      e.g. NOTAUTH of SRVFAIL. See below for examples of successful
      forward (AAAA record) and reverse (PTR record) updates.
\item After DNS Update is performed, DNS records can be verified using
      dig command line tool (a part of the dnsutils package). Command
      syntax is: 
      \verb+dig @(dns-server-address) name record-type+. 
      In the following example, this query checks for name
      jayne.example.com at a server located at 2000::1 address. Record
      type AAAA (standard record for resolving name into IPv6 address)
      is requested. dig tool provides server's response in the
      \verb+ANSWER SECTION:+. See example log below.
\item In example BIND configuration above, zone transfers, queries and
      updates are allowed from anywhere. To make this configuration more
      secure, it might be a good idea to allow updates only from a
      certain range of addresses or even one (DHCPv6 server's) address
      only.
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

To manually make AAAA record update, type:
\begin{lstlisting}
nsupdate
>server 2000::1
>update add worf.example.com 7200 IN AAAA 2000::567
>send
\end{lstlisting}

To manually make PTR record update, type:
\begin{lstlisting}
nsupdate
>server 2000::1
>update add 
3.2.1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.2.ip6.arpa.
86200 IN PTR picard.example.com. 
>send
\end{lstlisting}

\Note Everything between "update" and "picard.example.com" must be typed in one line.

And here is an example dig session:

\begin{lstlisting}
v13:/var# dig @2000::1 jayne.example.com AAAA
; <<>> DiG 9.3.2 <<>> @2000::1 jayne.example.com AAAA
; (1 server found)
;; global options:  printcmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 33416
;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 1, ADDITIONAL: 2

;; QUESTION SECTION:
;jayne.example.com.             IN      AAAA

;; ANSWER SECTION:
jayne.example.com.      7200    IN      AAAA    2001::e4

;; AUTHORITY SECTION:
example.com.            86400   IN      NS      v13.klub.com.pl.

;; Query time: 6 msec
;; SERVER: 2000::1#53(2000::1)
;; WHEN: Mon Jul 24 01:38:13 2006
;; MSG SIZE  rcvd: 136
\end{lstlisting}
%% >>

\subsection{Server address caching}
Previous Dibbler versions assigned a random address from the available
address pool, so the same client received different address each time it
asked for one. In the 0.5.0 release, new mechanism was introduced
to make sure that the same client gets the same address each time. It is
called \emph{Server caching}.

Below is the algorithm used by the server to assign an address to the client.

\begin{itemize}
 \item if the client provided hint, it is valid (i.e. is part of the
       supported address pool) and not used, then assign requested address.
 \item if the client provided hint, it is valid (i.e. is part of the 
       supported address pool) but used, then assign free address from
       the same pool.
 \item if the client provided hint, but it is not valid (i.e. is not
       part of the supported address pool, is link-local or a multicast
       address), then ignore the hint completety.
 \item if the did not provide valid hint (or provided invalid one), try
       to assign address previously assigned to this client (address caching)
 \item if this is the first time the client is seen, assign any address
       available.
\end{itemize}
%% see SrvOptions/SrvOptIA_NA.cpp, TSrvOptIA_NA::getFreeAddr() method

\subsection{Relays}
\label{features-relays}
In small networks, all nodes (server, hosts and routers) are connected
to the same network segment -- usually Ethernet segment or a single
access point or hotspot. This is very convenient as all clients can
reach server directly. However, larger networks usually are connected
via routers, so direct communication is not always possible. On the
other hand it is useful to have one server, which supports multiple
links -- some connected directly and some remotely.

\begin{figure}[ht]
\begin{center}
\includegraphics[width=0.7\textwidth]{dibbler-relay}
\caption{\emph{Relay deployment}}
\end{center}
\end{figure}

Very nice feature of the relays that they appear as actual servers
from the client's point of view. Therefore no special arrangement or
configuration on the client side is required. On the other hand, from
the administrator point of view it is much easier to manage one DHCPv6
server and deploy several relays than manage several servers on remote
links. 

It is important to understand that relays not simply forward DHCPv6
messages. Each message forwarded from client to the server is
encapsulated. Also each message forwarded from server to a client is
decapsulated. Therefore additional server configuration is required to
deal with encapsulated traffic.

To avoid confusion during reference to a specific link (i.e. eth0 on
the relay may be different link than eth0 on the server), each link
must be referred to using its unique interface-id. For simplicity
reasons, Dibbler uses 4 bytes long identifiers, which are specified as
numbers. It is essential to use the same indentifier in the relay
configuration as well as in the server, so both will refer to the same
link using the same number. See section \ref{example-server-relay1} for
example how to configure server and section \ref{example-relay-1} for 
corresponding relay configuration.

\begin{figure}[ht]
\begin{center}
\includegraphics[width=0.7\textwidth]{dibbler-cascade-relays}
\caption{\emph{Cascade relays}}
\label{fig-cascade-relays}
\end{center}
\end{figure}

In larger networks it is sometimes useful to connect multiple
relays. Assuming there are 2 relays connecting server and client. Such
scenario is depicted on figure \ref{fig-cascade-relays}. Requests from
client are received by relay2, which encapsulates and sends them to
relay1. Relay1 further encapsulates those messages and sends them to
the server. Since server receives double encapsulated messages, it
must be properly configured to support such traffic. See section
\ref{example-server-relay2} for details about server configuration and 
section \ref{example-relay-cascade} for example relays configuration.

\subsection{XML files}
\label{features-xml}
During its execution, all dibbler components (client, server and
relay) store its internal information in the XML files. In Linux
systems, they are stored in the \verb+/var/lib/dibbler+ directory. In
Windows, current directory (i.e. directory where exe files are
located) is used instead. There are several xml files generated. Since
they are similar for each component, following list provides
description for server only:

\begin{itemize}
\item server-CfgMgr.xml -- Represents information read from a
  configuration file, e.g. available address pool or DNS server
      configuration.
\item server-IfaceMgr.xml -- Represens detected interfaces in the
  operating system, as well as bound sockets and similar information.
\item server-AddrMgr.xml -- This is database, which contains identity
  associations with associated addresses.
 \item server-cache.xml -- Since caching is implemented by the server
      only, this file is only created by the server. It contains
      information about previously assigned addresses. 
\end{itemize}

\subsection{Prefix delegation}
\label{features-prefix}
According to \cite{rfc3633}: 

\begin{quote}
   The prefix delegation mechanism is
   intended for simple delegation of prefixes from a delegating router
   to requesting routers.  It is appropriate for situations in which the
   delegating router does not have knowledge about the topology of the
   networks to which the requesting router is attached, and the
   delegating router does not require other information aside from the
   identity of the requesting router to choose a prefix for delegation.
   For example, these options would be used by a service provider to
   assign a prefix to a Customer Premise Equipment (CPE) device acting
   as a router between the subscriber's internal network and the service
   provider's core network.
\end{quote}

\begin{figure}[ht]
\begin{center}
\label{fig-prefixes-host}
\includegraphics[width=0.7\textwidth]{dibbler-prefixes-host}
\caption{\emph{Prefix delegation (host behaviour)}}
\end{center}
\end{figure}

To configure server to provide prefixes, a pool must be defined and
also client prefixes' length. For example section below assigns
2000:1234::/32 pool to be managed by this server. From this pool,
server will assign /48 prefixes to the clients. For example, client
can receive prefix 2000:1234:7c34::/48. 

\begin{lstlisting}
pd-class {
    pd-pool 2000:1234::/32
    pd-length 48
}
\end{lstlisting}

As a general rule, server will provide random prefix to a client,
unless client provided a hint. The full prefix assignment algorithm is
as follows:

\begin{enumerate}
\item client didn't provide any hints: one prefix from each pool will
  be granted
\item client has provided hint and that is valid (supported and
  unused): requested prefix will be granted
\item client has provided hint, which belongs to supported pool, but this prefix is used:
  other prefix from that pool will be asigned
\item client has provided hint, but it is invalid (not beloninging to
  a supported pool, multicast or link-local): see point 1
\end{enumerate}

Dibbler implementation supports prefix delegation, but it also
extends it. From the server point of view, everything works according
to specs \cite{rfc3633}. However, client is able to meaningfully use
received prefix, even when packet forwarding is not enabled
(i.e. client is a host, not a router). In fact, this is simpler
scenario, therefore it will be explained first. This scenario is
depicted on Fig. \ref{fig-prefixes-host}. When dibbler client receives
prefix and detects that packet forwarding in not enabled, it will
configure received prefix on the interface, which data has been
received on.

Client's behavior is radically different if packet forwarding is
enabled (i.e. client is a router, not a host). In such scenario, when
client receives prefix on one interface (e.g. prefix
2000:1234:7c34::/48 received on eth0) it will generate subprefixes for
all other interfaces, which are up, running, non-loopback and
multicast capable. In the example depicted on
Fig. \ref{fig-prefixes-router}, received prefix was split into 3
prefixes: 2000:1234:7c34:1000::/56 for eth1, 2000:1234:7c34:2000::/56 for eth2
and 2000:1234:7c34:3000::/56 for eth3.

\begin{figure}[ht]
\begin{center}
\label{fig-prefixes-router}
\includegraphics[width=0.7\textwidth]{dibbler-prefixes-router}
\caption{\emph{Prefix delegation (router behaviour)}}
\end{center}
\end{figure}

It is also possible to define multiple prefix pools. See section
\ref{example-server-prefix} for simple prefix delegation configuration
for server or section \ref{example-server-prefixes} for multiple
prefixes configuration. Also section \ref{example-client-prefix}
provides information related to client configuration.

\subsection{Exceptions: per client configuration}
\label{features-exceptions}
All configuration parameters (except FQDN) are the same for all
clients, e.g. all clients will receive the same domain name and the
same DNS servers information. 

However, it is sometimes useful to provide some clients with different
configuration parameters. For example computers from the accouting
department in a corporate network may be configured to be in a
different subdomain. Is is possible to specify that for particular
client different configuration options should be provided. Each client
is identified by its DUID. This mechanism is called \emph{per client
  configuration}, but it is sometimes referred to as \emph{exceptions}.

Note: This mechanism does not apply to address and prefix granting,
because each client receives unique addresses and unique prefixes anyway.

See section \ref{example-server-exceptions} for server configuration examples.

\subsection{Vendor specific information}
Dibbler supports vendor specific information options. As the name
suggests, that option is specific to a particular vendor. To be able
to support any vendor in a flexible manner, values are specified in a
hex format in \verb+server.conf+. For example:

\begin{lstlisting}
 option vendor-spec 1234-0x00002fedc
\end{lstlisting}

When client asks for a vendor-specific info, server will send
vendor-specific info option with enterprise number set to 1234 and
value option-data will be 00002fedc.

Although uncommon, it is also possible to specify multiple vendor
options. Another \verb+server.conf+ example:

\begin{lstlisting}
 option vendor-spec 1234-0x00002fedc,5678-0x0002aaaa
\end{lstlisting}

Server algorithm for choosing, which vendor option should be sent,
works as follows:

\begin{itemize}
\item When client requests for a speficic vendor (i.e. sends
  \opt{vendor-spec info} option with vendor field set), it will
  receive option for that specific vendor (i.e. requested 1234, got 1234).
 \item When client requests any vendor (i.e. sends only \opt{option request} option
   with vendor-spec mentioned), it will receive first \opt{vendor-spec
     info} option from the list (i.e. 5678/0002aaaa).
 \item When client requests for not supported vendor (i.e. 11111), it will    
   receive first vendor-spec option from the list
   (i.e. 5678/0002aaaa).
\end{itemize}

It is possible to configure Dibbler client to ask for vendor-specific
info. Granted value will not be used, so from the client's point of
view this feature may be used as testing tool for the server. Client
can request \opt{vendor-specific information} option in one of the following ways:

\begin{description}
\item[option vendor-spec] -- Only \opt{option request} option will be sent
  with \opt{vendor-spec info} option mentioned.
\item[option vendor-spec 1234] -- \opt{option request} option will be sent
  with \opt{vendor-spec info} option mentioned, but also \opt{vendor-spec
  info} option with enterprise number set to 1234 will be sent.
\item[option vendor-spec 1234 0x0a0b0c0d] -- \opt{option request} option will be sent
  with \opt{vendor-spec info} option mentioned, but also
\opt{vendor-spec info} option with enterprise number set to 1234 and
option-data will be sent.
\end{description}

Although that is almost never needed, it is possible to configure
client to request multiple vendor-specific options at the same
time. That is also supported by the server. See
\ref{example-client-vendor-spec} for examples.


However, if client sends requests for multiple vendor-specific
options, which are not supported by the server, for each sent option,
server will assign one default vendor-spec option.

See \ref{example-client-vendor-spec} for client example and
\ref{example-server-vendor-spec} for server examples.
